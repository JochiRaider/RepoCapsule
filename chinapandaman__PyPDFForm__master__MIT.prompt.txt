### CODE_OF_CONDUCT.md [1/1] (lang=Markdown)

# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.

### CONTRIBUTING.md [1/1] (lang=Markdown)

## How to Contribute Code

Check out the developer guide on how to contribute to PyPDFForm: https://chinapandaman.github.io/PyPDFForm/dev_intro/

## Other Ways to Contribute

It is difficult to make sure that the library supports all the PDF form creating tools out 
there. So if you run into a case where the library does not work for certain PDF forms created by certain tools, feel free to open an issue with the problematic PDF form attached. I will seek 
to make the library support the attached PDF form as well as the tool used to create it.

### PyPDFForm/__init__.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
PyPDFForm is a pure Python library designed to streamline the process of filling PDF forms programmatically.

It provides a simple and intuitive API for interacting with PDF forms, allowing users to:

- Fill text fields with custom data.
- Check or uncheck checkboxes.
- Select radio button options.
- Add images to image fields.
- Flatten the filled form to prevent further modifications.

The library supports various PDF form features, including:

- Text field alignment (left, center, right).
- Font customization (size, color, family).
- Image field resizing and positioning.
- Handling of complex form structures.

PyPDFForm aims to simplify PDF form manipulation, making it accessible to developers of all skill levels.
"""

__version__ = "3.5.5"

from .middleware.text import Text  # exposing for setting global font attrs
from .widgets import Fields
from .wrapper import PdfWrapper

__all__ = ["PdfWrapper", "Text", "Fields"]

### PyPDFForm/adapter.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module for adapting different types of input to a consistent byte stream.

This module provides utility functions to adapt various types of input,
such as file paths, file-like objects, and byte streams, into a consistent
byte stream format. This is particularly useful when dealing with PDF form
filling operations, where the input PDF template can be provided in different
forms. The module ensures that the input is properly converted into a byte
stream before further processing.
"""

from os.path import isfile
from typing import Any, BinaryIO, Union


def readable(obj: Any) -> bool:
    """
    Check if an object has a readable "read" attribute.

    This function determines whether the provided object has a "read" attribute that is callable.
    It is used to identify file-like objects or streams that can be read from.

    Args:
        obj (Any): The object to check for a readable "read" attribute.

    Returns:
        bool: True if the object has a callable "read" attribute, indicating it is readable.
              Returns False otherwise.
    """
    return callable(getattr(obj, "read", None))


def fp_or_f_obj_or_stream_to_stream(
    fp_or_f_obj_or_stream: Union[bytes, str, BinaryIO],
) -> bytes:
    """
    Adapt a file path, file object, or stream to a byte stream.

    This function takes a file path, a file object, or a byte stream and adapts it to a consistent byte stream.
    It handles different input types, including:
        - byte streams (bytes)
        - file paths (str)
        - file-like objects with a read() method (BinaryIO)

    Args:
        fp_or_f_obj_or_stream (Union[bytes, str, BinaryIO]): The input to adapt.
            It can be a byte stream, a file path (string), or a file object.

    Returns:
        bytes: The byte stream representation of the input.
               Returns an empty byte string if the file path does not exist.
    """
    # not cached to handle writing to the same disk file
    result = b""
    if isinstance(fp_or_f_obj_or_stream, bytes):
        result = fp_or_f_obj_or_stream

    elif readable(fp_or_f_obj_or_stream):
        result = fp_or_f_obj_or_stream.read()

    elif isinstance(fp_or_f_obj_or_stream, str):
        if not isfile(fp_or_f_obj_or_stream):
            pass
        else:
            with open(fp_or_f_obj_or_stream, "rb") as _file:
                result = _file.read()
    return result

### PyPDFForm/constants.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module containing constants used throughout the PyPDFForm library.

This module defines a collection of constants that are used across various
modules within the PyPDFForm library. These constants include:

- String identifiers for PDF syntax elements (e.g., /Annots, /Rect, /FT).
- Numerical values representing field flags (e.g., READ_ONLY, MULTILINE).
- Default values for fonts, font sizes, and font colors.
- Identifiers for image fields and coordinate grid calculations.
- Version identifiers for PDF versions.

Using constants improves code readability and maintainability by providing
meaningful names for frequently used values and reducing the risk of typos.
"""

from typing import Union

from .middleware.checkbox import Checkbox
from .middleware.dropdown import Dropdown
from .middleware.image import Image
from .middleware.radio import Radio
from .middleware.signature import Signature
from .middleware.text import Text

VERSION_IDENTIFIERS = [
    b"%PDF-1.0",
    b"%PDF-1.1",
    b"%PDF-1.2",
    b"%PDF-1.3",
    b"%PDF-1.4",
    b"%PDF-1.5",
    b"%PDF-1.6",
    b"%PDF-1.7",
    b"%PDF-2.0",
]
VERSION_IDENTIFIER_PREFIX = "%PDF-".encode("utf-8")

WIDGET_TYPES = Union[Text, Checkbox, Radio, Dropdown, Signature, Image]

DEPRECATION_NOTICE = "{} will be deprecated soon. Use {} instead."

Annots = "/Annots"
A = "/A"
JS = "/JS"
T = "/T"
TU = "/TU"
Rect = "/Rect"
FT = "/FT"
Parent = "/Parent"
Ff = "/Ff"
Tx = "/Tx"
V = "/V"
AP = "/AP"
I = "/I"  # noqa: E741
N = "/N"
Sig = "/Sig"
DA = "/DA"
DR = "/DR"
DV = "/DV"
Btn = "/Btn"
MaxLen = "/MaxLen"
Q = "/Q"
Ch = "/Ch"
Opt = "/Opt"
AS = "/AS"
Yes = "/Yes"
Off = "/Off"

# Font dict
Length = "/Length"
Length1 = "/Length1"
Type = "/Type"
FontDescriptor = "/FontDescriptor"
FontName = "/FontName"
FontFile2 = "/FontFile2"
Font = "/Font"
Subtype = "/Subtype"
TrueType = "/TrueType"
BaseFont = "/BaseFont"
Filter = "/Filter"
FlateDecode = "/FlateDecode"
Encoding = "/Encoding"
WinAnsiEncoding = "/WinAnsiEncoding"
Widths = "/Widths"
FirstChar = "/FirstChar"
LastChar = "/LastChar"
MissingWidth = "/MissingWidth"
FontHead = "head"
FontCmap = "cmap"
FontHmtx = "hmtx"
FontNotdef = ".notdef"

FIRST_CHAR_CODE = 0
LAST_CHAR_CODE = 255
ENCODING_TABLE_SIZE = 256
EM_TO_PDF_FACTOR = 1000
DEFAULT_ASSUMED_GLYPH_WIDTH = 300

Resources = "/Resources"
FONT_NAME_PREFIX = "/F"

# For Adobe Acrobat
AcroForm = "/AcroForm"
Root = "/Root"
Fields = "/Fields"
XFA = "/XFA"

# Field flag bits
READ_ONLY = 1 << 0
REQUIRED = 1 << 1
MULTILINE = 1 << 12
COMB = 1 << 24

# reportlab acroform func
fieldFlags = "fieldFlags"
required = "required"

FONT_SIZE_IDENTIFIER = "Tf"
FONT_COLOR_IDENTIFIER = " rg"
DEFAULT_FONT = "Helvetica"
DEFAULT_FONT_SIZE = 12
DEFAULT_FONT_COLOR = (0, 0, 0)

IMAGE_FIELD_IDENTIFIER = "event.target.buttonImportIcon();"

COORDINATE_GRID_FONT_SIZE_MARGIN_RATIO = DEFAULT_FONT_SIZE / 100
UNIQUE_SUFFIX_LENGTH = 20

SLASH = "/"

### PyPDFForm/coordinate.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module for generating coordinate grids on PDFs.

This module provides functionality to generate coordinate grids on existing PDF documents.
It allows developers to visualize the coordinate system of each page in a PDF, which can be helpful
for debugging and precisely positioning elements when filling or drawing on PDF forms.
"""

from typing import Tuple

from pypdf import PdfReader
from reportlab.pdfbase.pdfmetrics import stringWidth

from .constants import COORDINATE_GRID_FONT_SIZE_MARGIN_RATIO, DEFAULT_FONT
from .middleware.text import Text
from .utils import stream_to_io
from .watermark import create_watermarks_and_draw, merge_watermarks_with_pdf


def generate_coordinate_grid(
    pdf: bytes, color: Tuple[float, float, float], margin: float
) -> bytes:
    """
    Generates a coordinate grid overlay on a PDF document.

    This function takes a PDF file as bytes, along with a color and margin, and generates
    a coordinate grid on each page of the PDF. The grid consists of lines and text indicating
    the X and Y coordinates. This can be useful for visualizing the layout and positioning
    elements on the PDF.

    Args:
        pdf (bytes): The PDF file as bytes.
        color (Tuple[float, float, float]): The color of the grid lines and text as a tuple of RGB values (0.0-1.0).
                                            For example, (0.0, 0.0, 0.0) represents black.
        margin (float): The margin between the grid lines and the edge of the page, in points.
                        This value determines the spacing of the grid.

    Returns:
        bytes: The PDF file with the coordinate grid overlay as bytes.
    """
    pdf_file = PdfReader(stream_to_io(pdf))
    lines_by_page = {}
    texts_by_page = {}
    watermarks = []

    for i, page in enumerate(pdf_file.pages):
        lines_by_page[i + 1] = []
        texts_by_page[i + 1] = []
        width = float(page.mediabox[2])
        height = float(page.mediabox[3])

        current = margin
        while current < width:
            lines_by_page[i + 1].append(
                {
                    "src_x": current,
                    "src_y": 0,
                    "dest_x": current,
                    "dest_y": height,
                    "color": color,
                }
            )
            current += margin

        current = margin
        while current < height:
            lines_by_page[i + 1].append(
                {
                    "src_x": 0,
                    "src_y": current,
                    "dest_x": width,
                    "dest_y": current,
                    "color": color,
                }
            )
            current += margin

        x = margin
        while x < width:
            y = margin
            while y < height:
                value = f"({x}, {y})"
                font_size = margin * COORDINATE_GRID_FONT_SIZE_MARGIN_RATIO
                text = Text("new_coordinate", value)
                text.font = DEFAULT_FONT
                text.font_size = font_size
                text.font_color = color
                texts_by_page[i + 1].append(
                    {
                        "widget": text,
                        "x": x - stringWidth(value, DEFAULT_FONT, font_size),
                        "y": y - font_size,
                    }
                )
                y += margin
            x += margin

    for page, lines in lines_by_page.items():
        watermarks.append(
            create_watermarks_and_draw(pdf, page, "line", lines)[page - 1]
        )

    result = merge_watermarks_with_pdf(pdf, watermarks)
    watermarks = []
    for page, texts in texts_by_page.items():
        watermarks.append(
            create_watermarks_and_draw(pdf, page, "text", texts)[page - 1]
        )

    return merge_watermarks_with_pdf(result, watermarks)

### PyPDFForm/filler.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module containing functions to fill PDF forms.

This module provides the core functionality for filling PDF forms programmatically.
It includes functions for handling various form field types, such as text fields,
checkboxes, radio buttons, dropdowns, images, and signatures. The module also
supports flattening the filled form to prevent further modifications.
"""

from io import BytesIO
from typing import Dict, Union, cast

from pypdf import PdfReader, PdfWriter
from pypdf.generic import DictionaryObject

from .constants import WIDGET_TYPES, Annots
from .hooks import flatten_generic, flatten_radio
from .image import get_draw_image_resolutions, get_image_dimensions
from .middleware.checkbox import Checkbox
from .middleware.dropdown import Dropdown
from .middleware.image import Image
from .middleware.radio import Radio
from .middleware.signature import Signature
from .middleware.text import Text
from .patterns import (update_checkbox_value, update_dropdown_value,
                       update_radio_value, update_text_value)
from .template import get_widget_key
from .utils import stream_to_io
from .watermark import create_watermarks_and_draw, merge_watermarks_with_pdf


def signature_image_handler(
    widget: dict, middleware: Union[Signature, Image], images_to_draw: list
) -> bool:
    """Handles signature and image widgets by extracting image data and preparing it for drawing.

    This function processes signature and image widgets found in a PDF form. It extracts the
    image data from the widget's middleware and prepares it for drawing on the form. The
    function calculates the position and dimensions of the image based on the widget's
    properties and the `preserve_aspect_ratio` setting. The image data is then stored in a
    list for later drawing.

    Args:
        widget (dict): The widget dictionary representing the signature or image field.
        middleware (Union[Signature, Image]): The middleware object containing the image data and properties.
        images_to_draw (list): A list to store image data for drawing.

    Returns:
        bool: True if any image is to be drawn, False otherwise.
    """
    stream = middleware.stream
    any_image_to_draw = False
    if stream is not None:
        any_image_to_draw = True
        image_width, image_height = get_image_dimensions(stream)
        x, y, width, height = get_draw_image_resolutions(
            widget, middleware.preserve_aspect_ratio, image_width, image_height
        )
        images_to_draw.append(
            {
                "stream": stream,
                "x": x,
                "y": y,
                "width": width,
                "height": height,
            }
        )

    return any_image_to_draw


def get_drawn_stream(to_draw: dict, stream: bytes, action: str) -> bytes:
    """Applies watermarks to specific pages of a PDF based on the provided drawing instructions.

    This function takes a dictionary of drawing instructions and applies watermarks to the
    specified pages of a PDF. It iterates through the drawing instructions, creates watermarks
    for each page, and merges the watermarks with the original PDF content. The function
    supports various drawing actions, such as adding images or text.

    Args:
        to_draw (dict): A dictionary containing page numbers as keys and lists of drawing instructions as values.
                         Each drawing instruction specifies the type of drawing, position, dimensions, and content.
        stream (bytes): The PDF content as bytes.
        action (str): The type of action to perform (e.g., "image", "text").

    Returns:
        bytes: The modified PDF content with watermarks applied.
    """
    watermark_list = []
    for page, stuffs in to_draw.items():
        watermark_list.append(b"")
        watermarks = create_watermarks_and_draw(stream, page, action, stuffs)
        for i, watermark in enumerate(watermarks):
            if watermark:
                watermark_list[i] = watermark

    return merge_watermarks_with_pdf(stream, watermark_list)


def fill(
    template: bytes,
    widgets: Dict[str, WIDGET_TYPES],
    use_full_widget_name: bool,
    flatten: bool = False,
) -> tuple:
    """Fills a PDF template with the given widgets.

    This function fills a PDF template with the provided widget values. It iterates through the
    widgets on each page of the PDF and updates their values based on the provided `widgets`
    dictionary. The function supports various widget types, including text fields, checkboxes,
    radio buttons, dropdowns, images, and signatures. It also supports flattening the filled
    form to prevent further modifications.

    Args:
        template (bytes): The PDF template as bytes.
        widgets (Dict[str, WIDGET_TYPES]): A dictionary of widgets to fill, where the keys are the
                                            widget names and the values are the widget objects.
        use_full_widget_name (bool): Whether to use the full widget name when looking up widgets
                                      in the `widgets` dictionary.
        flatten (bool): Whether to flatten the filled PDF. Defaults to False.

    Returns:
        tuple: A tuple containing the filled PDF as bytes and the image drawn stream as bytes, if any.
               The image drawn stream is only returned if there are any image or signature widgets
               in the form.
    """
    pdf = PdfReader(stream_to_io(template))
    out = PdfWriter()
    out.append(pdf)

    radio_button_tracker = {}
    images_to_draw = {}
    any_image_to_draw = False

    for page_num, page in enumerate(out.pages):
        images_to_draw[page_num + 1] = []
        for annot in page.get(Annots, []):
            annot = cast(DictionaryObject, annot.get_object())
            key = get_widget_key(annot.get_object(), use_full_widget_name)

            widget = widgets.get(key)
            if widget is None:
                continue

            # flatten all
            if flatten:
                (flatten_radio if isinstance(widget, Radio) else flatten_generic)(
                    annot, True
                )
            if widget.value is None:
                continue

            if isinstance(widgets[key], (Signature, Image)):
                any_image_to_draw |= signature_image_handler(
                    annot, widgets[key], images_to_draw[page_num + 1]
                )
            elif type(widget) is Checkbox:
                update_checkbox_value(annot, widget.value)
            elif isinstance(widget, Radio):
                if key not in radio_button_tracker:
                    radio_button_tracker[key] = 0
                radio_button_tracker[key] += 1
                if widget.value == radio_button_tracker[key] - 1:
                    update_radio_value(annot)
            elif isinstance(widget, Dropdown):
                update_dropdown_value(annot, widget)
            elif isinstance(widget, Text):
                update_text_value(annot, widget)

    with BytesIO() as f:
        out.write(f)
        f.seek(0)
        result = f.read()

    return result, (
        get_drawn_stream(images_to_draw, result, "image") if any_image_to_draw else None
    )

### PyPDFForm/font.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module provides functionalities for handling custom fonts within PDF documents.

It includes functions for registering fonts with ReportLab and within the PDF's AcroForm,
allowing these fonts to be used when filling form fields. The module also provides utilities
for extracting font information from TTF streams and managing font names within a PDF.
"""

from functools import lru_cache
from io import BytesIO
from zlib import compress

from fontTools.ttLib import TTFont as FT_TTFont
from pypdf import PdfReader, PdfWriter
from pypdf.generic import (ArrayObject, DictionaryObject, FloatObject,
                           NameObject, NumberObject, StreamObject)
from reportlab.pdfbase.pdfmetrics import registerFont
from reportlab.pdfbase.ttfonts import TTFError, TTFont

from .constants import (DEFAULT_ASSUMED_GLYPH_WIDTH, DR, EM_TO_PDF_FACTOR,
                        ENCODING_TABLE_SIZE, FIRST_CHAR_CODE, FONT_NAME_PREFIX,
                        LAST_CHAR_CODE, AcroForm, BaseFont, Encoding, Fields,
                        Filter, FirstChar, FlateDecode, Font, FontCmap,
                        FontDescriptor, FontFile2, FontHead, FontHmtx,
                        FontName, FontNotdef, LastChar, Length, Length1,
                        MissingWidth, Resources, Subtype, TrueType, Type,
                        Widths, WinAnsiEncoding)
from .utils import stream_to_io


@lru_cache
def register_font(font_name: str, ttf_stream: bytes) -> bool:
    """
    Registers a TrueType font with the ReportLab library.

    This allows the font to be used for generating PDF documents with ReportLab.

    Args:
        font_name (str): The name to register the font under. This name will be used
            to reference the font when creating PDF documents with ReportLab.
        ttf_stream (bytes): The font file data in TTF format. This should be the raw
            bytes of the TTF file.

    Returns:
        bool: True if the font was registered successfully, False otherwise.
            Returns False if a TTFError occurs during registration, which usually
            indicates an invalid TTF stream.
    """
    buff = BytesIO()
    buff.write(ttf_stream)
    buff.seek(0)

    try:
        registerFont(TTFont(name=font_name, filename=buff))
        result = True
    except TTFError:
        result = False

    buff.close()
    return result


def get_additional_font_params(pdf: bytes, base_font_name: str) -> tuple:
    """
    Retrieves additional font parameters from a PDF document for a given base font name.

    This function searches the PDF's resources for a font dictionary matching the provided
    base font name. If a match is found, it extracts the font descriptor parameters and
    the font dictionary parameters. These parameters can be used to further describe
    and define the font within the PDF.

    Args:
        pdf (bytes): The PDF file data as bytes.
        base_font_name (str): The base font name to search for within the PDF's font resources.

    Returns:
        tuple: A tuple containing two dictionaries:
            - font_descriptor_params (dict): A dictionary of font descriptor parameters.
            - font_dict_params (dict): A dictionary of font dictionary parameters.
            Returns empty dictionaries if the font is not found.
    """
    font_descriptor_params = {}
    font_dict_params = {}
    reader = PdfReader(stream_to_io(pdf))
    first_page = reader.get_page(0)

    for font in first_page[Resources][Font].values():
        if base_font_name.replace("/", "") in font[BaseFont]:
            font_descriptor_params = dict(font[FontDescriptor])
            font_dict_params = dict(font)
            break

    return font_descriptor_params, font_dict_params


def compute_font_glyph_widths(ttf_file: BytesIO, missing_width: float):
    """
    Computes the advance widths for all glyphs in a TrueType font, scaled for PDF text space.

    This function utilizes the `fontTools` library to parse the provided TTF stream
    and extract necessary metrics from the 'head', 'cmap', and 'hmtx' tables.
    It calculates the width for each glyph based on its advance width and the font's
    `unitsPerEm`, then scales these widths to a 1000-unit text space, which is standard
    for PDF font metrics.

    If any of the required font tables ('head', 'cmap', 'hmtx') are missing or
    cannot be accessed, the function returns a list populated with a specified
    `missing_width` for all expected glyphs, ensuring a fallback mechanism.

    Args:
        ttf_file (BytesIO): A BytesIO stream containing the TrueType Font (TTF) data.
                            This stream should be seekable and readable.
        missing_width (float): The default width to be used for all glyphs if the
                                necessary font tables (head, cmap, hmtx) are not found
                                within the TTF file.

    Returns:
        list[float]: A list of floats, where each float represents the scaled advance
                     width of a glyph in PDF text space units (1000 units per EM).
                     The list covers glyphs from `FIRST_CHAR_CODE` to `LAST_CHAR_CODE`.
                     If font tables are missing, the list will be filled with `missing_width`.
    """
    font = FT_TTFont(ttf_file)
    head_table = font.get(FontHead)
    cmap_table = font.get(FontCmap)
    hmtx_table = font.get(FontHmtx)

    widths: list[float] = []
    if head_table and cmap_table and hmtx_table:
        cmap = cmap_table.getBestCmap()
        units_per_em: int = head_table.unitsPerEm or 1

        for codepoint in range(ENCODING_TABLE_SIZE):
            glyph_name: str = cmap.get(codepoint, FontNotdef)
            advance_width, _ = hmtx_table[glyph_name]
            pdf_width: float = (advance_width / units_per_em) * EM_TO_PDF_FACTOR
            widths.append(pdf_width)
    else:
        widths: list[float] = [missing_width] * ENCODING_TABLE_SIZE

    return widths


def register_font_acroform(pdf: bytes, ttf_stream: bytes, adobe_mode: bool) -> tuple:

### PyPDFForm/font.py [2/2] (lang=Python)

 list[float] = [missing_width] * ENCODING_TABLE_SIZE

    return widths


def register_font_acroform(pdf: bytes, ttf_stream: bytes, adobe_mode: bool) -> tuple:
    """
    Registers a TrueType font within the PDF's AcroForm dictionary.

    This allows the font to be used when filling form fields within the PDF.
    The function adds the font as a resource to the PDF, making it available
    for use in form fields.

    Args:
        pdf (bytes): The PDF file data as bytes. This is the PDF document that
            will be modified to include the new font.
        ttf_stream (bytes): The font file data in TTF format as bytes. This is the
            raw data of the TrueType font file.
        adobe_mode (bool): A flag indicating whether to use Adobe-specific font parameters.

    Returns:
        tuple: A tuple containing the modified PDF data as bytes and the new font name
            (str) that was assigned to the registered font within the PDF.
    """
    base_font_name = get_base_font_name(ttf_stream)
    reader = PdfReader(stream_to_io(pdf))
    writer = PdfWriter()
    writer.append(reader)

    font_descriptor_params = {}
    font_dict_params = {}
    if adobe_mode:
        font_descriptor_params, font_dict_params = get_additional_font_params(
            pdf, base_font_name
        )

    font_file_stream = StreamObject()
    compressed_ttf = compress(ttf_stream)
    font_file_stream.set_data(compressed_ttf)
    font_file_stream.update(
        {
            NameObject(Length1): NumberObject(len(ttf_stream)),
            NameObject(Length): NumberObject(len(compressed_ttf)),
            NameObject(Filter): NameObject(FlateDecode),
        }
    )
    font_file_ref = writer._add_object(font_file_stream)  # type: ignore # noqa: SLF001 # # pylint: disable=W0212

    font_descriptor = DictionaryObject()
    font_descriptor.update(
        {
            NameObject(Type): NameObject(FontDescriptor),
            NameObject(FontName): NameObject(base_font_name),
            NameObject(FontFile2): font_file_ref,
        }
    )
    font_descriptor.update(
        {k: v for k, v in font_descriptor_params.items() if k not in font_descriptor}
    )
    font_descriptor_ref = writer._add_object(font_descriptor)  # type: ignore # noqa: SLF001 # # pylint: disable=W0212

    font_dict = DictionaryObject()
    font_dict.update(
        {
            NameObject(Type): NameObject(Font),
            NameObject(Subtype): NameObject(TrueType),
            NameObject(BaseFont): NameObject(base_font_name),
            NameObject(FontDescriptor): font_descriptor_ref,
            NameObject(Encoding): NameObject(WinAnsiEncoding),
        }
    )

    font_dict.update({k: v for k, v in font_dict_params.items() if k not in font_dict})

    if font_dict and Widths in font_dict:
        ttf_bytes_io = BytesIO(ttf_stream)
        missing_width = font_descriptor.get(MissingWidth, DEFAULT_ASSUMED_GLYPH_WIDTH)
        widths = compute_font_glyph_widths(ttf_bytes_io, missing_width)

        font_dict.update(
            {
                NameObject(FirstChar): NumberObject(FIRST_CHAR_CODE),
                NameObject(LastChar): NumberObject(LAST_CHAR_CODE),
                NameObject(Widths): ArrayObject(FloatObject(width) for width in widths),
            }
        )

    font_dict_ref = writer._add_object(font_dict)  # type: ignore # noqa: SLF001 # # pylint: disable=W0212

    if AcroForm not in writer._root_object:  # type: ignore # noqa: SLF001 # # pylint: disable=W0212
        writer._root_object[NameObject(AcroForm)] = DictionaryObject({NameObject(Fields): ArrayObject([])})  # type: ignore # noqa: SLF001 # # pylint: disable=W0212
    acroform = writer._root_object[AcroForm]  # type: ignore # noqa: SLF001 # # pylint: disable=W0212

    if DR not in acroform:
        acroform[NameObject(DR)] = DictionaryObject()
    dr = acroform[DR]

    if Font not in dr:
        dr[NameObject(Font)] = DictionaryObject()
    fonts = dr[Font]

    new_font_name = get_new_font_name(fonts)
    fonts[NameObject(new_font_name)] = font_dict_ref

    with BytesIO() as f:
        writer.write(f)
        f.seek(0)
        return f.read(), new_font_name


@lru_cache
def get_base_font_name(ttf_stream: bytes) -> str:
    """
    Extracts the base font name from a TrueType font stream.

    This function parses the TTF stream to extract the font's face name,
    which is used as the base font name. The result is cached using lru_cache
    for performance.

    Args:
        ttf_stream (bytes): The font file data in TTF format.

    Returns:
        str: The base font name, prefixed with a forward slash.
    """
    return (
        f"/{TTFont(name='new_font', filename=stream_to_io(ttf_stream)).face.name.ustr}"
    )


def get_new_font_name(fonts: dict) -> str:
    """
    Generates a new unique font name to avoid conflicts with existing fonts in the PDF.

    This function iterates through the existing fonts in the PDF and generates a new
    font name with the prefix '/F' followed by a unique integer.

    Args:
        fonts (dict): A dictionary of existing fonts in the PDF.

    Returns:
        str: A new unique font name.
    """
    existing = set()
    for key in fonts:
        if isinstance(key, str) and key.startswith(FONT_NAME_PREFIX):
            existing.add(int(key[2:]))

    n = 1
    while n in existing:
        n += 1
    return f"{FONT_NAME_PREFIX}{n}"


@lru_cache
def get_all_available_fonts(pdf: bytes) -> dict:
    """
    Retrieves all available fonts from a PDF document's AcroForm.

    This function extracts the font resources from the PDF's AcroForm dictionary
    and returns them as a dictionary.

    Args:
        pdf (bytes): The PDF file data.

    Returns:
        dict: A dictionary of available fonts, where the keys are the font names
            (without the leading slash) and the values are the corresponding font
            identifiers in the PDF. Returns an empty dictionary if no fonts are found.
    """
    reader = PdfReader(stream_to_io(pdf))
    try:
        fonts = reader.root_object[AcroForm][DR][Font]
    except KeyError:
        return {}

    result = {}
    for key, value in fonts.items():
        result[value[BaseFont].replace("/", "")] = key

    return result

### PyPDFForm/hooks.py [1/3] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines widget hooks that allow for dynamic modification of PDF form fields.

It provides functions to trigger these hooks, enabling changes to text field properties
like font, font size, color, alignment, and multiline settings, as well as the size
of checkbox and radio button widgets. It also provides functions for flattening
generic and radio button widgets. These hooks are triggered during the PDF form
filling process, allowing for customization of the form's appearance and behavior.
"""

import sys
from io import BytesIO
from typing import cast

from pypdf import PdfReader, PdfWriter
from pypdf.generic import (ArrayObject, DictionaryObject, FloatObject,
                           NameObject, NumberObject, TextStringObject)

from .constants import (COMB, DA, FONT_COLOR_IDENTIFIER, FONT_SIZE_IDENTIFIER,
                        MULTILINE, READ_ONLY, REQUIRED, TU, Annots, Ff, MaxLen,
                        Opt, Parent, Q, Rect)
from .template import get_widget_key
from .utils import stream_to_io


def trigger_widget_hooks(
    pdf: bytes,
    widgets: dict,
    use_full_widget_name: bool,
) -> bytes:
    """
    Triggers widget hooks to apply dynamic changes to PDF form fields.

    This function iterates through the annotations on each page of the PDF and,
    if a widget is associated with an annotation and has hooks to trigger,
    it executes those hooks. Hooks are functions defined in this module that
    modify the annotation dictionary, allowing for dynamic changes to the form field's
    appearance or behavior.

    Args:
        pdf (bytes): The PDF file data as bytes.
        widgets (dict): A dictionary of widgets, where keys are widget identifiers
            and values are widget objects containing information about the widget
            and its associated hooks.
        use_full_widget_name (bool): Whether to use the full widget name when
            looking up widgets in the widgets dictionary.

    Returns:
        bytes: The modified PDF data as bytes, with the widget hooks applied.
    """
    pdf_file = PdfReader(stream_to_io(pdf))
    output = PdfWriter()
    output.append(pdf_file)

    for page in output.pages:
        for annot in page.get(Annots, []):
            annot = cast(DictionaryObject, annot.get_object())
            key = get_widget_key(annot.get_object(), use_full_widget_name)

            widget = widgets.get(key)
            if widget is None or not widget.hooks_to_trigger:
                continue

            for hook in widget.hooks_to_trigger:
                getattr(sys.modules[__name__], hook[0])(annot, hook[1])

    for widget in widgets.values():
        widget.hooks_to_trigger = []

    with BytesIO() as f:
        output.write(f)
        f.seek(0)
        return f.read()


def update_text_field_font(annot: DictionaryObject, val: str) -> None:
    """
    Updates the font of a text field annotation.

    This function modifies the appearance string (DA) in the annotation dictionary
    to change the font used for the text field. It ensures that the provided font
    name is a proper PDF font by checking if it starts with a slash "/".
    The function then correctly identifies and updates the font in the appearance
    stream by locating the existing font identifier (which also starts with a slash).

    Args:
        annot (DictionaryObject): The annotation dictionary for the text field.
        val (str): The new font name to use for the text field. Must start with "/".
    """
    if not val.startswith("/"):
        return
    if Parent in annot and DA not in annot:
        text_appearance = annot[Parent][DA]
    else:
        text_appearance = annot[DA]

    text_appearance = text_appearance.split(" ")

    index_to_update = 0
    for i, each in enumerate(text_appearance):
        if each.startswith("/"):
            index_to_update = i
            break

    text_appearance[index_to_update] = val
    new_text_appearance = " ".join(text_appearance)

    if Parent in annot and DA not in annot:
        annot[NameObject(Parent)][NameObject(DA)] = TextStringObject(
            new_text_appearance
        )
    else:
        annot[NameObject(DA)] = TextStringObject(new_text_appearance)


def update_text_field_font_size(annot: DictionaryObject, val: float) -> None:
    """
    Updates the font size of a text field annotation.

    This function modifies the appearance string (DA) in the annotation dictionary
    to change the font size used for the text field.

    Args:
        annot (DictionaryObject): The annotation dictionary for the text field.
        val (float): The new font size to use for the text field.
    """
    if Parent in annot and DA not in annot:
        text_appearance = annot[Parent][DA]
    else:
        text_appearance = annot[DA]

    text_appearance = text_appearance.split(" ")
    font_size_index = 0
    for i, value in enumerate(text_appearance):
        if value.startswith(FONT_SIZE_IDENTIFIER):
            font_size_index = i - 1
            break

    text_appearance[font_size_index] = str(val)
    new_text_appearance = " ".join(text_appearance)

    if Parent in annot and DA not in annot:
        annot[NameObject(Parent)][NameObject(DA)] = TextStringObject(
            new_text_appearance
        )
    else:
        annot[NameObject(DA)] = TextStringObject(new_text_appearance)


def update_text_field_font_color(annot: DictionaryObject, val: tuple) -> None:
    """
    Updates the font color of a text field annotation.

    This function modifies the appearance string (DA) in the annotation dictionary
    to change the font color used for the text field.

    Args:
        annot (DictionaryObject): The annotation dictionary for the text field.
        val (tuple): The new font color as an RGB tuple (e.g., (1, 0, 0) for red).
    """
    if Parent in annot and DA not in annot:
        text_appearance = annot[Parent][DA]
    else:
        text_appearance = annot[DA]

    text_appearance = text_appearance.split(" ")
    font_size_identifier_index = 0
    for i, value in enumerate(text_appearance):
        if value == FONT_SIZE_IDENTIFIER:
            font_size_identifier_index = i
            break

    new_text_appearance = (
        text_appearance[:font_size_identifier_index]
        + [FONT_SIZE_IDENTIFIER]
        + [str(each) for each in val]
    )
    new_text_appearance = " ".join(new_text_appearance) + FONT_COLOR_IDENTIFIER

    if Parent in annot and DA not in annot:
        annot[NameObject(Parent)][NameObject(DA)] = TextStringObject(
            new_text_appearance
        )
    else:
        annot[NameObject(DA)] = TextStringObject(new_text_appearance)


def update_text_field_alignment(annot: DictionaryObject, val: int) -> None:
    """
    Updates the text alignment of a text field annotation.

    This function modifies the Q entry in the annotation dictionary to change
    the text alignment of the text field.

    Args:
        annot (DictionaryObject): The annotation dictionary for the text field.
        val (int): The new alignment value (0=Left, 1=Center, 2=Right).
    """
    annot[NameObject(Q)] = NumberObject(val)


def update_text_field_multiline(annot: DictionaryObject, val: bool) -> None:

### PyPDFForm/hooks.py [2/3] (lang=Python)

0=Left, 1=Center, 2=Right).
    """
    annot[NameObject(Q)] = NumberObject(val)


def update_text_field_multiline(annot: DictionaryObject, val: bool) -> None:
    """
    Updates the multiline property of a text field annotation.

    This function modifies the Ff (flags) entry in the annotation dictionary to
    enable or disable the multiline property of the text field.

    Args:
        annot (DictionaryObject): The annotation dictionary for the text field.
        val (bool): True to enable multiline, False to disable.
    """
    if val:
        # Ff in annot[Parent] only in hooks.py, or when editing instead of retrieving
        if Parent in annot and Ff in annot[Parent]:
            annot[NameObject(Parent)][NameObject(Ff)] = NumberObject(
                int(
                    annot[NameObject(Parent)][NameObject(Ff)]
                    if Ff in annot[NameObject(Parent)]
                    else 0
                )
                | MULTILINE
            )
        else:
            annot[NameObject(Ff)] = NumberObject(
                int(annot[NameObject(Ff)] if Ff in annot else 0) | MULTILINE
            )


def update_text_field_comb(annot: DictionaryObject, val: bool) -> None:
    """
    Updates the comb property of a text field annotation.

    This function modifies the Ff (flags) entry in the annotation dictionary to
    enable or disable the comb property of the text field, which limits the
    number of characters that can be entered in each line.

    Args:
        annot (DictionaryObject): The annotation dictionary for the text field.
        val (bool): True to enable comb, False to disable.
    """
    if val:
        if Parent in annot and Ff in annot[Parent]:
            annot[NameObject(Parent)][NameObject(Ff)] = NumberObject(
                int(
                    annot[NameObject(Parent)][NameObject(Ff)]
                    if Ff in annot[NameObject(Parent)]
                    else 0
                )
                | COMB
            )
        else:
            annot[NameObject(Ff)] = NumberObject(
                int(annot[NameObject(Ff)] if Ff in annot else 0) | COMB
            )


def update_text_field_max_length(annot: DictionaryObject, val: int) -> None:
    """
    Updates the maximum length of a text field annotation.

    This function sets the 'MaxLen' entry in the annotation dictionary, which
    specifies the maximum number of characters that can be entered into the text field.

    Args:
        annot (DictionaryObject): The annotation dictionary for the text field.
        val (int): The maximum number of characters allowed in the text field.
    """
    annot[NameObject(MaxLen)] = NumberObject(val)


def update_check_radio_size(annot: DictionaryObject, val: float) -> None:
    """
    Updates the size of a check box or radio button annotation.

    This function modifies the Rect entry in the annotation dictionary to change
    the size of the check box or radio button.

    Args:
        annot (DictionaryObject): The annotation dictionary for the check box or
            radio button.
        val (float): The new size (width and height) for the check box or radio button.
    """
    rect = annot[Rect]
    # scale from bottom left
    new_rect = [
        rect[0],
        rect[1],
        FloatObject(rect[0] + val),
        FloatObject(rect[1] + val),
    ]
    annot[NameObject(Rect)] = ArrayObject(new_rect)


def update_dropdown_choices(annot: DictionaryObject, val: list) -> None:
    """
    Updates the choices in a dropdown field annotation.

    This function modifies the Opt entry in the annotation dictionary to change
    the available choices in the dropdown field.

    Args:
        annot (DictionaryObject): The annotation dictionary for the dropdown field.
        val (list): A list of strings or tuples representing the new choices for the dropdown.
    """
    annot[NameObject(Opt)] = ArrayObject(
        [
            (
                ArrayObject([TextStringObject(each[1]), TextStringObject(each[0])])
                if isinstance(each, tuple)
                else ArrayObject([TextStringObject(each), TextStringObject(each)])
            )
            for each in val
        ]
    )


def flatten_radio(annot: DictionaryObject, val: bool) -> None:
    """
    Flattens a radio button annotation by setting or unsetting the ReadOnly flag,
    making it non-editable or editable based on the `val` parameter.

    This function modifies the Ff (flags) entry in the radio button's annotation
    dictionary or its parent dictionary if `Parent` exists in `annot`, to set or
    unset the ReadOnly flag, preventing or allowing the user from changing the
    selected option.

    Args:
        annot (DictionaryObject): The radio button annotation dictionary.
        val (bool): True to flatten (make read-only), False to unflatten (make editable).
    """
    if Parent in annot:
        annot[NameObject(Parent)][NameObject(Ff)] = NumberObject(
            (
                int(annot[NameObject(Parent)].get(NameObject(Ff), 0)) | READ_ONLY
                if val
                else int(annot[NameObject(Parent)].get(NameObject(Ff), 0)) & ~READ_ONLY
            )
        )
    else:
        annot[NameObject(Ff)] = NumberObject(
            (
                int(annot.get(NameObject(Ff), 0)) | READ_ONLY
                if val
                else int(annot.get(NameObject(Ff), 0)) & ~READ_ONLY
            )
        )


def flatten_generic(annot: DictionaryObject, val: bool) -> None:
    """
    Flattens a generic annotation by setting or unsetting the ReadOnly flag,
    making it non-editable or editable based on the `val` parameter.

    This function modifies the Ff (flags) entry in the annotation dictionary to
    set or unset the ReadOnly flag, preventing or allowing the user from
    interacting with the form field.

    Args:
        annot (DictionaryObject): The annotation dictionary.
        val (bool): True to flatten (make read-only), False to unflatten (make editable).
    """
    if Parent in annot and (Ff in annot[Parent] or Ff not in annot):
        annot[NameObject(Parent)][NameObject(Ff)] = NumberObject(
            (
                int(annot.get(NameObject(Ff), 0)) | READ_ONLY
                if val
                else int(annot.get(NameObject(Ff), 0)) & ~READ_ONLY
            )
        )
    else:
        annot[NameObject(Ff)] = NumberObject(
            (
                int(annot.get(NameObject(Ff), 0)) | READ_ONLY
                if val
                else int(annot.get(NameObject(Ff), 0)) & ~READ_ONLY
            )
        )


def update_field_tooltip(annot: DictionaryObject, val: str) -> None:
    """
    Updates the tooltip (alternate field name) of a form field annotation.

    This function sets the 'TU' entry in the annotation dictionary, which
    provides a text string that can be used as a tooltip for the field.

    Args:
        annot (DictionaryObject): The annotation dictionary for the form field.
        val (str): The new tooltip string for the field.
    """
    if val:
        annot[NameObject(TU)] = TextStringObject(val)


def update_field_required(annot: DictionaryObject, val: bool) -> None:

### PyPDFForm/hooks.py [3/3] (lang=Python)

r the field.
    """
    if val:
        annot[NameObject(TU)] = TextStringObject(val)


def update_field_required(annot: DictionaryObject, val: bool) -> None:
    """
    Updates the 'Required' flag of a form field annotation.

    This function modifies the Ff (flags) entry in the annotation dictionary
    (or its parent if applicable) to set or unset the 'Required' flag,
    making the field mandatory or optional.

    Args:
        annot (DictionaryObject): The annotation dictionary for the form field.
        val (bool): True to set the field as required, False to make it optional.
    """
    if Parent in annot and Ff in annot[Parent]:
        annot[NameObject(Parent)][NameObject(Ff)] = NumberObject(
            (
                int(annot.get(NameObject(Ff), 0)) | REQUIRED
                if val
                else int(annot.get(NameObject(Ff), 0)) & ~REQUIRED
            )
        )
    else:
        annot[NameObject(Ff)] = NumberObject(
            (
                int(annot.get(NameObject(Ff), 0)) | REQUIRED
                if val
                else int(annot.get(NameObject(Ff), 0)) & ~REQUIRED
            )
        )

### PyPDFForm/image.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module provides functionalities for handling images within PyPDFForm.

It includes functions for rotating images, retrieving image dimensions, and
calculating the resolutions for drawing an image on a PDF page, taking into
account whether to preserve the aspect ratio.
"""

from io import BytesIO
from typing import Tuple, Union

from PIL import Image

from .constants import Rect


def rotate_image(image_stream: bytes, rotation: Union[float, int]) -> bytes:
    """
    Rotates an image by a specified angle in degrees.

    This function takes an image stream as bytes and rotates it using the PIL library.
    The rotation is performed around the center of the image, and the expand=True
    parameter ensures that the entire rotated image is visible, even if it extends
    beyond the original image boundaries.

    Args:
        image_stream (bytes): The image data as bytes.
        rotation (Union[float, int]): The rotation angle in degrees. Positive values
            rotate the image counterclockwise, while negative values rotate it clockwise.

    Returns:
        bytes: The rotated image data as bytes.
    """
    buff = BytesIO()
    buff.write(image_stream)
    buff.seek(0)

    image = Image.open(buff)

    rotated_buff = BytesIO()
    image.rotate(rotation, expand=True).save(rotated_buff, format=image.format)
    rotated_buff.seek(0)

    result = rotated_buff.read()

    buff.close()
    rotated_buff.close()

    return result


def get_image_dimensions(image_stream: bytes) -> Tuple[float, float]:
    """
    Retrieves the width and height of an image from its byte stream.

    This function uses the PIL library to open the image from the provided byte stream
    and returns its dimensions (width and height) as a tuple of floats.

    Args:
        image_stream (bytes): The image data as bytes.

    Returns:
        Tuple[float, float]: The width and height of the image in pixels.
    """
    buff = BytesIO()
    buff.write(image_stream)
    buff.seek(0)

    image = Image.open(buff)

    return image.size


def get_draw_image_resolutions(
    widget: dict,
    preserve_aspect_ratio: bool,
    image_width: float,
    image_height: float,
) -> Tuple[float, float, float, float]:
    """
    Calculates the position and dimensions for drawing an image on a PDF page.

    This function determines the x, y coordinates, width, and height for drawing an
    image within a specified widget area on a PDF page. It takes into account whether
    the aspect ratio of the image should be preserved and adjusts the dimensions
    accordingly.

    Args:
        widget (dict): A dictionary containing the widget's rectangle coordinates
            (x1, y1, x2, y2) under the key "Rect".
        preserve_aspect_ratio (bool): Whether to preserve the aspect ratio of the image.
            If True, the image will be scaled to fit within the widget area while
            maintaining its original aspect ratio.
        image_width (float): The width of the image in pixels.
        image_height (float): The height of the image in pixels.

    Returns:
        Tuple[float, float, float, float]: A tuple containing the x, y coordinates,
            width, and height of the image to be drawn on the PDF page.
    """
    x = float(widget[Rect][0])
    y = float(widget[Rect][1])
    width = abs(float(widget[Rect][0]) - float(widget[Rect][2]))
    height = abs(float(widget[Rect][1]) - float(widget[Rect][3]))

    if preserve_aspect_ratio:
        ratio = max(image_width / width, image_height / height)

        new_width = image_width / ratio
        new_height = image_height / ratio

        x += abs(new_width - width) / 2
        y += abs(new_height - height) / 2

        width = new_width
        height = new_height

    return x, y, width, height

### PyPDFForm/middleware/base.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module containing base classes for middleware.

This module defines the base class for form widgets, which are used to
represent form fields in a PDF document. The Widget class provides
common attributes and methods for all form widgets, such as name, value,
and schema definition.
"""

from typing import Any


class Widget:
    """
    Base class for form widget.

    The Widget class provides a base implementation for form widgets,
    which are used to represent form fields in a PDF document. It
    defines common attributes and methods for all form widgets, such
    as name, value, and schema definition.
    """

    SET_ATTR_TRIGGER_HOOK_MAP = {
        "readonly": "flatten_generic",
        "required": "update_field_required",
        "tooltip": "update_field_tooltip",
    }

    def __init__(
        self,
        name: str,
        value: Any = None,
    ) -> None:
        """
        Initialize a new widget.

        Args:
            name (str): The name of the widget.
            value (Any): The initial value of the widget. Defaults to None.
        """
        super().__init__()
        self._name = name
        self._value = value
        self.tooltip: str = None
        self.readonly: bool = None
        self.required: bool = None
        self.hooks_to_trigger: list = []

    def __setattr__(self, name: str, value: Any) -> None:
        """
        Set an attribute on the widget.

        This method overrides the default __setattr__ method to
        trigger hooks when certain attributes are set.

        Args:
            name (str): The name of the attribute.
            value (Any): The value of the attribute.
        """
        if name in self.SET_ATTR_TRIGGER_HOOK_MAP and value is not None:
            self.hooks_to_trigger.append((self.SET_ATTR_TRIGGER_HOOK_MAP[name], value))
        super().__setattr__(name, value)

    @property
    def name(self) -> str:
        """
        Get the name of the widget.

        Returns:
            str: The name of the widget.
        """
        return self._name

    @property
    def value(self) -> Any:
        """
        Get the value of the widget.

        Returns:
            Any: The value of the widget.
        """
        return self._value

    @value.setter
    def value(self, value: Any) -> None:
        """
        Set the value of the widget.

        Args:
            value (Any): The value to set.
        """
        self._value = value

    @property
    def schema_definition(self) -> dict:
        """
        Get the schema definition of the widget.

        This method returns a dictionary that defines the schema
        for the widget. The schema definition is used to validate
        the widget's value.

        Returns:
            dict: The schema definition of the widget.
        """
        result = {}

        if self.tooltip is not None:
            result["description"] = self.tooltip

        return result

    @property
    def sample_value(self) -> Any:
        """
        Get a sample value for the widget.

        Raises:
            NotImplementedError: This method must be implemented by subclasses.
        """
        raise NotImplementedError

### PyPDFForm/middleware/checkbox.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module representing a checkbox widget.

This module defines the Checkbox class, which is a subclass of the
Widget class. It represents a checkbox form field in a PDF document.
"""

from typing import Union

from .base import Widget


class Checkbox(Widget):
    """
    Represents a checkbox widget.

    The Checkbox class provides a concrete implementation for
    checkbox form fields. It inherits from the Widget class and
    implements the schema_definition and sample_value properties.
    """

    def __init__(
        self,
        name: str,
        value: bool = None,
    ) -> None:
        """
        Initializes a checkbox widget.

        Args:
            name (str): The name of the checkbox.
            value (bool): The initial value of the checkbox. Defaults to None.

        Attributes:
            size (int): The size of the checkbox. Defaults to None.
        """
        self.SET_ATTR_TRIGGER_HOOK_MAP.update(
            {
                "size": "update_check_radio_size",
            }
        )
        super().__init__(name, value)

        self.size: float = None

    @property
    def schema_definition(self) -> dict:
        """
        Returns the schema definition for the checkbox.

        The schema definition is a dictionary that describes the
        data type and other constraints for the checkbox value.

        Returns:
            dict: A dictionary representing the schema definition.
        """
        return {"type": "boolean", **super().schema_definition}

    @property
    def sample_value(self) -> Union[bool, int]:
        """
        Returns a sample value for the checkbox.

        The sample value is used to generate example data for the
        checkbox field.

        Returns:
            Union[bool, int]: A sample value for the checkbox.
        """
        return True

### PyPDFForm/middleware/dropdown.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module representing a dropdown widget.

This module defines the Dropdown class, which is a subclass of the
Widget class. It represents a dropdown form field in a PDF document.
"""

from typing import Union

from .base import Widget


class Dropdown(Widget):
    """
    Represents a dropdown widget in a PDF form.

    Inherits from the Widget class and provides specific functionality
    for handling dropdown form fields.

    Key attributes:
        font (str): The font of the dropdown field.
        choices (List[str]): The list of available options in the dropdown.
        value (int): The index of the selected choice in the choices list.

    Methods:
        schema_definition: Returns a schema definition for the dropdown's value.
        sample_value: Returns a sample value for the dropdown.
    """

    def __init__(
        self,
        name: str,
        value: int = None,
    ) -> None:
        """
        Initializes a dropdown widget.

        Args:
            name (str): The name of the dropdown.
            value (int): The initial value of the dropdown. Defaults to None.

        Attributes:
            font (str): The font of the dropdown field.
            choices (List[str]): The list of choices for the dropdown.
        """
        self.SET_ATTR_TRIGGER_HOOK_MAP.update(
            {
                "font": "update_text_field_font",
                "font_size": "update_text_field_font_size",
                "font_color": "update_text_field_font_color",
                "choices": "update_dropdown_choices",
            }
        )
        super().__init__(name, value)

        self.font: str = None
        self.font_size: float = None
        self.font_color: tuple = None
        self.choices: Union[tuple, list] = None

    @property
    def value(self) -> int:
        """
        Gets the current value of the dropdown.

        Returns:
            int: The index of the selected choice.
        """
        return super().value

    @value.setter
    def value(self, value: Union[str, int]) -> None:
        """
        Sets the value of the dropdown.

        If the value is a string, it attempts to find the corresponding
        index in the choices list. If not found, the string value is
        added to the choices, and its new index is used.

        Args:
            value (Union[str, int]): The value to set. Can be a string
                                      (option text) or an integer (index).
        """
        if isinstance(value, str):
            index = self._get_option_index(value)
            if index is None:
                self.choices = list(self.choices) + [value]
                index = len(self.choices) - 1
            value = index

        self._value = value

    def _get_option_index(self, value: str) -> Union[int, None]:
        """
        Gets the index of a given option value in the dropdown's choices.

        Args:
            value (str): The option value to search for.

        Returns:
            Union[int, None]: The index of the option if found, otherwise None.
        """
        for i, each in enumerate(self.choices):
            if value == each:
                return i

        return None

    @property
    def schema_definition(self) -> dict:
        """
        Returns the schema definition for the dropdown.

        The schema definition is a dictionary that describes the
        data type and other constraints for the dropdown value.

        Returns:
            dict: A dictionary representing the schema definition.
        """
        return {
            "type": "integer",
            "maximum": len(self.choices) - 1,
            **super().schema_definition,
        }

    @property
    def sample_value(self) -> int:
        """
        Returns a sample value for the dropdown.

        The sample value is used to generate example data for the
        dropdown field.

        Returns:
            int: A sample value for the dropdown.
        """
        return len(self.choices) - 1

### PyPDFForm/middleware/image.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module representing an image widget.

This module defines the Image class, which is a subclass of the
Signature class. It represents an image form field in a PDF document,
allowing users to add images to the form.
"""

from .signature import Signature


class Image(Signature):
    """
    Represents an image widget.

    The Image class provides a concrete implementation for
    image form fields. It inherits from the Signature class and
    sets the preserve_aspect_ratio attribute to False by default.
    """

    preserve_aspect_ratio: bool = False

### PyPDFForm/middleware/radio.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module representing a radio button widget.

This module defines the Radio class, which is a subclass of the
Checkbox class. It represents a radio button form field in a PDF
document, allowing users to select one option from a group of choices.
"""

from .checkbox import Checkbox


class Radio(Checkbox):
    """
    Represents a radio button widget.

    The Radio class provides a concrete implementation for radio button
    form fields. It inherits from the Checkbox class and implements
    the schema_definition and sample_value properties.
    """

    def __init__(
        self,
        name: str,
        value: int = None,
    ) -> None:
        """
        Initializes a radio button widget.

        Args:
            name (str): The name of the radio button.
            value (int): The initial value of the radio button. Defaults to None.

        Attributes:
            number_of_options (int): The number of options for the radio button.
        """
        self.SET_ATTR_TRIGGER_HOOK_MAP.update(
            {
                "readonly": "flatten_radio",
            }
        )
        super().__init__(name, value)

        self.number_of_options: int = 0

    @property
    def schema_definition(self) -> dict:
        """
        Returns the schema definition for the radio button.

        The schema definition is a dictionary that describes the
        data type and other constraints for the radio button value,
        which is expected to be an integer representing the index
        of the selected option.

        Returns:
            dict: A dictionary representing the schema definition.
        """
        return {
            "maximum": self.number_of_options - 1,
            **super().schema_definition,
            "type": "integer",
        }

    @property
    def sample_value(self) -> int:
        """
        Returns a sample value for the radio button.

        The sample value is used to generate example data for the
        radio button field. It returns the index of the last option
        in the group.

        Returns:
            int: A sample value for the radio button.
        """
        return self.number_of_options - 1

### PyPDFForm/middleware/signature.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module representing a signature widget.

This module defines the Signature class, which is a subclass of the
Widget class. It represents a signature form field in a PDF document,
allowing users to add their signature as an image.
"""

from os.path import expanduser
from typing import Union

from ..adapter import fp_or_f_obj_or_stream_to_stream
from .base import Widget


class Signature(Widget):
    """
    Represents a signature widget.

    The Signature class provides a concrete implementation for
    signature form fields. It inherits from the Widget class and
    implements the schema_definition, sample_value, and stream
    properties.
    """

    preserve_aspect_ratio: bool = True

    @property
    def schema_definition(self) -> dict:
        """
        Returns the schema definition for the signature.

        The schema definition is a dictionary that describes the
        data type and other constraints for the signature value,
        which is expected to be a string representing the path to
        the signature image.

        Returns:
            dict: A dictionary representing the schema definition.
        """
        return {"type": "string", **super().schema_definition}

    @property
    def sample_value(self) -> str:
        """
        Returns a sample value for the signature.

        The sample value is used to generate example data for the
        signature field. It returns the path to a sample image file.

        Returns:
            str: A sample value for the signature.
        """
        return expanduser("~/Downloads/sample_image.jpg")

    @property
    def stream(self) -> Union[bytes, None]:
        """
        Returns the stream of the signature image.

        This method reads the signature image from the file path
        specified in the value attribute and returns the image data
        as a stream of bytes.

        Returns:
            Union[bytes, None]: The stream of the signature image.
        """
        return (
            fp_or_f_obj_or_stream_to_stream(self.value)
            if self.value is not None
            else None
        )

### PyPDFForm/middleware/text.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module representing a text field widget.

This module defines the Text class, which is a subclass of the
Widget class. It represents a text field form field in a PDF document,
allowing users to enter text.
"""

from .base import Widget


class Text(Widget):
    """
    Represents a text field widget.

    The Text class provides a concrete implementation for text field
    form fields. It inherits from the Widget class and implements
    the value, schema_definition, and sample_value properties. It
    also defines a number of attributes that can be used to customize
    the appearance and behavior of the text field, such as font,
    font_size, font_color, comb, alignment, and multiline.
    """

    def __init__(
        self,
        name: str,
        value: str = None,
    ) -> None:
        """
        Initializes a text field widget.

        Args:
            name (str): The name of the text field.
            value (str): The initial value of the text field. Defaults to None.

        Attributes:
            font (str): The font of the text field. Defaults to None.
            font_size (int): The font size of the text field. Defaults to None.
            font_color (str): The font color of the text field. Defaults to None.
            comb (bool): Whether the text field is a comb field. Defaults to None.
            alignment (str): The alignment of the text field. Defaults to None.
            multiline (bool): Whether the text field is multiline. Defaults to None.
            max_length (int): The maximum length of the text field. Defaults to None.
        """
        self.SET_ATTR_TRIGGER_HOOK_MAP.update(
            {
                "font": "update_text_field_font",
                "font_size": "update_text_field_font_size",
                "font_color": "update_text_field_font_color",
                "comb": "update_text_field_comb",
                "alignment": "update_text_field_alignment",
                "multiline": "update_text_field_multiline",
                "max_length": "update_text_field_max_length",
            }
        )
        super().__init__(name, value)

        self.font: str = None
        self.font_size: float = None
        self.font_color: tuple = None
        self.comb: bool = None
        self.alignment: int = None
        self.multiline: bool = None
        self.max_length: int = None

    @property
    def value(self) -> str:
        """
        Returns the value of the text field.

        If the value is an integer or float, it is converted to a string.

        Returns:
            str: The value of the text field.
        """
        if isinstance(self._value, (int, float)):
            return str(self._value)

        return self._value

    @value.setter
    def value(self, value: str) -> None:
        """
        Sets the value of the text field.

        Args:
            value (str): The value to set.
        """
        self._value = value

    @property
    def schema_definition(self) -> dict:
        """
        Returns the schema definition for the text field.

        The schema definition is a dictionary that describes the
        data type and other constraints for the text field value.

        Returns:
            dict: A dictionary representing the schema definition.
        """
        result = {"type": "string"}

        if self.max_length is not None:
            result["maxLength"] = self.max_length

        return {**result, **super().schema_definition}

    @property
    def sample_value(self) -> str:
        """
        Returns a sample value for the text field.

        The sample value is used to generate example data for the
        text field. It returns the name of the field, truncated to
        the maximum length if specified.

        Returns:
            str: A sample value for the text field.
        """
        return (
            self.name[: self.max_length] if self.max_length is not None else self.name
        )

### PyPDFForm/patterns.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines patterns and utility functions for interacting with PDF form fields.

It includes patterns for identifying different types of widgets (e.g., text fields,
checkboxes, radio buttons, dropdowns, images, and signatures) based on their
properties in the PDF's annotation dictionary. It also provides utility functions
for updating these widgets.
"""

from typing import Union

from pypdf.generic import (ArrayObject, DictionaryObject, NameObject,
                           NumberObject, TextStringObject)

from .constants import (AP, AS, DV, FT, IMAGE_FIELD_IDENTIFIER, JS, MULTILINE,
                        SLASH, TU, A, Btn, Ch, Ff, I, N, Off, Opt, Parent, Sig,
                        T, Tx, V, Yes)
from .middleware.checkbox import Checkbox
from .middleware.dropdown import Dropdown
from .middleware.image import Image
from .middleware.radio import Radio
from .middleware.signature import Signature
from .middleware.text import Text

WIDGET_TYPE_PATTERNS = [
    (
        ({A: {JS: IMAGE_FIELD_IDENTIFIER}},),
        Image,
    ),
    (
        ({FT: Sig},),
        Signature,
    ),
    (
        ({Parent: {FT: Sig}},),
        Signature,
    ),
    (
        ({FT: Tx},),
        Text,
    ),
    (
        # reportlab creation pattern
        (
            {FT: Btn},
            {Parent: {FT: Btn}},
            {AS: (Yes, Off, SLASH)},
        ),
        Radio,
    ),
    (
        (
            {FT: Btn},
            {AS: (Yes, Off)},
        ),
        Checkbox,
    ),
    (
        ({FT: Ch},),
        Dropdown,
    ),
    (
        ({Parent: {FT: Ch}},),
        Dropdown,
    ),
    (
        ({Parent: {FT: Tx}},),
        Text,
    ),
    (
        (
            {Parent: {FT: Btn}},
            {Parent: {DV: (Yes, Off)}},
            {AS: (Yes, Off)},
        ),
        Checkbox,
    ),
    (
        (
            {Parent: {FT: Btn}},
            {AS: (Yes, Off, SLASH)},
        ),
        Radio,
    ),
]

WIDGET_KEY_PATTERNS = [
    {T: True},
    {Parent: {T: True}},
]

WIDGET_DESCRIPTION_PATTERNS = [{TU: True}, {Parent: {TU: True}}]

DROPDOWN_CHOICE_PATTERNS = [
    {Opt: True},
    {Parent: {Opt: True}},
]


def update_checkbox_value(annot: DictionaryObject, check: bool = False) -> None:
    """
    Updates the value of a checkbox annotation, setting it to checked or unchecked.

    This function modifies the appearance state (AS) and value (V) of the checkbox
    annotation to reflect the desired state (checked or unchecked).

    Args:
        annot (DictionaryObject): The checkbox annotation dictionary.
        check (bool): True to check the checkbox, False to uncheck it. Defaults to False.
    """
    for each in annot[AP][N]:
        if (check and str(each) != Off) or (not check and str(each) == Off):
            annot[NameObject(AS)] = NameObject(each)
            annot[NameObject(V)] = NameObject(each)
            break


def get_checkbox_value(annot: DictionaryObject) -> Union[bool, None]:
    """
    Retrieves the boolean value of a checkbox annotation.

    This function checks the value (V) of the checkbox annotation. If the value
    is not 'Off', it means the checkbox is checked, and True is returned.
    Otherwise, if the value is 'Off' or not present, None is returned.

    Args:
        annot (DictionaryObject): The checkbox annotation dictionary.

    Returns:
        Union[bool, None]: True if the checkbox is checked, None otherwise.
    """
    return True if annot.get(V, Off) != Off else None


def update_radio_value(annot: DictionaryObject) -> None:
    """
    Updates the value of a radio button annotation, selecting it.

    This function modifies the appearance state (AS) and value (V) of the radio button's
    parent dictionary to reflect the selected state.

    Args:
        annot (DictionaryObject): The radio button annotation dictionary.
    """
    if Opt in annot[Parent]:
        del annot[Parent][Opt]

    for each in annot[AP][N]:
        if str(each) != Off:
            annot[NameObject(AS)] = NameObject(each)
            annot[NameObject(Parent)][NameObject(V)] = NameObject(each)
            break


def get_radio_value(annot: DictionaryObject) -> bool:
    """
    Retrieves the boolean value of a radio button annotation.

    This function iterates through the appearance states (AP) of the radio button
    annotation. If the value (V) of the parent dictionary matches any of these
    appearance states, it means the radio button is selected, and True is returned.
    Otherwise, False is returned.

    Args:
        annot (DictionaryObject): The radio button annotation dictionary.

    Returns:
        bool: True if the radio button is selected, False otherwise.
    """
    for each in annot.get(AP, {}).get(N, []):
        if annot.get(Parent, {}).get(V) == each:
            return True

    return False


def update_dropdown_value(annot: DictionaryObject, widget: Dropdown) -> None:
    """
    Updates the value of a dropdown annotation, selecting an option from the list.

    This function modifies the value (V) and appearance (AP) of the dropdown
    annotation to reflect the selected option. It also updates the index (I)
    of the selected option.

    Args:
        annot (DictionaryObject): The dropdown annotation dictionary.
        widget (Dropdown): The Dropdown widget object containing the selected value.
    """
    choices = widget.choices or []
    if Parent in annot and T not in annot:
        annot[NameObject(Parent)][NameObject(V)] = TextStringObject(
            choices[widget.value]
        )
        annot[NameObject(AP)] = TextStringObject(choices[widget.value])
    else:
        annot[NameObject(V)] = TextStringObject(choices[widget.value])
        annot[NameObject(AP)] = TextStringObject(choices[widget.value])
        annot[NameObject(I)] = ArrayObject([NumberObject(widget.value)])


def get_dropdown_value(annot: DictionaryObject, widget: Dropdown) -> None:
    """
    Retrieves the selected value of a dropdown annotation and updates the widget.

    This function determines the current value of the dropdown, considering
    whether it's a child annotation or a top-level one. It then iterates
    through the widget's choices to find a match and sets the widget's
    value to the index of the matched choice.

    Args:
        annot (DictionaryObject): The dropdown annotation dictionary.
        widget (Dropdown): The Dropdown widget object to update with the retrieved value.
    """
    if Parent in annot and T not in annot:
        to_compare = annot.get(Parent, {}).get(V)
    else:
        to_compare = annot.get(V)

    for i, each in enumerate(widget.choices):
        if each == to_compare:
            widget.value = i or None  # set None when 0


def update_text_value(annot: DictionaryObject, widget: Text) -> None:
    """
    Updates the value of a text annotation, setting the text content.

    This function modifies the value (V) and appearance (AP) of the text
    annotation to reflect the new text content.

    Args:
        annot (DictionaryObject): The text annotation dictionary.
        widget (Text): The Text widget object containing the text value.
    """
    if Parent in annot and T not in annot:
        annot[NameObject(Parent)][NameObject(V)] = TextStringObject(widget.value)
        annot[NameObject(AP)] = TextStringObject(widget.value)
    else:
        annot[NameObject(V)] = TextStringObject(widget.value)
        annot[NameObject(AP)] = TextStringObject(widget.value)


def get_text_value(annot: DictionaryObject, widget: Text) -> None:

### PyPDFForm/patterns.py [2/2] (lang=Python)

    """
    Retrieves the text value of a text annotation and updates the widget.

    This function determines the current text value of the annotation, considering
    whether it's a child annotation or a top-level one, and then sets the
    widget's value accordingly.

    Args:
        annot (DictionaryObject): The text annotation dictionary.
        widget (Text): The Text widget object to update with the retrieved value.
    """
    if Parent in annot and T not in annot:
        widget.value = annot[Parent].get(V)
    else:
        widget.value = annot.get(V)


def update_annotation_name(annot: DictionaryObject, val: str) -> None:
    """
    Updates the name of an annotation, setting the T (title) entry.

    This function modifies the T (title) entry in the annotation dictionary to
    change the name or title of the annotation.

    Args:
        annot (DictionaryObject): The annotation dictionary.
        val (str): The new name for the annotation.
    """
    if Parent in annot and T not in annot:
        annot[NameObject(Parent)][NameObject(T)] = TextStringObject(val)
    else:
        annot[NameObject(T)] = TextStringObject(val)


def get_text_field_multiline(annot: DictionaryObject) -> bool:
    """
    Checks if a text field annotation is multiline.

    This function inspects the 'Ff' (field flags) entry of the text annotation
    dictionary (or its parent if it's a child annotation) to determine if the
    Multiline flag is set.

    Args:
        annot (DictionaryObject): The text annotation dictionary.

    Returns:
        bool: True if the text field is multiline, False otherwise.
    """
    if Parent in annot and Ff not in annot:
        return bool(
            int(
                annot[NameObject(Parent)][NameObject(Ff)]
                if Ff in annot[NameObject(Parent)]
                else 0
            )
            & MULTILINE
        )
    return bool(int(annot[NameObject(Ff)] if Ff in annot else 0) & MULTILINE)

### PyPDFForm/template.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module for handling PDF form templates.

This module provides functionalities to extract, build, and update widgets
in PDF form templates. It leverages the pypdf library for PDF manipulation
and defines specific patterns for identifying and constructing different
types of widgets.
"""

from functools import lru_cache
from io import BytesIO
from typing import Dict, List, Tuple, Union, cast

from pypdf import PdfReader, PdfWriter
from pypdf.generic import DictionaryObject

from .constants import WIDGET_TYPES, Annots, MaxLen, Parent, T
from .middleware.checkbox import Checkbox
from .middleware.dropdown import Dropdown
from .middleware.radio import Radio
from .middleware.text import Text
from .patterns import (DROPDOWN_CHOICE_PATTERNS, WIDGET_DESCRIPTION_PATTERNS,
                       WIDGET_KEY_PATTERNS, WIDGET_TYPE_PATTERNS,
                       get_checkbox_value, get_dropdown_value, get_radio_value,
                       get_text_field_multiline, get_text_value,
                       update_annotation_name)
from .utils import extract_widget_property, find_pattern_match, stream_to_io


def build_widgets(
    pdf_stream: bytes,
    use_full_widget_name: bool,
) -> Dict[str, WIDGET_TYPES]:
    """
    Builds a dictionary of widgets from a PDF stream.

    This function parses a PDF stream to identify and construct widgets
    present in the PDF form. It iterates through each page and its annotations,
    extracting widget properties such as key, description, max length (for text fields),
    and choices (for dropdowns). The constructed widgets are stored in a dictionary
    where the keys are the widget keys and the values are the widget objects.

    Args:
        pdf_stream (bytes): The PDF stream to parse.
        use_full_widget_name (bool): Whether to use the full widget name
            (including parent names) as the widget key.

    Returns:
        Dict[str, WIDGET_TYPES]: A dictionary of widgets, where keys are widget
            keys and values are widget objects.
    """
    results = {}

    for widgets in get_widgets_by_page(pdf_stream).values():
        for widget in widgets:
            key = get_widget_key(widget, use_full_widget_name)
            _widget = construct_widget(widget, key)
            if _widget is not None:
                _widget.__dict__["tooltip"] = extract_widget_property(
                    widget, WIDGET_DESCRIPTION_PATTERNS, None, str
                )

                if isinstance(_widget, Text):
                    # mostly for schema for now
                    # doesn't trigger hook
                    _widget.__dict__["max_length"] = get_text_field_max_length(widget)
                    _widget.__dict__["multiline"] = get_text_field_multiline(widget)
                    get_text_value(widget, _widget)

                if type(_widget) is Checkbox:
                    _widget.value = get_checkbox_value(widget)

                if isinstance(_widget, Dropdown):
                    # actually used for filling value
                    # doesn't trigger hook
                    _widget.__dict__["choices"] = get_dropdown_choices(widget)
                    get_dropdown_value(widget, _widget)

                if isinstance(_widget, Radio):
                    if key not in results:
                        results[key] = _widget

                    # for schema
                    results[key].number_of_options += 1

                    if get_radio_value(widget):
                        results[key].value = results[key].number_of_options - 1
                    continue

                results[key] = _widget

    return results


@lru_cache()
def get_widgets_by_page(pdf: bytes) -> Dict[int, List[dict]]:
    """
    Retrieves widgets from a PDF stream, organized by page number.

    This function parses a PDF stream and extracts all the widgets (annotations)
    present on each page. It returns a dictionary where the keys are the page
    numbers and the values are lists of widget dictionaries.

    Args:
        pdf (bytes): The PDF stream to parse.

    Returns:
        Dict[int, List[dict]]: A dictionary where keys are page numbers (1-indexed)
            and values are lists of widget dictionaries.
    """
    pdf_file = PdfReader(stream_to_io(pdf))

    result = {}

    for i, page in enumerate(pdf_file.pages):
        widgets = page.annotations
        result[i + 1] = []
        if widgets:
            for widget in widgets:
                widget = dict(widget.get_object())
                for each in WIDGET_TYPE_PATTERNS:
                    patterns = each[0]
                    check = True
                    for pattern in patterns:
                        check = check and find_pattern_match(pattern, widget)
                    if check:
                        result[i + 1].append(widget)
                        break

    return result


def get_widget_key(widget: dict, use_full_widget_name: bool) -> str:
    """
    Extracts the widget key from a widget dictionary.

    This function extracts the widget key from a widget dictionary based on
    predefined patterns. If `use_full_widget_name` is True, it recursively
    constructs the full widget name by concatenating the parent widget keys.

    Args:
        widget (dict): The widget dictionary to extract the key from.
        use_full_widget_name (bool): Whether to use the full widget name
            (including parent names) as the widget key.

    Returns:
        str: The extracted widget key.
    """
    if not use_full_widget_name:
        return extract_widget_property(widget, WIDGET_KEY_PATTERNS, None, str)

    key = widget.get(T)
    if (
        Parent in widget
        and T in widget[Parent].get_object()
        and widget[Parent].get_object()[T] != key  # sejda case
    ):
        if key is None:
            return get_widget_key(widget[Parent].get_object(), use_full_widget_name)

        return (
            f"{get_widget_key(widget[Parent].get_object(), use_full_widget_name)}.{key}"
        )

    return key or ""


def construct_widget(widget: dict, key: str) -> Union[WIDGET_TYPES, None]:
    """
    Constructs a widget object based on the widget dictionary and key.

    This function determines the type of widget based on predefined patterns
    and constructs the corresponding widget object.

    Args:
        widget (dict): The widget dictionary to construct the object from.
        key (str): The key of the widget.

    Returns:
        Union[WIDGET_TYPES, None]: The constructed widget object, or None
            if the widget type is not recognized.
    """
    result = None
    for each in WIDGET_TYPE_PATTERNS:
        patterns, _type = each
        check = True
        for pattern in patterns:
            check = check and find_pattern_match(pattern, widget)
        if check:
            result = _type(key)
            break
    return result


def get_text_field_max_length(widget: dict) -> Union[int, None]:
    """
    Extracts the maximum length of a text field from a widget dictionary.

    Args:
        widget (dict): The widget dictionary to extract the max length from.

    Returns:
        Union[int, None]: The maximum length of the text field, or None
            if the max length is not specified.
    """
    return int(widget[MaxLen]) or None if MaxLen in widget else None


def get_dropdown_choices(widget: dict) -> Union[Tuple[str, ...], None]:
    """
    Extracts the choices from a dropdown widget dictionary.

    This function extracts the choices from a dropdown widget dictionary.

    Args:
        widget (dict): The widget dictionary to extract the choices from.

    Returns:
        Union[Tuple[str, ...], None]: A tuple of strings representing the choices in the dropdown, or None if the choices are not specified.
    """
    return tuple(
        (each if isinstance(each, str) else str(each[1]))
        for each in extract_widget_property(
            widget, DROPDOWN_CHOICE_PATTERNS, None, None
        )
    )


def update_widget_keys(

### PyPDFForm/template.py [2/2] (lang=Python)

e str(each[1]))
        for each in extract_widget_property(
            widget, DROPDOWN_CHOICE_PATTERNS, None, None
        )
    )


def update_widget_keys(
    template: bytes,
    widgets: Dict[str, WIDGET_TYPES],
    old_keys: List[str],
    new_keys: List[str],
    indices: List[int],
) -> bytes:
    """
    Updates the keys of widgets in a PDF template.

    This function updates the keys of widgets in a PDF template based on the provided old keys and new keys.
    It iterates through each page and annotation, finds the widgets with the old keys, and updates their names with the corresponding new keys.
    The `indices` parameter is used when multiple widgets have the same name, to differentiate which one to update.

    Args:
        template (bytes): The PDF template to update.
        widgets (Dict[str, WIDGET_TYPES]): A dictionary of widgets in the template.
        old_keys (List[str]): A list of the old widget keys to be replaced.
        new_keys (List[str]): A list of the new widget keys to replace the old keys.
        indices (List[int]): A list of indices to handle the case where multiple widgets have the same name.

    Returns:
        bytes: The updated PDF template as a byte stream.
    """
    pdf = PdfReader(stream_to_io(template))
    out = PdfWriter()
    out.append(pdf)

    for i, old_key in enumerate(old_keys):
        index = indices[i]
        new_key = new_keys[i]
        tracker = -1
        for page in out.pages:
            for annot in page.get(Annots, []):
                annot = cast(DictionaryObject, annot.get_object())
                key = get_widget_key(annot.get_object(), False)

                widget = widgets.get(key)
                if widget is None:
                    continue

                if old_key != key:
                    continue

                tracker += 1
                if not isinstance(widget, Radio) and tracker != index:
                    continue

                update_annotation_name(annot, new_key)

    with BytesIO() as f:
        out.write(f)
        f.seek(0)
        return f.read()

### PyPDFForm/utils.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module provides a collection of utility functions used throughout the PyPDFForm library.

It includes functions for:
- Converting byte streams to BinaryIO objects.
- Removing all widgets (form fields) from a PDF.
- Extracting the content stream of each page in a PDF.
- Merging two PDFs into one.
- Finding and traversing patterns within PDF widgets.
- Extracting widget properties based on defined patterns.
- Generating unique suffixes for internal use.
- Enabling Adobe-specific settings in the PDF to ensure proper rendering of form fields.
"""

from collections.abc import Callable
from functools import lru_cache
from io import BytesIO
from secrets import choice
from string import ascii_letters, digits, punctuation
from typing import Any, BinaryIO, List, Union

from pypdf import PdfReader, PdfWriter
from pypdf.generic import ArrayObject, DictionaryObject, NameObject

from .constants import SLASH, UNIQUE_SUFFIX_LENGTH, XFA, AcroForm, Annots, Root


@lru_cache
def stream_to_io(stream: bytes) -> BinaryIO:
    """
    Converts a bytes stream to a BinaryIO object, which can be used by PyPDFForm.

    This function takes a bytes stream as input and returns a BinaryIO object
    that represents the same data. This is useful because PyPDFForm often
    works with BinaryIO objects, so this function allows you to easily convert
    a bytes stream to the correct format. The result is cached using lru_cache
    for performance.

    Args:
        stream (bytes): The bytes stream to convert.

    Returns:
        BinaryIO: A BinaryIO object representing the stream.
    """
    result = BytesIO()
    result.write(stream)
    result.seek(0)

    return result


@lru_cache
def enable_adobe_mode(pdf: bytes) -> bytes:
    """Enables Adobe-specific settings in the PDF to ensure proper rendering of form fields.

    This function modifies the PDF's AcroForm dictionary to include the `NeedAppearances` flag,
    which forces Adobe Reader to generate appearance streams for form fields. It also handles
    XFA (XML Forms Architecture) forms by removing the XFA entry from the AcroForm dictionary
    if it exists, ensuring compatibility and proper rendering. This ensures that the form fields
    are rendered correctly in Adobe Reader, especially when the form is filled programmatically.

    Args:
        pdf (bytes): The PDF content as bytes.

    Returns:
        bytes: The modified PDF content with Adobe mode enabled.
    """
    reader = PdfReader(stream_to_io(pdf))
    writer = PdfWriter()

    if AcroForm in reader.trailer[Root] and XFA in reader.trailer[Root][AcroForm]:
        del reader.trailer[Root][AcroForm][XFA]

    writer.append(reader)
    writer.set_need_appearances_writer()

    with BytesIO() as f:
        writer.write(f)
        f.seek(0)
        return f.read()


@lru_cache
def remove_all_widgets(pdf: bytes) -> bytes:
    """
    Removes all widgets (form fields) from a PDF, effectively flattening the form.

    This function takes a PDF as a bytes stream, removes all of its interactive
    form fields (widgets), and returns the modified PDF as a bytes stream. This
    is useful for creating a non-interactive version of a PDF form.

    Args:
        pdf (bytes): The PDF as a bytes stream.

    Returns:
        bytes: The PDF with all widgets removed, as a bytes stream.
    """
    pdf_file = PdfReader(stream_to_io(pdf))
    result_stream = BytesIO()
    writer = PdfWriter()
    for page in pdf_file.pages:
        if page.annotations:
            page.annotations.clear()
        writer.add_page(page)

    writer.write(result_stream)
    result_stream.seek(0)
    return result_stream.read()


def get_page_streams(pdf: bytes) -> List[bytes]:
    """
    Extracts the content stream of each page in a PDF as a list of byte streams.

    This function takes a PDF as a bytes stream and returns a list of bytes streams,
    where each element in the list represents the content stream of a page in the PDF.

    Args:
        pdf (bytes): The PDF as a bytes stream.

    Returns:
        List[bytes]: A list of bytes streams, one for each page.
    """
    pdf_file = PdfReader(stream_to_io(pdf))
    result = []

    for page in pdf_file.pages:
        writer = PdfWriter()
        writer.add_page(page)
        with BytesIO() as f:
            writer.write(f)
            f.seek(0)
            result.append(f.read())

    return result


def merge_two_pdfs(pdf: bytes, other: bytes) -> bytes:
    """
    Merges two PDF files into a single PDF file.

    This function takes two PDF files as byte streams, merges them, and returns the result as a single PDF byte stream.
    It handles the merging of pages from both PDFs and also attempts to preserve form field widgets from both input PDFs
    in the final merged PDF. The form fields are cloned and added to the output pages.

    Args:
        pdf (bytes): The first PDF file as a byte stream.
        other (bytes): The second PDF file as a byte stream.

    Returns:
        bytes: The merged PDF file as a byte stream.
    """
    output = PdfWriter()
    pdf_file = PdfReader(stream_to_io(pdf))
    other_file = PdfReader(stream_to_io(other))
    result = BytesIO()

    for page in pdf_file.pages:
        output.add_page(page)
    for page in other_file.pages:
        output.add_page(page)

    output.write(result)
    result.seek(0)

    merged_no_widgets = PdfReader(stream_to_io(remove_all_widgets(result.read())))
    output = PdfWriter()
    output.append(merged_no_widgets)

    # TODO: refactor duplicate logic with copy_watermark_widgets
    widgets_to_copy = {}
    for i, page in enumerate(pdf_file.pages):
        widgets_to_copy[i] = []
        for annot in page.get(Annots, []):
            widgets_to_copy[i].append(annot.clone(output))

    for i, page in enumerate(other_file.pages):
        widgets_to_copy[i + len(pdf_file.pages)] = []
        for annot in page.get(Annots, []):
            widgets_to_copy[i + len(pdf_file.pages)].append(annot.clone(output))

    for i, page in enumerate(output.pages):
        page[NameObject(Annots)] = (
            (page[NameObject(Annots)] + ArrayObject(widgets_to_copy[i]))
            if Annots in page
            else ArrayObject(widgets_to_copy[i])
        )

    result = BytesIO()
    output.write(result)
    result.seek(0)
    return result.read()


def find_pattern_match(pattern: dict, widget: Union[dict, DictionaryObject]) -> bool:
    """
    Recursively finds a pattern match within a PDF widget (annotation dictionary).

    This function searches for a specific pattern within a PDF widget's properties.
    It recursively traverses the widget's dictionary, comparing keys and values
    to the provided pattern.

    Args:
        pattern (dict): The pattern to search for, represented as a dictionary.
        widget (Union[dict, DictionaryObject]): The widget to search within, which
            can be a dictionary or a DictionaryObject.

    Returns:
        bool: True if a match is found, False otherwise.
    """
    for key, value in widget.items():
        result = False
        if key in pattern:
            value = value.get_object()
            if isinstance(pattern[key], dict) and isinstance(
                value, (dict, DictionaryObject)
            ):
                result = find_pattern_match(pattern[key], value)
            else:
                if isinstance(pattern[key], tuple):
                    result = value in pattern[key]
                    if not result and SLASH in pattern[key] and value.startswith(SLASH):
                        result = True
                else:
                    result = pattern[key] == value
        if result:
            return result
    return False


def traverse_pattern(

### PyPDFForm/utils.py [2/2] (lang=Python)

    pattern: dict, widget: Union[dict, DictionaryObject]
) -> Union[str, list, None]:
    """
    Recursively traverses a pattern within a PDF widget (annotation dictionary) and returns the value.

    This function searches for a specific pattern within a PDF widget's properties.
    It recursively traverses the widget's dictionary, comparing keys and values
    to the provided pattern and returns the value if the pattern is True.

    Args:
        pattern (dict): The pattern to traverse, represented as a dictionary.
        widget (Union[dict, DictionaryObject]): The widget to traverse within, which
            can be a dictionary or a DictionaryObject.

    Returns:
        Union[str, list, None]: The value found, or None if not found.
    """
    for key, value in widget.items():
        result = None
        if key in pattern:
            value = value.get_object()
            if isinstance(pattern[key], dict) and isinstance(
                value, (dict, DictionaryObject)
            ):
                result = traverse_pattern(pattern[key], value)
            else:
                if pattern[key] is True and value:
                    return value
        if result:
            return result
    return None


def extract_widget_property(
    widget: Union[dict, DictionaryObject],
    patterns: list,
    default_value: Any,
    func_before_return: Union[Callable, None],
) -> Any:
    """
    Extracts a specific property from a PDF widget based on a list of patterns.

    This function iterates through a list of patterns, attempting to find a match
    within the provided widget. If a match is found, the corresponding value is
    extracted and returned. If no match is found, a default value is returned.

    Args:
        widget (Union[dict, DictionaryObject]): The widget to extract the property from.
        patterns (list): A list of patterns to search for. Each pattern should be a
            dictionary representing the structure of the property to extract.
        default_value (Any): The default value to return if no pattern is found.
        func_before_return (Union[Callable, None]): An optional function to call before
            returning the extracted value. This can be used to perform additional
            processing or formatting on the value.

    Returns:
        Any: The extracted property value, or the default value if no pattern is found.
    """
    result = default_value

    for pattern in patterns:
        value = traverse_pattern(pattern, widget)
        if value:
            result = func_before_return(value) if func_before_return else value
            break

    return result


def generate_unique_suffix() -> str:
    """
    Generates a unique suffix string for internal use, such as to avoid naming conflicts.

    This function creates a random string of characters with a predefined length
    (UNIQUE_SUFFIX_LENGTH) using a combination of ASCII letters, digits, and
    punctuation characters (excluding hyphens).

    Returns:
        str: A unique suffix string.
    """
    return "".join(
        [
            choice(ascii_letters + digits + punctuation.replace("-", ""))
            for _ in range(UNIQUE_SUFFIX_LENGTH)
        ]
    )

### PyPDFForm/watermark.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-
"""
Module related to adding watermarks to a PDF.

This module provides functionalities to add watermarks to existing PDF documents.
It supports drawing text, lines, and images as watermarks.
The module also includes functions to merge these watermarks with the original PDF content
and to copy specific widgets from the watermarks to the original PDF.
"""

from io import BytesIO
from typing import List, Union

from pypdf import PdfReader, PdfWriter
from pypdf.generic import ArrayObject, NameObject
from reportlab.lib.utils import ImageReader
from reportlab.pdfgen.canvas import Canvas

from .constants import Annots
from .template import get_widget_key
from .utils import stream_to_io


def draw_text(canvas: Canvas, **kwargs) -> None:
    """
    Draws a text string on the given canvas using the specified font, size, and color.
    Supports multiline text by splitting the input string by newline characters.

    Args:
        canvas (Canvas): The ReportLab Canvas object to draw on.
        **kwargs: Keyword arguments containing the text's properties and coordinates.
            - widget: The widget object containing font, font_size, font_color, and value.
            - x (float): The x-coordinate of the text's starting point.
            - y (float): The y-coordinate of the text's starting point.

    Returns:
        None
    """
    widget = kwargs["widget"]
    coordinate_x = kwargs["x"]
    coordinate_y = kwargs["y"]

    text_to_draw = widget.value
    canvas.setFont(widget.font, widget.font_size)
    canvas.setFillColorRGB(
        widget.font_color[0], widget.font_color[1], widget.font_color[2]
    )
    text_obj = canvas.beginText(coordinate_x, coordinate_y)
    for line in text_to_draw.split("\n"):
        text_obj.textLine(line)
    canvas.drawText(text_obj)


def draw_line(canvas: Canvas, **kwargs) -> None:
    """
    Draws a line on the given canvas with the specified source and destination coordinates, and color.

    Args:
        canvas (Canvas): The ReportLab Canvas object to draw on.
        **kwargs: Keyword arguments containing the line's properties and coordinates.
            - src_x (float): The x-coordinate of the line's starting point.
            - src_y (float): The y-coordinate of the line's starting point.
            - dest_x (float): The x-coordinate of the line's ending point.
            - dest_y (float): The y-coordinate of the line's ending point.
            - color (tuple): A tuple representing the RGB color of the line.

    Returns:
        None
    """
    src_x = kwargs["src_x"]
    src_y = kwargs["src_y"]
    dest_x = kwargs["dest_x"]
    dest_y = kwargs["dest_y"]
    color = kwargs["color"]

    canvas.setStrokeColorRGB(*(color))
    canvas.line(src_x, src_y, dest_x, dest_y)


def draw_image(canvas: Canvas, **kwargs) -> None:
    """
    Draws an image on the given canvas, scaling it to fit within the specified width and height.

    Args:
        canvas (Canvas): The ReportLab Canvas object to draw on.
        **kwargs: Keyword arguments containing the image's properties and coordinates.
            - stream (bytes): The image data as a byte stream.
            - x (float): The x-coordinate of the image's bottom-left corner.
            - y (float): The y-coordinate of the image's bottom-left corner.
            - width (float): The desired width of the image.
            - height (float): The desired height of the image.

    Returns:
        None
    """
    image_stream = kwargs["stream"]
    coordinate_x = kwargs["x"]
    coordinate_y = kwargs["y"]
    width = kwargs["width"]
    height = kwargs["height"]

    image_buff = BytesIO()
    image_buff.write(image_stream)
    image_buff.seek(0)

    canvas.drawImage(
        ImageReader(image_buff),
        coordinate_x,
        coordinate_y,
        width=width,
        height=height,
        mask="auto",
    )

    image_buff.close()


def create_watermarks_and_draw(
    pdf: bytes,
    page_number: int,
    action_type: str,
    actions: List[dict],
) -> List[bytes]:
    """
    Creates watermarks for a specific page in the PDF based on the provided actions and draws them.

    This function takes a PDF file, a page number, an action type, and a list of actions as input.
    It then creates a watermark for the specified page by drawing the specified actions on a Canvas object.

    Args:
        pdf (bytes): The PDF file as a byte stream.
        page_number (int): The page number to which the watermark should be applied (1-indexed).
        action_type (str): The type of action to perform when creating the watermark (e.g., "image", "text", "line").
        actions (List[dict]): A list of dictionaries, where each dictionary represents an action to be performed on the watermark.

    Returns:
        List[bytes]: A list of byte streams, where the element at index (page_number - 1) contains the watermark for the specified page,
                     and all other elements are empty byte streams.
    """
    pdf_file = PdfReader(stream_to_io(pdf))
    buff = BytesIO()

    canvas = Canvas(
        buff,
        pagesize=(
            float(pdf_file.pages[page_number - 1].mediabox[2]),
            float(pdf_file.pages[page_number - 1].mediabox[3]),
        ),
    )

    action_type_to_func = {
        "image": draw_image,
        "text": draw_text,
        "line": draw_line,
    }

    if action_type_to_func.get(action_type):
        for each in actions:
            action_type_to_func[action_type](canvas, **each)

    canvas.save()
    buff.seek(0)

    watermark = buff.read()
    buff.close()

    return [
        watermark if i == page_number - 1 else b"" for i in range(len(pdf_file.pages))
    ]


def merge_watermarks_with_pdf(
    pdf: bytes,
    watermarks: List[bytes],
) -> bytes:
    """
    Merges the generated watermarks with the original PDF content.

    This function takes a PDF file and a list of watermarks as input.
    It then merges each watermark with its corresponding page in the PDF.

    Args:
        pdf (bytes): The PDF file as a byte stream.
        watermarks (List[bytes]): A list of byte streams, where each element represents the watermark for a specific page.

    Returns:
        bytes: A byte stream representing the merged PDF with watermarks applied.
    """
    result = BytesIO()
    pdf_file = PdfReader(stream_to_io(pdf))
    output = PdfWriter()

    for i, page in enumerate(pdf_file.pages):
        if watermarks[i]:
            watermark = PdfReader(stream_to_io(watermarks[i]))
            if watermark.pages:
                page.merge_page(watermark.pages[0])
        output.add_page(page)

    output.write(result)
    result.seek(0)
    return result.read()


def copy_watermark_widgets(

### PyPDFForm/watermark.py [2/2] (lang=Python)

erge_page(watermark.pages[0])
        output.add_page(page)

    output.write(result)
    result.seek(0)
    return result.read()


def copy_watermark_widgets(
    pdf: bytes,
    watermarks: Union[List[bytes], bytes],
    keys: Union[List[str], None],
    page_num: Union[int, None],
) -> bytes:
    """
    Copies specific widgets from the watermarks to the original PDF.

    This function allows you to selectively copy widgets (e.g., form fields) from the watermarks to the original PDF.
    You can specify which widgets to copy by providing a list of keys.

    Args:
        pdf (bytes): The PDF file as a byte stream.
        watermarks (Union[List[bytes], bytes]): A list of byte streams, where each element represents the watermark for a specific page.
        keys (Union[List[str], None]): A list of keys identifying the widgets to copy from the watermarks. If None, all widgets are copied.
        page_num (Union[int, None]): The page number to copy the widgets from. If None, widgets are copied from all pages.

    Returns:
        bytes: A byte stream representing the modified PDF with the specified widgets copied from the watermarks.
    """
    pdf_file = PdfReader(stream_to_io(pdf))
    out = PdfWriter()
    out.append(pdf_file)

    # TODO: refactor duplicate logic with merge_two_pdfs
    widgets_to_copy_watermarks = {}
    widgets_to_copy_pdf = {}

    widgets_to_copy = widgets_to_copy_watermarks
    if isinstance(watermarks, bytes):
        watermarks = [watermarks]
        widgets_to_copy = widgets_to_copy_pdf

    if page_num is not None:
        widgets_to_copy = widgets_to_copy_watermarks

    for i, watermark in enumerate(watermarks):
        if not watermark:
            continue

        widgets_to_copy_watermarks[i] = []
        watermark_file = PdfReader(stream_to_io(watermark))
        for j, page in enumerate(watermark_file.pages):
            widgets_to_copy_pdf[j] = []
            for annot in page.get(Annots, []):
                key = get_widget_key(annot.get_object(), False)

                # cannot be watermarks when page_num not None
                if (keys is None or key in keys) and (
                    page_num is None or page_num == j
                ):
                    widgets_to_copy_watermarks[i].append(annot.clone(out))
                    widgets_to_copy_pdf[j].append(annot.clone(out))

    for i, page in enumerate(out.pages):
        if i in widgets_to_copy:
            page[NameObject(Annots)] = (
                (page[NameObject(Annots)] + ArrayObject(widgets_to_copy[i]))
                if Annots in page
                else ArrayObject(widgets_to_copy[i])
            )

    with BytesIO() as f:
        out.write(f)
        f.seek(0)
        return f.read()

### PyPDFForm/widgets/__init__.py [1/1] (lang=Python)

"""
The `widgets` package provides a collection of classes representing various types of PDF form fields (widgets).

It defines `FieldTypes` as a Union of all supported field types, allowing for flexible
type hinting when working with different widget configurations.

Classes within this package encapsulate the properties and behaviors of individual
form fields, facilitating their creation and manipulation within PDF documents.
"""

from dataclasses import dataclass
from typing import Union

from .checkbox import CheckBoxField
from .dropdown import DropdownField
from .image import ImageField
from .radio import RadioGroup
from .signature import SignatureField
from .text import TextField

FieldTypes = Union[
    TextField, CheckBoxField, RadioGroup, DropdownField, SignatureField, ImageField
]


@dataclass
class Fields:
    """
    A container class that provides convenient access to all available PDF form field types.

    This class acts as a namespace for the various `Field` classes defined in the
    `PyPDFForm.widgets` package, making it easier to reference them (e.g., `Fields.TextField`).
    """

    TextField = TextField
    CheckBoxField = CheckBoxField
    RadioGroup = RadioGroup
    DropdownField = DropdownField
    SignatureField = SignatureField
    ImageField = ImageField

### PyPDFForm/widgets/base.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines the base classes for all form fields and widgets in PyPDFForm.

It provides a foundational structure for representing and interacting with
different types of PDF form elements, such as text fields, checkboxes,
and radio buttons.

Classes:
    - `Field`: A dataclass representing the common properties of a PDF form field.
    - `Widget`: A base class for all widget implementations, providing core
      functionality for rendering and manipulation.
"""

from dataclasses import dataclass
from inspect import signature
from io import BytesIO
from typing import List, Optional, Union

from pypdf import PdfReader
from reportlab.lib.colors import Color
from reportlab.pdfgen.canvas import Canvas

from ..constants import fieldFlags, required
from ..utils import stream_to_io


class Widget:
    """
    Base class for all widgets in PyPDFForm.

    This class provides a common interface for interacting with different types of
    form fields. It handles basic properties like name, page number, and
    coordinates, and provides methods for rendering the widget on a PDF page.

    Attributes:
        USER_PARAMS (list): List of user-defined parameters for the widget.
        COLOR_PARAMS (list): List of color-related parameters for the widget.
        ALLOWED_HOOK_PARAMS (list): List of allowed hook parameters for the widget.
        NONE_DEFAULTS (list): List of parameters that default to None.
        ACRO_FORM_FUNC (str): Name of the AcroForm function to use for rendering the widget.
    """

    USER_PARAMS = []
    COLOR_PARAMS = []
    ALLOWED_HOOK_PARAMS = []
    NONE_DEFAULTS = []
    ACRO_FORM_FUNC = ""

    def __init__(
        self,
        name: str,
        page_number: int,
        x: Union[float, List[float]],
        y: Union[float, List[float]],
        **kwargs,
    ) -> None:
        """
        Initializes a Widget object.

        This method sets up the basic properties of the widget, such as its name,
        page number, and coordinates. It also handles user-defined parameters,
        color parameters, and hook parameters.

        Args:
            name (str): Name of the widget.
            page_number (int): Page number of the widget.
            x (Union[float, List[float]]): X coordinate(s) of the widget. Can be a single float or a list of floats.
            y (Union[float, List[float]]): Y coordinate(s) of the widget. Can be a single float or a list of floats.
            **kwargs: Additional keyword arguments for customizing the widget.

        Returns:
            None
        """
        super().__init__()
        self.page_number = page_number
        self.acro_form_params = {
            "name": name,
            "x": x,
            "y": y,
        }
        self.hook_params = []

        for each in self.USER_PARAMS:
            user_input, param = each
            if user_input in kwargs:
                value = kwargs[user_input]
                if user_input in self.COLOR_PARAMS:
                    value = Color(
                        value[0],
                        value[1],
                        value[2],
                        value[3] if len(value) == 4 else 1,
                    )
                self.acro_form_params[param] = value
            elif user_input in self.NONE_DEFAULTS:
                self.acro_form_params[param] = None

        for each in self.ALLOWED_HOOK_PARAMS:
            if each in kwargs:
                self.hook_params.append((each, kwargs.get(each)))

    def _required_handler(self, canvas: Canvas) -> None:
        """
        Handles the 'Required' flag for the widget's AcroForm field.

        This method inspects the default flags of the AcroForm function associated
        with the widget and modifies them based on the widget's 'required' parameter.
        If the widget is marked as required, the 'required' flag is added to the
        AcroForm field flags; otherwise, it is removed. This ensures the PDF form
        field's required status is correctly reflected.

        Args:
            canvas (Canvas): The ReportLab canvas object used for PDF operations.
        """
        default_flags = signature(
            getattr(canvas.acroForm, self.ACRO_FORM_FUNC)
        ).parameters.get(fieldFlags)
        default_flags = (
            default_flags.default.split(" ")
            if default_flags and default_flags.default
            else []
        )

        if self.acro_form_params.get(required):
            default_flags.append(required)
        else:
            if required in default_flags:
                default_flags.remove(required)

        default_flags = " ".join(list(set(default_flags)))
        self.acro_form_params[fieldFlags] = default_flags
        if required in self.acro_form_params:
            del self.acro_form_params[required]

    def canvas_operations(self, canvas: Canvas) -> None:
        """
        Performs canvas operations for the widget.

        This method uses the ReportLab library to draw the widget on the PDF canvas.
        It retrieves the appropriate AcroForm function from the canvas and calls it
        with the widget's parameters.

        Args:
            canvas (Canvas): Canvas object to operate on.

        Returns:
            None
        """
        getattr(canvas.acroForm, self.ACRO_FORM_FUNC)(**self.acro_form_params)

    def watermarks(self, stream: bytes) -> List[bytes]:
        """
        Generates watermarks for the widget.

        This method takes a PDF stream as input and generates watermarks for each
        page of the PDF. The watermark is created by drawing the widget on a
        ReportLab canvas and then embedding the canvas as a watermark on the
        specified page.

        Args:
            stream (bytes): PDF stream.

        Returns:
            List[bytes]: List of watermarks for each page. Each element in the list
                         is a byte stream representing the watermark for that page.
                         If a page does not need a watermark, the corresponding
                         element will be an empty byte string.
        """
        pdf = PdfReader(stream_to_io(stream))
        page_count = len(pdf.pages)
        watermark = BytesIO()

        canvas = Canvas(
            watermark,
            pagesize=(
                float(pdf.pages[self.page_number - 1].mediabox[2]),
                float(pdf.pages[self.page_number - 1].mediabox[3]),
            ),
        )

        self._required_handler(canvas)
        self.canvas_operations(canvas)

        canvas.showPage()
        canvas.save()
        watermark.seek(0)

        return [
            watermark.read() if i == self.page_number - 1 else b""
            for i in range(page_count)
        ]


@dataclass
class Field:
    """
    Base dataclass for all PDF form fields.

    This class defines the common properties that all types of form fields
    (e.g., text fields, checkboxes, radio buttons) share. Specific field types
    will extend this class to add their unique attributes.

    Attributes:
        name (str): The name of the form field. This is used to identify the
            field within the PDF document.
        page_number (int): The 1-based page number on which the field is located.
        x (float): The x-coordinate of the field's position on the page.
        y (float): The y-coordinate of the field's position on the page.
        required (Optional[bool]): Indicates whether the field is required to be
            filled by the user. Defaults to None, meaning not explicitly set.
        tooltip (Optional[str]): A tooltip message that appears when the user
            hovers over the field. Defaults to None.
    """

    name: str
    page_number: int
    x: float
    y: float
    required: Optional[bool] = None
    tooltip: Optional[str] = None

### PyPDFForm/widgets/bedrock.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""PDF template containing bedrock widgets to copy from."""
BEDROCK_PDF = b'%PDF-1.6\n%\xe2\xe3\xcf\xd3\n1 0 obj\n<<\n/Producer (pypdf)\n>>\nendobj\n2 0 obj\n<<\n/Type /Pages\n/Count 1\n/Kids [ 4 0 R ]\n>>\nendobj\n3 0 obj\n<<\n/Type /Catalog\n/Pages 2 0 R\n/Outlines 6 0 R\n>>\nendobj\n4 0 obj\n<<\n/Contents 5 0 R\n/CropBox [ 0 0 612 792 ]\n/MediaBox [ 0 0 612 792 ]\n/Resources <<\n/ProcSet [ /PDF /Text ]\n>>\n/Rotate 0\n/Type /Page\n/Parent 2 0 R\n/Annots [ 7 0 R 54 0 R ]\n>>\nendobj\n5 0 obj\n<<\n/Filter /FlateDecode\n/Length 10\n>>\nstream\nH\x89\x02\x080\x00\x00\x00\x00\x01\nendstream\nendobj\n6 0 obj\n<<\n>>\nendobj\n7 0 obj\n<<\n/FT /Btn\n/Ff 65536\n/Type /Annot\n/Subtype /Widget\n/F 4\n/MK <<\n/TP 1\n/IF 8 0 R\n/BG [ 0.501961 0.501961 0.501961 ]\n>>\n/M (D\\07220210127180214\\05506\\04700\\047)\n/A <<\n/Type /Action\n/S /JavaScript\n/JS (event\\056target\\056buttonImportIcon\\050\\051\\073)\n>>\n/DA (\\057Micr 12 Tf 0 0 0 rg)\n/Rect [ 170.41 58.97 401.036 212.128 ]\n/AP 9 0 R\n/T (image)\n/P 13 0 R\n>>\nendobj\n8 0 obj\n<<\n/S /A\n>>\nendobj\n9 0 obj\n<<\n/N 10 0 R\n/R 11 0 R\n/D 12 0 R\n>>\nendobj\n10 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/BBox [ 0 0 230.627 153.158 ]\n/Resources <<\n>>\n/Matrix [ 1 0 0 1 0 0 ]\n/Filter /FlateDecode\n/Length 98\n>>\nstream\nx\x9c3T0\x00BC0\x99\x9c\xabP\xa8\xa0\xef\x92Z\x96\x99\x9c\x1a\xe4\xee\xa4\xe0\x1c\x0c\x94\x00\xc1`g?d\xf1\xe4b\x05\x03=S\x03CK3C,\x8c\xe2\xe4<\xa8ypS\xb9\x0c\x14t\r\xf4\x0c\x0c\x0c\xcd-L\x8d,\x14\x8c\x8c\r\xf4\xcc\x8c\x15\x0cM\x8d\xf5\x0c\xcd\x14\x8aR\xb9\x14\xd2\xb8\xb8\x02\x01\xa1\xb6\x1eW\nendstream\nendobj\n11 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/BBox [ 0 0 230.627 153.158 ]\n/Resources <<\n>>\n/Matrix [ 1 0 0 1 0 0 ]\n/Filter /FlateDecode\n/Length 98\n>>\nstream\nx\x9c3T0\x00BC0\x99\x9c\xabP\xa8\xa0\xef\x92Z\x96\x99\x9c\x1a\xe4\xee\xa4\xe0\x1c\x0c\x94\x00\xc1`g?d\xf1\xe4b\x05\x03=S\x03CK3C,\x8c\xe2\xe4<\xa8ypS\xb9\x0c\x14t\r\xf4\x0c\x0c\x0c\xcd-L\x8d,\x14\x8c\x8c\r\xf4\xcc\x8c\x15\x0cM\x8d\xf5\x0c\xcd\x14\x8aR\xb9\x14\xd2\xb8\xb8\x02\x01\xa1\xb6\x1eW\nendstream\nendobj\n12 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/BBox [ 0 0 230.627 153.158 ]\n/Resources <<\n>>\n/Matrix [ 1 0 0 1 0 0 ]\n/Filter /FlateDecode\n/Length 98\n>>\nstream\nx\x9c3T0\x00BC0\x99\x9c\xabP\xa8\xa0\xef\x92Z\x96\x99\x9c\x1a\xe4\xee\xa4\xe0\x1c\x0c\x94\x00\xc1`g?d\xf1\xe4b\x05\x03=\x13K\x0b\x03cK,\x8c\xe2\xe4<\xa8ypS\xb9\x0c\x14t\r\xf4\x0c\x0c\x0c\xcd-L\x8d,\x14\x8c\x8c\r\xf4\xcc\x8c\x15\x0cM\x8d\xf5\x0c\xcd\x14\x8aR\xb9\x14\xd2\xb8\xb8\x02\x01\xaa\xb6\x1ex\nendstream\nendobj\n13 0 obj\n<<\n/Annots 14 0 R\n/Contents 27 0 R\n/CropBox [ 0 0 612 792 ]\n/Group <<\n/CS /DeviceRGB\n/S /Transparency\n/Type /Group\n>>\n/MediaBox [ 0 0 612 792 ]\n/Resources <<\n/ExtGState <<\n/GS7 28 0 R\n/GS8 29 0 R\n>>\n/Font <<\n/F1 30 0 R\n>>\n/ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ]\n/XObject <<\n/wspe_X1 34 0 R\n/wspe_X2 45 0 R\n>>\n>>\n/Rotate 0\n/Tabs /S\n/Type /Page\n/Parent 53 0 R\n>>\nendobj\n14 0 obj\n[ 15 0 R 16 0 R 7 0 R 22 0 R ]\nendobj\n15 0 obj\n<<\n/DA (\\057Arial 0 Tf 0 g)\n/F 4\n/FT /Tx\n/MK <<\n>>\n/P 13 0 R\n/Rect [ 73.3365 662.692 305.76 683.76 ]\n/Subtype /Widget\n/T (test)\n/Type /Annot\n/AA <<\n>>\n>>\nendobj\n16 0 obj\n<<\n/AP <<\n/D <<\n/Off 17 0 R\n/Yes 18 0 R\n>>\n/N <<\n/Off 20 0 R\n/Yes 21 0 R\n>>\n>>\n/AS /Off\n/F 4\n/FT /Btn\n/MK <<\n/BC [ 0 ]\n/BG [ 1 ]\n/CA (4)\n>>\n/P 13 0 R\n/Rect [ 358.874 664.717 377.354 683.197 ]\n/Subtype /Widget\n/T (check)\n/Type /Annot\n>>\nendobj\n17 0 obj\n<<\n/BBox [ 0.0 0.0 18.4798 18.48 ]\n/Filter /FlateDecode\n/FormType 1\n/Matrix [ 1 0.0 0.0 1 0.0 0.0 ]\n/Resources <<\n/ProcSet [ /PDF ]\n>>\n/Subtype /Form\n/Type /XObject\n/Length 54\n>>\nstream\nH\x892\xd0375\xb24VH\xe72P0P0\xb4\xd031\xb7\xb4\x00\xd3\x16\nE\xa9\\i\\\x06z\xa6\n lh\x0e\x952\x87J\x15s\x01\x04\x18\x00hJ\x0c\x19\nendstream\nendobj\n18 0 obj\n<<\n/BBox [ 0.0 0.0 18.4798 18.48 ]\n/Filter /FlateDecode\n/FormType 1\n/Matrix [ 1 0.0 0.0 1 0.0 0.0 ]\n/Resources <<\n/Font <<\n/ZaDb 19 0 R\n>>\n/ProcSet [ /PDF /Text ]\n>>\n/Subtype /Form\n/Type /XObject\n/Length 122\n>>\nstream\nH\x89,\xcc1\x0b\xc2P\x0c\x04\xe0\xfd~EF]b\xd2&}y\xab\xe8\xe6"\x04\x047E[p(\xa8\xff\x1f\xac\xe5q\x1c7|p\xc2\xc5\xbb\xda\xd3\x04!!\r\xb6Rc\xdd\xa0\xcf\x13#\x84\x9d\xfe\xd5\xd2\xa84\xfa\xe2\r\xa5%C\x83\xa1\xc1\x05\xf3r6a\x9f\xd8]o\x87;\xa9\xb3\xa8\x04\xe5\x88\x8e\xa3\x8a\x91\xb1zT\xca\x07\xd4\xd8\xdc{\xca\x136\xb6\xa5|\xe1\x988\xe3\'\xc0\x00\x1f\xc5\x1e\xfd\nendstream\nendobj\n19 0 obj\n<<\n/BaseFont /ZapfDingbats\n/Name /ZaDb\n/Subtype /Type1\n/Type /Font\n>>\nendobj\n20 0 obj\n<<\n/BBox [ 0 0 18.4798 18.48 ]\n/Filter /FlateDecode\n/FormType 1\n/Matrix [ 1 0 0 1 0 0 ]\n/Resources <<\n/ProcSet [ /PDF ]\n>>\n/Subtype /Form\n/Type /XObject\n/Length 48\n>>\nstream\nH\x892TH\xe72P0P0\xb4\xd031\xb7\xb4\x00\xd3\x16\nE\xa9\\i\\\x06z\xa6\n lh\x0e\x952\x87J\x15s\x01\x04\x18\x00"\x8c\n\xe2\nendstream\nendobj\n21 0 obj\n<<\n/BBox [ 0.0 0.0 18.4798 18.48 ]\n/Filter /FlateDecode\n/FormType 1\n/Matrix [ 1 0.0 0.0 1 0.0 0.0 ]\n/Resources <<\n/Font <<\n/ZaDb 19 0 R\n>>\n/ProcSet [ /PDF /Text ]\n>>\n/Subtype /Form\n/Type /XObject\n/Length 118\n>>\nstream\nH\x89,\xcc\xb1\n\x02A\x0c\x04\xd0~\xbebJmb\xa2\xd9\xdbl+\xda\xd9\x08\x01\xc1N\xd1;\xb0\x10\xd4\xff\x07OY\x86a\x8a\x07c\x9c\xa0TZ\x88\xd7\x16\xff\r\xbe\xef\x18\xa1R\xf8\xab\xd5N\xb5\xd3\x07/\x18\xe7\x0c\x1d\x86\x0e\'<\xe7\xb3\t\xdb\xc4\xea|\xd9]iE\xd44\x98#\xd6\x12M\x9d.V\xa21o0\x17/e\xc3<`\xe1K\xe6\x03\xfb\xc4\x11_\x01\x06\x00kk\x1d\xc6\nendstream\nendobj\n22 0 obj\n<<\n/Type /Annot\n/Rect [ 555 745.113 611.887 754 ]\n/F 4\n/Subtype /Link\n/AP 23 0 R\n/A <<\n/Type /Action\n/S /URI\n/URI (http\\072\\057\\057cbs\\056wondershare\\056com\\057go\\056php\\077pid\\0755239\\046m\\075db)\n>>\n/H /N\n/C [ 0.827451 0.827451 0.827451 ]\n/BS 25 0 R\n/BE 26 0 R\n/M (D\\07220170302103307\\05308\\04700\\047)\n/IsRegister /Register\n/NoCaculate false\n/P 13 0 R\n>>\nendobj\n23 0 obj\n<<\n/N 24 0 R\n>>\nendobj\n24 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/BBox [ 0 0.374998 189.624 30 ]\n/Resources <<\n>>\n/Filter /FlateDecode\n/Length 22\n>>\nstream\nx\x9c3T0\x00BC0\x99\x9c\xabP\xa8\xc0\x15\x08\x00"\x1f\x03\xbf\nendstream\nendobj\n25 0 obj\n<<\n/S /S\n/D [ 3 ]\n/W 1\n>>\nendobj\n26 0 obj\n<<\n/S /S\n>>\nendobj\n27 0 obj\n<<\n/Filter /FlateDecode\n/Length 406\n>>\nstream\nx\x9c\xa5\x95MK\x031\x14E\xf7\xf3+\xde\xb2]\x98\xc9{\xc9$\x13\x90Bm+(\x16*\x06\x14Dd,\xadT\xa9\xaduD\xfc\xf7f\xfc\xa0n$\x17d\x16a\x029\xefr9!\xe5\x8c\x0e\x0f\xcb\xe9\xe8dLz0\xa0\xa3\xf1\x88\x9e\x8b\xa3X\x94\xc7L\xacU\xa8).\x89I\xa7\x8f\xc9\x0by\x1dTEq]\\\xf7\xe2\xe4"\xd2l\xdc?\xb0\xbdc\x8a\x93\xfe\x81\xebMg\xdd\xdf\xd90\xfd\xdd\xc4\xd3\xe2\xe7\x1c;\xa3\xd8\xed\xcf\xf6\xa8\x1f\x1f\n\x9a\xc4\x82\xce\xd32\x1d\x15\xe5>\x06#1\\\xed\xb3 \x81@\xce\x02\x99\x0c\x84\xb2\xfc\xb9\x99aY\x88\xc5\xa9*\x9beU\x08\xab\n^\xe9<\xcbA,o\x91\\\x1ebU\x82\xe4\xaa!\x96@}\x05\x88\xa5\xa1\xbe\x18\xba/\xb6\xb6\xca\xe5Y\x90\xf4\xd6\x89\xe2<\x0b\xf2\xde\x9a\x80\xe4\x82\xc4\xb7\xec\x91\\\x90\xf8&@}A\xe2\x1b\x9f\x04\xcb_H\x86\xcc76\x19\x06\xc0 \xf5\x8d\xa4\xc6\x00\xc5 \xf7\x8dN\x95\x010H~\xa9\x05I&\x90\xfcR\x05$\x99@\xf6\x8b\x81:\x13H\x7fa\xa83\x81\xfc\xe7 J\xf2,\xc8\x7fvA\x01O\x1b\xe4?[\x8f\xe4\x82\xf4g\xb1H.\xc8~\xd6\xc9\xb1\xfcU\x12\xc8~\x9f\x14\xfb\x8b5\xdc\xb5\xabe3o;d|\xdf.\xcaYs\xbfzj\xda\xd5\xe6\xa9\xbcx\xbdk\xbb\xad\xcb\xa6]\xec\xd6\xcd\xee\xf1g\x18iU\x7f\xe2\xbb\x95\x93q\xc6\x08\xcd\xd7T\xbe\xbdl\x17\xb7WL\xe3\xcd\xbf\x07\x98\xef\x01&=\x82\x15y[\xfd\x1a _\x03\x8a4\xe0\x03\xee\xd9\x07d\nendstream\nendobj\n28 0 obj\n<<\n/BM /Normal\n/Type /ExtGState\n/ca 1\n>>\nendobj\n29 0 obj\n<<\n/BM /Normal\n/CA 1\n/Type /ExtGState\n>>\nendobj\n30 0 obj\n<<\n/BaseFont /BCDEEE+Calibri\n/Encoding /WinAnsiEncoding\n/FirstChar 32\n/FontDescriptor 31 0 R\n/LastChar 84\n/Name /F1\n/Subtype /TrueType\n/Type /Font\n/Widths 33 0 R\n>>\nendobj\n31 0 obj\n<<\n/Ascent 750\n/AvgWidth 521\n/CapHeight 750\n/Descent -250\n/Flags 32\n/FontBBox [ -503 -250 1240 750 ]\n/FontFile2 32 0 R\n/FontName /BCDEEE+Calibri\n/FontWeight 400\n/ItalicAngle 0\n/MaxWidth 1743\n/StemV 52\n/Type /FontDescriptor\n/XHeight 250\n>>\nendobj\n32 0 obj\n<<\n/Filter /FlateDecode\n/Length1 95024\n/Length 28102\n>>\nstream\nx\x9c\xec}\x07|TU\xda\xfe9\xf7N\xcb\x94d&\xc9\x84$\x930\x93\x0cI\x80\x01\x02\x84\x12\x8ad \x85\x12JB2\x90\x00\x81\x84\x14\x02\x84"E:FQ`\xa3X\xd6\xde\xb1\x17P\'\x03H\xc0\x86\x8au\xed\xb2\xea\xea\xdav\xd5uW\xb0\xec\xaa\xeb\x82$\xdfs\xee;\'\x04VY\xf7\xbf~\x9f\xeb\xff7o\xe6\xb9\xcfs\xdeS\xee9\xef=\xe7\xdc3\x12\x84q\xc6\x98\x1d\x17\x1d\xab.\x1cSP\xfe\xc2\xf5w\x7f\xc7\xf8\xe4 c\x86\xaa\xc21\x13\xf3y\xdd\x15\xe71^<\x8e1\xb5qJY\xf6\xc0\x1b\x1e\xab\xda\xc3\x18\xdf\x8aZ\xd5\xb5\x8bj\x96n-\xde\x8a\xca\x0br\x91\x7f\xb0\xf6\xac\x15\x9e}K\xdf\x1c\xcc\xd8\xf6x\xc6\xf4\x0f5,\x9d\xb7h\xe3\xbb\xeaP\xc6\x16}\xc7\x98\xcd7\xafiM\xc3\xe5\xbb[\xe63v\xfb\xcb\x8c\xe5\x154\xd6\xd7\xd4\xfd\xfd9\xef1\xb4gE{C\x1a\xe1\xb0\xdd\x9br\x04\xe9\x02\xa4{4.Z\xb1\xfa\xdb\x89)\xaf#\xfd\tc\x8d%MKjkF\xf6\xf6-b\xec#\xb4?\xe8\xe8\xa2\x9a\xd5K\xfbVe|\x83\xfcF\x94\xf7,\xaa_Qs\xe8\x9a\xb7\x162\x1e\xb0#\xdd\xb4\xb8fQ}\xcb\xe3\x07s\x19OFz\x80s\xe9\x92\xe5+:\\l3\xc6\xd3S\x94_\xba\xac~i\xdc\xbc\xf4$\xc6\xd6!\xdd\xe3S&ba\xc8\x9dZ\xda\xc0\xca\xe7\xc4\x8c\xfc\x9a%\x99\x98\xb0\x07?]\xff\xbc\xe0\xd7\x9f\xea\xd1\xeb\xd8\xd1\xe3\xcdQ\x87MC\x90\x8cb\n#C=\x03kg\xfc\xa0y\xfb\xb1\xa3G\xb7G\x1d\xd6Z\xeabI;\x85\'y=kfvV\x89z\n8\x9bma,v\x88v_\xceT\x9d\x8f_\xc2\xf4\xcc\xa4\xbfF\x9f\x83&\xbb\x13\xab/\xb3\xcd\n31%F\xaf(\x8aNUt\xef\xb3~\x1d\x07X\x8fuZ\x0f`\x93\xca<\x1e\xe6g,\xe3y\xea\x83\xf1F%\xd3\xc3x\x87\xc8S\xf7\xea\xa3\xc5HY\xbc.\xfaDo\xf8Kx\xdc73/\xfb\tMw\x98\xed\xec\x9aV?99\xfdC\xa6\xde\xcbv\xea\xadl\xe6O\xd9\x97\x93\xda\xaf\xfa\xfe~\x18\xde\xf8q\xfd\xfb1\xa6K\xff\xe1\xb60\xbe\xb1\xdf\xeb\xff\x98\xc5\xfcT\xf7\xffwM\xfd\n\xb3\xef\'4]=\xbb\xf9\xa4\xf6\x9bON\xff`?J\xd8\xcd\xbasY\xd3O\xd9\x97\xae\xa6\xbc\xff\xfd\xfd0\x18~\\\xff~\x8c\xa9O\x9ehK=rJ\x1c\xa6\xb0\xf1\xdf[\xa7\x92\xa5\xfcT\xf7\xffo3\xdd V\xfds\xf7!b\xff\xb9)\xcf\xb1k~\xee>\xfc\x12L\xf9\x88\x8d\xfb\x7f\xa9\xc7\xbf\xf9\xdf\xdb\xf7"\x16\xb1\x88E,b\xff\xbe)\xd7q\xf3\x0f\xe6U\xb3#\xff\x97}\xf9\xa5\x98:\x98]\xf0s\xf7\xe1TS\x0f\xb3\xb9@\xe9\xbf*\x87\xef\xc5\xcb\x80y\xff\xb2\xbds\xd8,u9\xbe\xbb\xff\xabr7\xb1z`\xee\xffu\xff\x94 +V\xeee\xa3\xffU\xb9\x9f\xbc\xeeT6R\x19\xcf\xfa\xfeT\xe5"\x16\xb1\x88\xfd<\xa6{\x8c5\xfc\xa7m(_\x9f\xf8o\x1bj1\xbbH\xb9\x0b\xb8\x90]\xa4\x16\xb0\x19\xffTv&\xbbH\xb7\x88]\xd4\x99~\xb3\x8bnfE\xcat\xa6\xfbO\xfb\x13\xb1\x88E,b\x11\x8bX\xc4"\x16\xb1\x88E,b\x11\xfb\xe5Z\xd7\xef\x98\xc2\xe4\xf7LM\xff\x88\xef\x99\x9d\xfe\xf0\xf7\xcd\xc8\xf7\xcc\x88E,b\x11\x8bX\xc4"\x16\xb1\x88E,b\x11\x8bX\xc4"\x16\xb1\x9f\xdfx\xe4\xb7\xd1#\x16\xb1\x88E,b\x11\x8bX\xc4"\x16\xb1\x88E,b\x11\x8bX\xc4"\xf6_j\xcaR\x96\x01d\xfe\xaf\xde\xa3\x81M\x11\xf8\xf7ju\xdc\xf5\xbf\xd3\x9b\x88E,b\x11\x8bX\xc4"\x16\xb1\x88E,b\x11\x8bX\xc4"\x16\xb1\x88E,b\x11\x8bX\xc4"\x16\xb1\x88E,b\x11\x8bX\xc4:\xf6\xff\xdc=\x88\xd8\x8f25\x8c\x94\xf0\xbfvt\x14)(\xe5c\xa6c\xef"\xdd\x8fy\xa0\xc4\xbf;dc\xe9,\x87\x8dfc\xd9$V\xc2\xcaY\x1d[\xc6\xb6\xb3]\xa9}R\x07\xa4\xe6\xa4\x0eK\x1d\x95\xea\xf7Dy6e<\xdf\xa1\xfd\xabE(\xefa\x03Q\xbe\x80MD\xf9\xb2p\xf9\x10\xca\xf7G\xf9\xdcp\xf9s\xb5\xf2\xbc\xe3kt\xe3\xa1\x8e\'\xb4\x9aF\xe0\x01\x9e\xdcQ\xab\x16}\xba\xe5\xc4\xcf\x91\xac?\x9e\xff\xde\x19\xe1~\xf6\x0e_\xfb\xe3\xda\xff\xf4#T\'\xa8W\xb1D\x8c0\x93e\xb1Q\xe8\xcfl\xf4\xc5\xc0\x0fk\xb9_\x9e\xfa\xaf<!\xad\x84\xffM(\x85\x9d\xdex\x97\xf6O\xdf\x85\xcf\xd4\xcfO\x93M\xff\xdf\x1a\xd9Ci\xa2\xa7\xc2\xa6kW\xd1\xe7\xd3w&\xf94y\x17\x9e\xbe\xee\x7f\x9d\xa9?ik\xff_\xcfd\xff\x8c\xcd\xe7\xafX\xbe\xec\xcc\xa5K\x16/jZ\xb8`~\xe3\xbc\x86\xfa\xba\xb9sfW\xcd\x9a9\xa3\xb2"P^6\xb5\xb4d\xca\xe4I\x13\x8b\'\x8c\x1f7\xb6\xa8\xb0 \x7f\xcch\x7f\xde\xa83F\x8e\x18>,w\xe8\x90\xc1\xd9\xfd\xfa\xf6\xe9\x99\x99\xd1\xc3\x9b\xeeN\x8cw\xd8cl\x16s\x94\xc9h\xd0\xebT\x85\xb3>\x85\xde\xa2jO0\xb3:\xa8\xcb\xf4\x8e\x1b\xd7W\xa4\xbd5p\xd4tqT\x07=p\x15\x9d\\&\xe8\xa9\xd6\x8ayN.\xe9G\xc9\x86SJ\xfa\xa9\xa4\xbf\xb3$\xb7{F\xb2\x91}\xfbx\n\xbd\x9e\xe0\x0b\x05^O\x1b\x9fQZ\x01\xbd\xad\xc0[\xe9\t\x1e\xd1\xf4$M\xeb2\xb5\x84\r\x89\xb44\xd4\xf0\x14&6\x16x\x82\xbc\xdaS\x18,:\xab\xb1\xa5\xb0\xba\x00\xed\xb5Z\xcc\xf9\xde\xfczs\xdf>\xac\xd5l\x81\xb4@\x05{z\x97\xb6\xf2\x9e\xa3\xb8&\x94\x9e\x85\xc3[\x15f\xb2\x89\xdb\x06\xd5\x8c\xc2\x9a\xba`IiEa\x81+-\xadR\xf3\xb1|\xad\xad\xa0!?h\xd4\xda\xf2\xcc\x17}f\x17xZ\xfb\x1ch\xb9\xb0\xcd\xce\xe6V\xfb\xacu\xde\xba\x9aY\x15A\xb5\x06\x95Z\xd4\xc2\x96\x96-A\x87/\xd8\xcb[\x10\xec\xb5\xf6\xc3D\x0c\xb9>\xd8\xc7[P\x18\xf4y\xd1X\xf1\xd4\xce\x1b\xf0\xa0>\xc3\xee\xf5\xb4|\xcd\xd0y\xef\x91\xc3\'{j\xc2\x1eC\x86\xfdk&\xa4\x18bg\x98\x90/5C\xdf\xd0C\x8c/-M\xf4\xe5\x826?\x9b\x8bD\xb0\xb9\xb4\x82\xd2\x1e6\xd7\x15b\xfel_eP\xa9\x169\x07d\x8e3 r\x9aeNg\xf5jo\x9axT\x85\xd5\xe1\xcfY\x8d\x89\xc1\xe6\xb9\x9e\xbe}\x10}\xed\x93\x81\x0f\xf2=A5\xb3znm\xa3\xe0\x9a\xfa\x16oA\x01\xc5\xad\xbc"\xe8/\x80\xf0\xd7\x84\xc7Z\xd8\xda?\x1b\xe5k\xaa1\x88\xf9"\x0c\xa5\x15\xc1l\xef\xd2`\xbcw\x0c\x15\x80\xc3#\x9e\xc1\xfc\xb2\n\xadJ\xb8Z0>?\xc8\xaak\xc3\xb5\x82\xd9\x85\x05\xa2_\x9e\xc2\x96\xea\x02\xea\xa0h\xcb[Z\xb1\x8f\xe5t\xbc\xdf:\xc8\xe3\xda\x95\xc3\x06\xb1J\xd1\x8f`B>\x1eJfaKE]C\xd0]\xed\xaa\xc3\xfcl\xf0T\xb8\xd2\x82\xfeJ\x84\xaf\xd2[Q_)\x9e\x92\xd7\x1e\xec\xf5>n\x97\xa6\xddQ\xab\x85\xb1\x9dRZ\x16\x16#7f\x98<\x15\x8aK\xad\x14O\x0b\x0eO\x11.\xde1#\x91a\xc7\xe3\xd2\x92\xe2\x89\x8e\x19\xe9\xa9\xe0.&\x8b\xe1.\xe1\x12B\x9d\xd4\x0e\x12jF\xfe8\x91\xa5\x8a\xaa\xf9\xe3\\i\x95id\xa7\xe9\x92+\xdc\'}F\xd0\xd4\xa5-;\x1c\x9d}\xa2\xfb\xfc`\xd7\xa8\xb4\xe8P/Oa}A\x97\x0e\x9e\xd4\xa8>\xdc\xc1pk\xdf\xdfOE\xc4"|c\xd40\x89\xc79Nf\xa9\x19X\xb9\xf0)hFs\x89\xa7\x98\xe8\t\xb2\x12O\x85\xb7\xde[\xe9\xc5\x1c\xf2\x97T\x88\xb1\x89Xk\xcf\xb7\xb8\xcc[\\:\xa3B{\xda\xe1YR~R\x8a\xf2s)\x15di\xc8\x96\t%\x1fs\xb0\xc8\xe7\x92\x8fUK\x8f\xd5\xd2\x9d\xc9q\xa7d\x8f\x97\xd9^\xd1\xaf\x96\x96\xbaV\xa6f\x88\xa9\xecj\xe5\x9a\xd0\xe7_P\x19\x9c\xe2\xab\xf4\x06\xe7\xfa\xbci\xa2\x9f}\xfb\xb4\x9a\x985\xad\xbc:\x1fk\xb5\x08\xdb\x9d\xb7\xa8\xc6\xeb\xb1{\x8aZj\xda:\x9a\xe7\xb6\xb4\xfa\xfd-K\x0b\xab\x1b\x87c]\xb4x\xc7\xd7\xb5x\xcb*F\xba\xb4\xceO\xad\xd8\xe0Z+\xee\x1d\xcb\x8ayq\xf9\x184\xa5\xb01\xad^\xbe\xb5\xb4\xd5\xcf\xb7\x96\xcd\xa8\xd8gg\xcc\xb3\xb5\xbc"\xa4p%\xbfzLek\x0f\xe4U\xec\xf30\xe6\xd7\xbc\x8a\xf0\n\xa7HxDB\xb44\x15\t\x93V\xde\xb5\xcf\xcfX\xb3\x96\xab\xd3\x1cZ\xba\xb6\x8d3\xcdg\x92>\xcej\xdb\x14\xf2\xd9\xe9F\x99\xda\x8d\xfc8\r\xd5\xb6\xe9(\xc7/K\xeb\xe03\x91\xaf\x99J\xf7\x0c\x976!\xc7.r\xf63E\x9c\'E&Y+\x13\x01\xf6\x9b\xf5~\x93?\xcaoUl\nB*\\!x\xf6\xa3l\x14g\xbb\xac\xdc\xc6]\xadhs\xaa\xe6n\xe3\xcd\xadQ~\xd7>\xad\xa5\xa9\xe1\x92\xcd()|\xcd\x9d>\xf4\\\x14\xeb\xd2\x10\xeeG\x03\x0f\x9c\x18A`F\xc5.+C\xfb\xda\x15%\xc6\x08\xc3,Ll\xc4\x1c\xc2\xfb\xa4\xd0S\'\xe6\xdf\xfa\xca\xc6\x96\xeaJ\xb1{\xb0\x04\xccU|x\x90{G\xb1\xa0\xe2\x1d\x85\x1e\x1b\xacA\xb3\xb7~L\xd0\xe2\x1d#\xfcy\xc2\x9fG~\x83\xf0\x1b1\xf3y\x02\xc7\xc3\x16\x9bnK\xb5\x17\x1b1VL\x05sqZk\xaah\xd2\xd3\xd6\xd1Q^\x91\xf6\x82\xebHe\x1a\xd6\xd2,`FE0\xca\x87\x97\x9b>c\x02\xca\x8d\x15\xa8\x86{l\xb0\xb9\xb6F\xf4\x83\x05*D]c\xc6\xf8\xdaJ\xacK\xd9 \x8a\x8c\x0fF\xa1\x85\xa8p\x0b(Q\xa4\xd5\x11\xeb\r\x95j1\xd7j\xbc\x9a\x84\x1b[Gse\xb0\xd2\'nZ1\xbfR[\xaf\xf6 \x1b\xe7\x1d\x1e4dR\x9b\xfaLq\xa3\xec\xca\x96X\xef@m\xf3\xc1Z7gl\x11\x14\x85\xbe\xb1\xb2\n\xf2\xb8\x90\xc4\xcd*)HF+z^\xebEVm\xb5\x87\xe6H\x19\xd62\xbd,\xcc.\xf2\xd4c\xcf\xd7e\xd6k0\xbb\xc2\x99L\x0cK\xcd\xb0\xd8\xcc\xc1\xa8~h\x10\x1f\xa1-\xfd\xc4\x9e\xa3\xcf0VVR\xe7\xb5\xd4\x96p\x01\xdc\xdb\x1e\xb4\xa0G\x99]B\x19\xae\x80\xe8 k\xbc\xe8\x0b>[\xd0UQ\xf41\xd1Li\x1b\x9b\xea]\x8d\xadStZk\xc9\x88\xec\xa0-c|\r\xdenT\xdf\x02\x8f7WV6\x89M\xd0\x12n\xe3 y\x8db\xe4V\xc4\x1d[B[\xc7\x9d\xde5i]\x0c{\x87x\xfb\x89\xf9\xc7\\\xfb\xb0PYe\xcb\xa9\x8e\xe0L_\xdf>\xa6S\xbd6\xcd\xdd\xd2b\xb2}\x7f\x05\x8a\x97\xc9\xd6\xc9\x9aS\xc9\xa8\x15o\x05\xb0\x98p\xda|\xf3\x14\x8aW\xa5wB\xab2\xd9\xa71\xd7\xb8e\x82\x17o\x10%C\x00\x07\x1d\x15\xcb\'\xcdSW)J\xa1\xcb%\xda^\xf6\x83\x85x\x97B\xe25\xad5\xdeb\x1f!S<\x9c\xa2\x87\xd9\x12\x9cwr\xb2\xb13Y$\x80\xc3`F?:C`(b\xaf\xc5\\Y\xe0\n6af\xca"\xe2\x89xZ<v\xefp\xaf\xb8h\x95\xc7\nT\xe3!u.\x0bL\x7f\xcc:\xb1h\x9ak=\x15s1\xd9\xd1`QuKQ\x8b8\xa2\xd6\xd6\x84\xc3\x16\xbeSp\xb1\xef\xa4&\xb1.8&\x0f\x1a\x12\xc3\t6\x97x\xaa+=\xd58\x9a\xf2\xd2\x8a\xb44\x17V#\xd8\xd3\x80s\xaa\xb7F\xbc\nJh<%3\xb4\xa3JM\x8b\x98\xe2\x0c\'\x95JW\xd0\x88\x17SCM\xbd7\ro\x90\xa0\xd8\x81(\xfa\xa2\x8f\xba\xf0\xb2a\xae\x96\x16oKP[\xb7E(\x8c\xe63\xb1\xec\xc6\x0b\xc2g\xa9\xcf[S/\x8e\xd0\r\xe2\x04]\xaf\xd5-Bw\xb5\xe8\x88\xd6\\\x85^\xac\xe5z\xb8\xb5X"p\xd8\xfa\xe6\x8aKm\x8b8\xa0WU\xfb\x10\tGKl\x8bgX\x0b\xb6\xe0*\xbc=t\x99\xb5\xd3\xaa\xf1\xaa\x12o$\x8f\xf6\xa8k\\H!\x08\xe3E\xaa\x12\rQ\xc1\xa8\x0cQ\x90\x96\x80\xe8\xcd"_k\x951\xe3\x84G\xfb,\xf1Qa\x93\xd6*z6\xb5"X"\x8bh\xebI\x883}A\xa5[.2\xc5\xe0\xf9\xd4\x19\x15r\x9fRE\xf6x\x84\xd7\x8fY\xe5\x12\xb5=A\xa5\xbc"\xfcx\xb4\xfa\xe3EU\x97|`T\r\x1e\xed\x1d\x12^_\x9do\x1b\xf9\x1e\x9a\xe5BL\x7f\xd0\x8f\x97\x83:\xbaLyFy\x8a\xe52\xb7\xf2t\x98\xdfa\xb9\xca[,\xa0\xfc\x0e\xfc\x06\xf8\xcd0\xbf\x0e\xfe-\xf8\x10\xf85\xf0\xab\xe0W\xc0\x8f\x82\x1f\x01?\x0c~\x88\x05\x98Ny\x9b\r\x02\xca\x01\xb5S\xd5\x01\xb7\x01\x87\x00=[\x88\x968\xb3\xa0>g\xf1\xca\xe3\xac\x00\xa8\x03V\x00\x97\x03z\x94}\x04y\xb7\xa1E\xce<\xcay\xbb\xa3\x12\xf9\x04<\xd0MR\x9c+\xc59R4Kq\xb6\x14\x1b\xa5\xd8 \xc5z)\xd6I\xb1V\x8a5R\xac\x96b\x95\x14gI\xb1R\x8a\x15R,\x97\xe2L)\x96J\xb1D\x8a\xc5R,\x92\xa2I\x8a\x85R,\x90b\xbe\x14\x8dR\xcc\x93\xa2A\x8az)\xea\xa4\xa8\x95b\xae\x145RTK1G\x8a\xd9RTI1K\x8a\x99R\xcc\x90\xa2R\x8a\n)\xa6K1M\x8a\x80\x14\xe5R\x94I1U\x8aR)J\xa4\x98"\xc5d)&I1Q\x8ab)&H1^\x8aqR\x8c\x95\xa2H\x8aB)\n\xa4\xc8\x97b\x8c\x14\xa3\xa5\xf0K\x91\'\xc5()\xce\x90b\xa4\x14#\xa4\x18.\xc50)r\xa5\x18*\xc5\x10)\x06K1H\x8a\x1c)\x06J1@\x8a\xfeRdK\xd1O\x8a\xbeR\xf4\x91\xc2\'Eo)zI\xd1S\x8a,)2\xa5\xc8\x90\xa2\x87\x14^)\xd2\xa5H\x93\xc2#\x85[\x8a\xeeR\xa4J\x91"\x85K\x8ad)\x92\xa4H\x94\xa2\x9b\x14\tR8\xa5\x88\x97"N\x8aX)\x1cR\xd8\xa5\x88\x91"Z\n\x9b\x14V),R\x98\xa5\x88\x92\xc2$\x85Q\n\x83\x14z)tR\xa8R(Rp)XX\xf0\x0e)\xda\xa58.\xc5wR\x1c\x93\xe2\xa8\x14\xff\x90\xe2[)\xfe.\xc57R|-\xc5WR\xfcM\x8a\xbfJ\xf1\xa5\x14_H\xf1\xb9\x14\x9fIqD\x8a\xc3R|*\xc5_\xa4\xf8\xb3\x14\x9fH\xf1\')>\x96\xe2#)>\x94\xe2\x8fR\xfcA\x8a\x0f\xa4x_\x8a\xf7\xa4xW\x8aw\xa4\xf8\xbd\x14oK\xf1\x96\x14\xbf\x93\xe2M)\xde\x90\xe2u)~+\xc5!)^\x93\xe2U)^\x91\xe2e)^\x92\xe2E)^\x90\xe2y)~#\xc5sR<+\xc53R<-\xc5SR<)\xc5A)\x9e\x90\xe2q)\x1e\x93\xe2\x80\x14\x8fJ\xf1\x88\x14\x0fK\xf1\x90\x14\x0fJ\xb1_\x8a}R\xb4I\xb1W\x8a\x07\xa4\xd8#\xc5n)vI\x11\x92\xa2U\x8a\xa0\x14\xf7Kq\x9f\x14\xf7J\xb1S\x8a\x1dR\xdc#\xc5\xddR\xdc%\xc5\x9dR\xdc!\xc5\xedR\xdc&\xc5\xadR\xdc"\xc5\xcdRl\x97\xe2&)n\x94\xe2\x06)\xae\x97\xe2:)\xae\x95\xe2\x1a)\xae\x96\xe2*)\xae\x94\xe2\n).\x97\xe22)~-\xc5\xa5R\\"\xc5\xc5R\\$\xc56).\x94\xe2\x02)Z\xa4\xf8\x95\x14[\xa5\xd8"\xc5f)\xce\x97B\x1e{\xb8<\xf6py\xec\xe1\xf2\xd8\xc3\xe5\xb1\x87\xcbc\x0f\x97\xc7\x1e.\x8f=\\\x1e{\xb8<\xf6py\xec\xe1\xf2\xd8\xc3\xe5\xb1\x87\xcbc\x0f\x97\xc7\x1e.\x8f=\\\x1e{\xb8<\xf6\xf0eR\xc8\xf3\x0f\x97\xe7\x1f.\xcf?\\\x9e\x7f\xb8<\xffpy\xfe\xe1\xf2\xfc\xc3\xe5\xf9\x87\xcb\xf3\x0f\x97\xe7\x1f.\xcf?\\\x9e\x7f\xb8<\xffpy\xfe\xe1\xf2\xfc\xc3\xe5\xf9\x87\xcb\xf3\x0f\x97\xe7\x1f.\xcf?\\\x9e\x7f\xb8<\xffpy\xfe\xe1\xf2\xfc\xc3\xe5\xf9\x87\xcb\xf3\x0f\x97\xe7\x1f.\xcf?\\\x9e\x7f\xb8<\xffpy\xfe\xe1\xf2\xfc\xc3\xe5\xf9\x87\xcbc\x0f\x97\xc7\x1e.\x8f=\\\x9ev\xb8<\xedpy\xda\xe1\xf2\xb4\xc3\xe5i\x87\xcb\xd3\x0e\x97\xa7\x1d.O;\\\x9evx\xfe.!\xda\x94\xf3B\xddG\xb9qf\x0euw\x82\xce\xa5\xd49\xa1\xee\xc3A\xcd\x94:\x9bhc\xa8\xbb\x15\xb4\x81R\xeb\x89\xd6\x11\xad%Z\x13J\x1d\rZ\x1dJ\xcd\x07\xad":\x8bh%\xe5\xad\xa0\xd4r\xa2e\xe4<3\x94:\x06\xb4\x94h\t\xd1b*\xb2\x88\xa8\x89ha(\xa5\x10\xb4\x80h>Q#\xd1<\xa2\x86PJ\x01\xa8\x9eRuD\xb5Ds\x89j\x88\xaa\x89\xe6\x10\xcd\xa6zU\x94\x9aE4\x93h\x06Q%Q\x05\xd1t\xa2iD\x01\xa2r\xa22\xa2\xa9D\xa5D%DS\x88&\x13M"\x9aHTL4!\xe4\x1a\x0f\x1aO4.\xe4\x9a\x00\x1aKT\x14r\x15\x83\nC\xae\x89\xa0\x02\xa2|\xa21\x947\x9a\xea\xf9\x89\xf2\xa8\xde(\xa23\x88FR\xc9\x11D\xc3\xa9\xfa0\xa2\\\xa2\xa1DC\x88\x06Sc\x83\x88r\xa8\x95\x81D\x03\x88\xfaSc\xd9D\xfd\xa8^_\xa2>D>\xa2\xdeD\xbd\x88z\x12eQ\xd3\x99D\x19\xd4f\x0f"/Q:5\x9dF\xe4\xa1zn\xa2\xeeD\xa9D)D.\xa2\xe4P\xf2dP\x12Qb(y\n\xa8\x1bQ\x029\x9dD\xf1\xe4\x8c#\x8a%rP\x9e\x9d(\x86\x9c\xd1D6"+\xe5Y\x88\xccDQ\x94g"2\x12\x19BI% }(\xa9\x14\xa4#R\xc9\xa9P\x8a\x131\x8dx\x07Q\xbbV\x84\x1f\xa7\xd4wD\xc7\x88\x8eR\xde?(\xf5-\xd1\xdf\x89\xbe!\xfa:\x94X\x0e\xfa*\x94X\x06\xfa\x1b\xa5\xfeJ\xf4%\xd1\x17\x94\xf79\xa5>#:Bt\x98\xf2>%\xfa\x0b9\xffL\xf4\t\xd1\x9f\x88>\xa6"\x1fQ\xeaCJ\xfd\x91R\x7f \xfa\x80\xe8}\xca{\x8f\xe8]r\xbeC\xf4{\xa2\xb7\x89\xde\xa2"\xbf\xa3\xd4\x9bDo\x84\xbaM\x07\xbd\x1e\xea6\r\xf4[\xa2C\xe4|\x8d\xe8U\xa2W\x88^\xa6"/\x11\xbdH\xce\x17\x88\x9e\'\xfa\r\xd1sT\xe4Y\xa2g\xc8\xf94\xd1SDO\x12\x1d$z\x82J>N\xa9\xc7\x88\x0e\x10=Jy\x8f\x10=L\xce\x87\x88\x1e$\xdaO\xb4\x8f\xa8\x8dJ\xee\xa5\xd4\x03D{\x88v\x13\xed\n%\xe4\x81B\xa1\x84\x99\xa0V\xa2 \xd1\xfdD\xf7\x11\xddK\xb4\x93h\x07\xd1=\xa1\x04\xec\xd7\xfcnj\xe5.\xa2;)\xef\x0e\xa2\xdb\x89n#\xba\x95\xe8\x16\xa2\x9b\x89\xb6\x13\xddD\x8d\xddH\xad\xdc@t=\xe5]Gt-\xd15DWS\x85\xab(u%\xd1\x15D\x97S\xdee\xd4\xca\xaf\x89.\xa5\xbcK\x88.&\xba\x88h\x1b\xd1\x85T\xf2\x02J\xb5\x10\xfd\x8ah+\xd1\x16\xa2\xcd!g\r\xe8\xfc\x90s.\xe8<\xa2M!g\x03\xe8\\\xa2sB\xce\x00\xa89\xe4\xc4f\xcc\xcf\x0e9\x87\x806\x12m\xa0\xea\xeb\xa9\xde:\xa2\xb5!g\x1dh\rU_M\xb4\x8a\xe8,\xa2\x95D+\x88\x96S\xd3\xcb\xa8\xfa\x99DKC\xceZ\xd0\x12jl1\x95\\D\xd4D\xb4\x90h\x01\xd1|\xaa\xd7H4\x8fz\xd6@\xd5\xeb\x89\xea\xa8d-\xd1\\\xa2\x1a\xa2j\xa29D\xb3i\xd0U\xd4\xb3YD3i\xd03\xa8\xe9J\xbaQ\x05\xd1t\xea\xee4\xbaQ\x80Z)\'*#\x9aJT\x1a\x8a\xf7\x83JB\xf1\xe2\x0eSB\xf1bzO\x0e\xc5o\x02M\n\xc5\xf7\x05M\xa4"\xc5D\x13B\xf18\x17\xf0\xf1\x94\x1aG4\x96\x9cE\xa1\xf8\x8d\xa0\xc2P\xfc\x16PA(\xfelP~(\xbe\x194&\x14[\x04\x1aM\xe4\'\xca#\x1a\x15\x8a\xc5\xfb\x9d\x9fA\xa9\x91!G%h\x04\xd1\xf0\x90CL\x8daD\xb9!\xc7X\xd0\xd0\x90\xa3\x024$\xe4\x98\x01\x1aLy\x83\x88rB\x8e>\xa0\x81Tr@\xc8!\x06\xd6?\xe4\x10k3\x9b\xa8\x1fU\xefKw\xe8C\xe4\xa3\xc6z\x13\xf5\xa2\xc6z\x12e\x11e\x12e\x84\x1c"J=\x88\xbc\xd4f:\xb5\x99F\x8dy\xa8\x157Qw\xaa\x97J\x94B\xe4"J&J\n\xd9\xab@\x89!\xfblP\xb7\x90}\x0e(\x81\xc8I\x14O\x14G\x14K\x15\x1cT\xc1N\xce\x18\xa2h"\x1b\x91\x95JZ\xa8\xa4\x99\x9cQD&"#\x91\x81J\xea\xa9\xa4\x8e\x9c*\x91B\xc4\x89\x98\xbf#f\xae[\xa0=\xa6\xd6}<\xa6\xce\xfd\x1d\xf41\xe0(\xf0\x0f\xf8\xbe\x85\xef\xef\xc07\xc0\xd7\xc0W\xf0\xff\r\xf8+\xf2\xbeD\xfa\x0b\xe0s\xe03\xe0\x08\xfc\x87\x81O\x91\xf7\x17\xa4\xff\x0c|\x02\xfc\t\xf88z\x9e\xfb\xa3\xe8F\xf7\x87\xc0\x1f\x81?\x00\x1f\xc0\xf7>\xf8=\xe0]\xe0\x1d\xa4\x7f\x0f~\x1bx\x0b\xf8\x1d\xf0\xa6m\xa1\xfb\r\xdb\x00\xf7\xeb\xe0\xdf\xda\x9a\xdc\x87l\x99\xee\xd7\x80W\xa1_\xb1\xf9\xdc/\x03/\x01/"\xff\x05\xf8\x9e\xb7-r\xff\x06\xfa9\xe8g\xa1\x9f\xb1-p?m\x9b\xef~\xca\xd6\xe8~\xd26\xcf}\x10u\x9f@{\x8f\x03\x8f\x01\xfe\x8e\x03\xb8>\n<\x02<l=\xd3\xfd\x90u\x99\xfbA\xebr\xf7~\xeb\n\xf7>\xa0\r\xd8\x0b\xff\x03\xc0\x1e\xe4\xedF\xde.\xf8B@+\x10\x04\xee\xb7\xacq\xdfgY\xeb\xbe\xd7\xb2\xde\xbd\xd3\xb2\xc1\xbd\xc3\xb2\xd1}\x0fp7p\x17p\'p\x07p\xbb\xa5\xaf\xfb6\xf0\xad\xc0-\xa8s3x\xbbe\xa1\xfb&\xe8\x1b\xa1o\x00\xae\x87\xbe\x0em]\x8b\xb6\xaeA[W\xc3w\x15p%p\x05p9p\x19\xf0k\xd4\xbb\x14\xed]b\x9e\xec\xbe\xd8<\xc5}\x91y\x9e{\x9b\xf9v\xf7\x85\xe6;\xdd\xe7\xab\x19\xee\xf3\xd4\\\xf7&\x9e\xeb>7\xd0\x1c8gGs\xe0\xec\xc0\x86\xc0\xc6\x1d\x1b\x02\x96\r\xdc\xb2\xc1\xb5\xa1x\xc3\xba\r;6\xbc\xbd\xc1\x1fk0\xaf\x0f\xac\r\xac\xdb\xb16\xb0&\xb0*\xb0z\xc7\xaa\xc0~e3kP\xce\xf7\x8f\x0c\x9c\xb5ce@\xb72~\xe5\x8a\x95\xeaW+\xf9\x8e\x95\xbc`%\xef\xbf\x92+l\xa5}\xa5g\xa5j]\x11X\x16X\xbecY\x80-+Y\xd6\xbc,\xb8L7"\xb8\xec\xfde\n[\xc6\xcdm\x1d\x07v-su/\x02\xfb\xd7/\xb3\xd9\x8b\xce\x0c,\t,\xdd\xb1$\xb0\xb8aQ`\x01:8?w^\xa0q\xc7\xbc@Cn]\xa0~G]\xa06wn\xa0&\xb7:0\'\xb7*0{GU`V\xee\x8c\xc0\xcc\x1d3\x02\x95\xb9\x15\x81\xe9(?-\xb7<\x10\xd8Q\x1e(\xcb-\rL\xddQ\x1a\x98\x92;90\x19\xfeI\xb9\xc5\x81\x89;\x8a\x03\x13r\xc7\x05\xc6\xef\x18\x17\x18\x9b[\x14(\xc4\xe0Y\x8a=\xc5\x93\xa2\xdaE\x07&\xa7\xa0\'\xcc\xc5\xc7\xf4w\xf9]\xef\xbb\xbep\xe9\x98+\xe8:\xe0Rcc\x92\xdd\xc9J\xaf\x98$\x9e?%\x89/I:;\xe9\xe2$5&\xf1\xa5D\xc5\x9f\xd8\xabOQL\xb7\x97\xba\xbd\xd7\xed\xf3n\xba8\x7f\xb7^\xfd\x8aX\x82=\xc1\x93\xa0:\xc5\xd8\x12&\x95\x17i\x9cW@<`\xb06Vw\x827\xb3(\xc6\xc9c\x9cn\xa7R\xf8\xb9\x93of*\xf7p\xce\xb8\x1d\xa4\x9aPf7w\xba\x8b\xd4\x87\xb9\xf8e;=\xe3\xfc\x12V\xee+n3\xb1\xa9\xc5AS\xc9\xcc \xdf\x1a\xcc(\x13W\x7f\xe9\x8c\xa0ak\x90\x05f\xcc\xach\xe5\xfc\xa2J\xedw\x12\x82\xf1\xe2\x97J\xb4\xf4\xf9\xdb\xb6\xb1\xd41\xc5\xc1\xd4\xb2\x8a\x90\xba}{\xea\x98\xca\xe2`\xb3\xd0~\xbf\xa6;\x84f(R\xe9\x9b\xbd|\xe5r_\x85\xff\x0c\xe6x\xdf\xf1\x85Cu>j\x7f\xc9\xae\xc4\xc4\xf0\x98\x98\x8e\x18\xc5\x1f\x83\xce\xc7D\xbb\xa3\x15q\xe9\x88V\xfd\xd1\x03\x86\x16\xc5\xd8\xdc6E\\:lj\x82\xdf\x06\x8f\x18_\x96\xb5\xa4\xbc(\xc6\xe2\xb6(\x81<\xcb\x14\x8b\xe2\xb7\xe4\xe5\x17\xf9-}\xfb\x17\xfd\xd38w\x89q\xd2\x9d}+f\xe32{\xf9\n\x9f\xf6A\xaa\x92\xaf\x14I\x9f\xf0\x8a\xcf\xf2\x15H\x8b\x9f\x95Z\x9a\xf9NkT\x0c4g9l\x85t\xae8}\xad\xffv\xe3?w\x07~\xf9F\xbf\xc93\xbaC9\x8f\xd5)\x9b\x80s\x81s\x80f\xe0l`#\xb0\x01X\x0f\xac\x03\xd6\x02k\x80\xd5\xc0*\xe0,`%\xb0\x02X\x0e\x9c\t,\x05\x96\x00\x8b\x81E@\x13\xb0\x10X\x00\xcc\x07\x1a\x81y@\x03P\x0f\xd4\x01\xb5\xc0\\\xa0\x06\xa8\x06\xe6\x00\xb3\x81*`\x160\x13\x98\x01T\x02\x15\xc0t`\x1a\x10\x00\xca\x812`*P\n\x94\x00S\x80\xc9\xc0$`"P\x0cL\x00\xc6\x03\xe3\x80\xb1@\x11P\x08\x14\x00\xf9\xc0\x18`4\xe0\x07\xf2\x80Q\xc0\x19\xc0H`\x040\x1c\x18\x06\xe4\x02C\x81!\xc0``\x10\x90\x03\x0c\x04\x06\x00\xfd\x81l\xa0\x1f\xd0\x17\xe8\x03\xf8\x80\xde@/\xa0\'\x90\x05d\x02\x19@\x0f\xc0\x0b\xa4\x03i\x80\x07p\x03\xdd\x81T \x05p\x01\xc9@\x12\x90\x08t\x03\x12\x00\'\x10\x0f\xc4\x01\xb1\x80\x03\xb0\x031@4`\x03\xac\x80\x050\x03Q\x80\t0\x02\x06@\x0f\xe8Fw\xe0\xaa\x02\n\xc0\x01\xc6\xea8|\xbc\x1d8\x0e|\x07\x1c\x03\x8e\x02\xff\x00\xbe\x05\xfe\x0e|\x03|\r|\x05\xfc\r\xf8+\xf0%\xf0\x05\xf09\xf0\x19p\x048\x0c|\n\xfc\x05\xf83\xf0\t\xf0\'\xe0c\xe0#\xe0C\xe0\x8f\xc0\x1f\x80\x0f\x80\xf7\x81\xf7\x80w\x81w\x80\xdf\x03o\x03o\x01\xbf\x03\xde\x04\xde\x00^\x07~\x0b\x1c\x02^\x03^\x05^\x01^\x06^\x02^\x04^\x00\x9e\x07~\x03<\x07<\x0b<\x03<\r<\x05<\t\x1c\x04\x9e\x00\x1e\x07\x1e\x03\x0e\x00\x8f\x02\x8f\x00\x0f\x03\x0f\x01\x0f\x02\xfb\x81}@\x1b\xb0\x17x\x00\xd8\x03\xec\x06v\x01!\xa0\x15\x08\x02\xf7\x03\xf7\x01\xf7\x02;\x81\x1d\xc0=\xc0\xdd\xc0]\xc0\x9d\xc0\x1d\xc0\xed\xc0m\xc0\xad\xc0-\xc0\xcd\xc0v\xe0&\xe0F\xe0\x06\xe0z\xe0:\xe0Z\xe0\x1a\xe0j\xe0*\xe0J\xe0\n\xe0r\xe02\xe0\xd7\xc0\xa5\xc0%\xc0\xc5\xc0E\xc06\xe0B\xe0\x02\xa0\x05\xf8\x15\xb0\x15\xd8\x02l\x06\xcegu\xa3\x9b9\xd6?\xc7\xfa\xe7X\xff\x1c\xeb\x9fc\xfds\xac\x7f\x8e\xf5\xcf\xb1\xfe9\xd6?\xc7\xfa\xe7X\xff\x1c\xeb\x9fc\xfds\xac\x7f\x8e\xf5\xcf\xb1\xfe9\xd6?\xc7\xfa\xe7\xcb\x00\xec\x01\x1c{\x00\xc7\x1e\xc0\xb1\x07p\xec\x01\x1c{\x00\xc7\x1e\xc0\xb1\x07p\xec\x01\x1c{\x00\xc7\x1e\xc0\xb1\x07p\xec\x01\x1c{\x00\xc7\x1e\xc0\xb1\x07p\xec\x01\x1c{\x00\xc7\x1e\xc0\xb1\x07p\xec\x01\x1c{\x00\xc7\x1e\xc0\xb1\x07p\xec\x01\x1c{\x00\xc7\x1e\xc0\xb1\x07p\xec\x01\x1c{\x00\xc7\x1e\xc0\xb1\x07p\xac\x7f\x8e\xf5\xcf\xb1\xfe9\xd6>\xc7\xda\xe7X\xfb\x1ck\x9fc\xeds\xac}\x8e\xb5\xcf\xb1\xf69\xd6>\xc7\xda\xff\xb9\xf7\xe1_\xb8U\xfe\xdc\x1d\xf8\x85\x1b[\xbe\xbc\xcb\xc1LX\xe2\x9c\xd9\xe2/\x9f\xdc\xc8X\xfbe\'\xfd\r\x92\x12\xb6\x80-g\xcd\xf8\xd9\xcc\xb6\xb1\xcb\xd8\xa3\xecm6\x97m\x82\xba\x86mgw\xb0\xbbY\x90=\xc6\x9eeo\xfc\xf8\xbf\\\xf3\xaf\xad}\x8d~\x11\xb3\xaa{\x99\x81\xc51\xd6q\xb4\xe3H\xfb\x1d@\x9b>\xba\x8b\xe72\xa4\xe2t\x9e\x13\x9e\x0e{\xc7g\xa7\xf8>k\xbf\xac\xc3\xde\xdef\x88ef\xad\xaeMy\x15\xde\xbf\xf1\xe3\x1dG\xf1\xcaE\xbac\x88H+[\xa0c\xb4\x1a_\x1aol\xbf\xbf\xfd\xceSbP\xcaf\xb0\x99l\x16\xabb\xd5\xac\x06\xe3\xafc\x8dl>"\xb3\x905\xb1El\xb1\x96Z\x8c\xbcy\xb86 5\x07\xa5\xb0\xbdh\xfaD\xa9%l)\xb0\x8c\xad`+\xd9Y\xf8Y\n\xbd<\x9c\x12ygj\xe9\x95l\x15~V\xb35l-[\xc7\xd6\xb3\r\xe1\xeb*\xcd\xb3\x1e9k\xb5\xf4j`#;\x1bO\xe6\x1cv\xae\xa6$\x93g\x13;\x8f\x9d\x8f\xa7\xb6\x85me\xbf:m\xeaW\x9d\xaa\x85]\xc0.\xc4s\xbe\x88]\xfc\x83z\xdbI\xa9K\xf0s)\xfb5\xe6\xc3\xe5\xec\nv%\xbb\x1a\xf3\xe2:v\xfd)\xde\xab4\xff\xb5\xecFv\x13\xe6\x8c\xc8\xbb\x02\x9e\x9b4%r\x1fbO\xb1=\xec>v?{@\x8be-\xa2F\x11\x91qi\xd0b\xb8\x141X\x8f\x11n\xea\xd2c\x8a\xdf\xaa\xcehm\xc4\xd8\xc5\xd8Z\xc2#]\r\xff\xb9]j\x9c\x15\x8e\xa3(\xb9\t%\xa9\x15z\x0e\xa2\x95\r\xa7D\xe2\x12\x8c\x81\xf4\x89\x11Q\xea\nm\xfc\'\xbc]\xa3r:\xaf\x8c\xc7\xf5]"s\x9d\x96\x12\xeaT\xef\x0f\xe9+\xd9\rX\x817\xe3*\xa2*\xd4-\xd0\xa4n\xd2tW\xff\x8d\x9de\xb7k\xe9[\xd9m\xecv<\x8b;5%\x99<w@\xdf\xc9\xee\xc2\xda\xbe\x87\xed`;\xf1sBwU\xc4\xf7\xb1{\xb5\'\x17d\xad,\xc4v\xb1\xddx\x92\x0f\xb0\xbd\xacM\xf3\x9f.\xef\xfb\xfc\xbb\xc2\xfeP\xa7g\x1f\xdb\xcf\x1e\xc4\x0cy\x84\x1d\xc0N\xf38~\xa4\xe7a\xf8\x1e\r{\x0fj>J?\xce\x9e@Z\x94\xa2\xd4S\xeci\xecP\xcf\xb1\xdf\xb0\xe7\xd9K\xecI\xa4^\xd4\xae\xcf \xf52{\x95\xbd\xc6\xde\xe06\xa8W\xd8\x9fq=\xce^\xd6\x7f\xc8\xa2\xd9h|\xfd\xdf\x8f8_\xcff\xb3\xd9?\xe5\xeev\xaa\xe9\x93\x99\x93m\xef\xf8\xb6cU\xc7\xb7\xea8\xd6\xc0\xcbq\x80\xdc\x89\xa7\xb4\x9b]\x88o\xec\x8bO\x94\xe4nf\xd6\xfd\x81\xc5\xb3\xdd\x1d\xdf\xa8\xb3\xc0=\x8f\xbf\xa5ol\xbf\xa5\xe3s\xa6\xc7\xae\xb9\\}\x15\xbb\x9c\xca\x8cl\x18\x9b\xc4&\xb3\xab\x82\xe7\xfb*\x1eb6\x9cR\x12\xd8p\xbeg\x8f\xb3\xa0\xc0\xd4\xd7\xf8\x08N \n\xf3\xe0\x0ccb\x9c\xe7\xfbct\x8amorr\x9ew\xef`\xc36\xd51\xbe\x8d\xf7\xdd\x9dg\xdc\x86\xd3y\xde\xf1w\x8f\xbf\x98}\xfc\xdd#\xb1\xc3\xb2\x8f\xf0\xecw>x\xf7\x03\xfb\x97/:\x86e\xe7|p\xe8\x83\x01\xfd]\xfe\xf8d\xdb\xde&T\x1d\xec\xdd\xdb4X5lkR\x1dy\xa2\xbe?\xaa)\xcf\xaf\x18\xb75\xa1\x91\xc4<_\xf2\x8b\xbe\x17\xb3}/\xfa\xd0\x8c\xaf\xff\x80J\xeeHsh\x88\x8fV\x8c\xc6x\x837\xbd\x9f28+sHN\xce\xc0Q\xca\xe0A\x99\xde\xf4hE\xf3\r\x1a2t\x94\x9a3\xb0\xbb\xa2\xc6K\xcf(E\xa4\xb9\xfa\xeaw3\xd4)\xc7\r\xcaFo\xde\xb4\x1c}\xf7\xe4\x98x\x9bA\xaf\xa4$\xc6\xf6\x1d\x99a/\x9b\x991\xb2_\xaaQ5\x1aT\xbd\xc9\xd8s\xe8\x98\xf4\xe2\xa6\xc2\xf4\xb7\x8c\x8eTgBj\xac\xc9\x14\x9b\x9a\xe0Lu\x18\x8f\xbf\xad\x8f>\xfaW}\xf4\xb1|]\xd3\xb1\xcbU\xc3\x88Yy=\xd4\xab\xcd&Eg0\xb4uOL\xea="m\xfc\xb4\x988\xbb\xce\x12gw$\x98\x8c\xb1\x0ek\xcf\x82Y\xc77;SD\x1b)N\'\xb5u|\x12\xc2\xe9\xed8\xaa\xdb\xa8\x8fg\xe9,\x93\xfd^\xc4}\x1f\xeb\xd1\xf1\xc9n\xab\x9dO\xf4\xb6\x85Ef[\xc7\x17\xbb-\x10\x16)\xcc\x10\xfed\xa12\xec\xe2j\xd3\xaeV\xed\xea\xef\xc93Dv\x1f\x0b\x9f\xd4\xc3\x9b\x99\xf1\x95\xd5bMLO\xf5\x9am<AgeV\xbbU\xb9\xdf\xfb\xa8\xf7%\xaf\xea\xb5z\xad\xb1\xa9Sc\x03\xfa\x00\xcb\xcb\xcb\x8b\x1d6,;\xbb\xaa\xca\xd1m\x98\x03\xd2\x91c?2\xd0\x913\xa0?\xf7U\x85\xdf\xfe>\x9f\xcb\xdf\x1dMZ3\xbej\xea\xdaf\xd7v\x12eC\x9d\xcd\xf8\xd0\n\x1e^FB\x82A{bYj\x9a\x1a\xadz\xd333\x87\x0c\xe5\xf4\x98\xba\x19\xbdj\x9an\xa5\x89\xdb3\xdc\xee\x8c\xb8(\xdd\x92\xe3\x1f/P\xcdq\xde\x94\xd4\x8c\x18n\xe2!\x9d-)\xab\xbb\xa7wr\xb4n\x1d\x7f\x8f?~F\x82+Z\xa7\x1a\xadQ|D\xfb\xb3Q\xb6(\x9d>\xda\x95\xa0\x0bY\xa2M\xaaj\x8a\xb1l;\xbe\x0e\x91\xdd\xc9\x98\xeeb\xcc\xebX\xe6fW\x8b\xc8\xfaS\xf3\xd2x\\\xa2\x9dO\x8a\xb3\xc7\xe0\x12o\xc3%\xd6\x8aK"B\x15\xf7 \xbe\x183\x96\xdc\xf1\xc9.\x94HF\x04w\xc5\x84\xd9\xa6\xf17\xbb\xac\x1a\x7f\xb2\x0b\xa5\x93\x1f\xc4W\xd8(\x96\xc8\xad\xa1\xe8RW\x1b\xcfl\xd5\x97\xb3\xbc#y\x98\xed\x1fh\xc1:D4\xa0\x7f\x95\xab5:\xb1\x8d[w7E\x97\xeaE\xc9P\x13\x8abr\xe7iSZL\xd0\xb4\xf4\xcc\xc1\x8eACr\xd2\x10\n\xe3\xa0~\x8a\xd7\xeb\x103Zw\xf1\xb4\xdb\xbf\xb8\xa3\xfd\xb3n\xbdzu\xe3\x19w}rC\xe9\x9eAK\xee\xd9|\x7f\xeb\xfa{\x96\rS\xae\xbd\xeb\xd8\xedS\xddY\xbas\xb3\xdc\xd3o\xfd\xe4\x9a\xf9{\xce\x9b\xf0\x9dcT\xf3c\x8c\x8b\x91\xab\xeb1\xf2>\xec>1\xee\xd6\xe4\xac6\x1aUVxTY\xe1Qe\x85G\x95\x15\x1eUV\x9b\xe2\xf0GE\xc5y\xe2<\x18\\r\x1b7\xf9m\xcd\x99\xfc@&\x7f9\x93gf\x1a\x92\xc4\x1fX\xd8J\xb3@\xad\x06\x1a/\x96f\xd5\x99\xcb0\xecl\xed\xa9\xdbi\xd8\x03\xb1\xc8[3\xb5\x06,M,\x93\'\xa8\xa8mK\xd2\xc2`+5\x88\x06BM\x86p\x18\xd0\xc4\x9c\xd9U"\x1a\x19\xa7F\xc3\xa99\x1c\xa7Hu\xbd\xcel3\x1d\xbfL\x04Fi0\xd9Lz=.\xed\x06\x1e2a.\xe8\xa2\xa0\'+\xdcd3\xeb\xc6\xc6\xbabM\x14$S\xac+>\xd6\xe50\xb5/\x88\xb2\xa7\xc4\xc5&\xdb\x8d\xed\x03L\x0e\x97\xf8\xbb\xf5;;\x8e\xaa\xe5\x88W\x16\xdb\xa4\xc5\xcb\x18\x17\x8eW\\8^q\xe1x\xc5\x85\xe3\x15\x17\x8eW\x1c\xe2\xb5\xc7\x96\xca\xba\xa7\x1a1\xa2]qqI\x866\xdesWzi\x92XP\xe1\xdd/\xfb\xa0cX\x97\xa8\xc4\x89\xa2{\x9aP6]\x14\xde\xdd\xa4\x95\xc6\xb2\xe9\xdc\xe5\xfei\xccr\x13\x93QQ\xcb1~c;\x1e\x8c\x11c\xd4\xb4\xdf\x14\xefINL\x8f7!"E\x9a\xf7`\\\n\x06;\xcehw9\xe3\\\x8e\xa8\xe3\x1f\x19mF\xbd\x1e\x17\xdd}"\x18\xa9\x18\xf7\xcc\x8e\xcft\xab\xf5\x1e\x96\xc7\xde\xa1\xf5\x91\x92\x12\x93(\xd6G\xa2X\x1f\x89v\x8c8\xd1l\x15\ncM\x14s\xc3\xc6\x1e\xcd\xe2\x9e,\x7fVu\x96\x9a\x15\x13\x8eRL8J\xe0\xc3"J\xe0\xcfD\x94b\xc2Q\x8a\x11\xbf\x8b\x9d=\x88\x0f\xc220\xefNO\x1f\x96=\xeaAn\xc6\x9b\xc7\xcc{\x85\x86\x95\xc5\xb7\xf1>\xad\xd9\xd3\xc4l:~\xe8\x88\x83\x82V\x15^EUU\x07I\xc1-\xa2\x97.\xdax\xa0I4\xa2\x1f\x05\xb9\xabI?\xcc\xdc\xc6{\xedn\x1aV\x96-Z\n5\xa1)mZ\x1d\xf49\xbaF\x14\x01\x14\xef\x07g|w\xbc\t\x86\x0cu\x88i&\xde\nZ\x9c\x11b]\x97\xf7\x84N\xb7Zg\xb2\x1a\xad\xb9\xb37\xcdXx\xcfYy\x85k\xef\xae\x1f\xb9np\xfb!\x87C\x17\x85]\xe7:KB\xac9v\xf8\xac\xb9u\x03\xae<|\xeb\xb4\xaa\xbb\x8f\\2\xe1\xdc\xfa\xc2d\xb3nv\\j\x9c)\xb3_\xe6\xe4\x96G\x96\xac?p^Aj*_\x93\xde\x03\x0f\xc0d\xb2\xa7\xc4\xb6\xc7%g\xa6\xa6\'Z\xabv~q\xf9\xb5G\x835\xc9\xde^\xc9\xe9,\xbcb\x8b\xf1\x16Hf5\xf4\x0epRh\x9d\xe1\xd0:\xc3\x13\xd0\x19\x9e\x80\xceph\x9d\xe2\xb7\xb7YT\xccTg\x1b\xf7\x85\x97$\xcf~A\xee=\xae]1S\r"\xabs\xb1\x9d\xbc\xc8\xe8\xa5\xe8\xa4EU\x8c\x85\x13u\xfc`\xb7^\xa6\xf8\xf4\xc4\xa4\xb4x\x13\x7fYl\xad\xc5\xf1\xae\xb8(,\xa1\xfb\x10\x10\xcc\x1f\xab\xe9\xd8\xcdQ\x8e\x14Z5\x06\x1fV\xcdH\xf6\xba6{\xec\xd5\xa3\x96\x8eRl\xfd\xfbw\xcb\xce6\xf7KLLn\xfb\x91[\xa9\x98X\xdd{\x0c\xb0Z\xcdb\xee\x99\xc5\xdc3\x8b\xb9g\x16s\xcf,\xf6f\xf3~\xec\xb6\xac\xe3\x80?\t\t\xd6cH\xa9%\xb1\x9b-;q@?\x83\xbbg\xa9; _`y\xb1x\xe7\xe4 \x00\x87|\xe1\x05\x87\x97X\xa7r\x0c;#;\'G\xbc\xd1\xaap\x00\xf9\xde6\x12O4"\x03\xa5\xad;/\x17/,\xbc\xba\xb8\xf7\xa4\xc5\xa8\xbd\xbbx\x8ex\x8bi\x814\xf8L\xf1\xee\xa4niq&\xa5=G\xb58S\xe3\x9d\xdd\xe3-J\xfbX\x8e\xe5\x99\x94\xe8\x893\xf6q5z\xfa\xf7H\x8c\xe2\xab\xf4|\xb3%\xd9\x9d\x99\xb4(\xc6\x15gM\x96\xc1\xd5\xcd;v\xb9\xd1lTuF\xb3\x01\x87\x8bk:\xfdw\xf4\xeeaM\xee\xe9\xfan\xbazG\xf7\xdeI\x96\xa8\xb8T\xa7x\xc7a\xe7z\x1a\xcf \x85\xf5b7i{W\x0fC8\xec\x86p\xd8\r\xe1\xb0\x1b\xc2a7\x84\xc3n\x10a\xef\xe6H\x151O\x151O\xb5[m|b\xaa\x07y\xa9\xe2W\xd4\x98#C,0\x83\xc1\xeam\xe3\x96]\xceRk\x97M\x8d^o]w{\x83(\xbd\xa7\t\xc5\x9d\xa2\xfc\xee&\xad\xc2\xa9\xfb\x9a\xf7\xd4\xcdL\xd7\xe5\x85\xa7>\xed_u\xef\xea\xcb\xa2\xe2\xd2\x92\xc4\xfc\xeb\x9d\xcc\x9d\xbd\'\xcd_4\xb1\xd7\x9e\x11\xd3\xab\xfa\xdct\xdd\xe4yE=\xd4\xcbj\xae_<\xb2\xbd_g`\xee\xe9\x99n\xec\x967k\xcd\xf4)\x0b\x06E\x1f\xffG\xcf\xb1\xb5\x98\x9bc;\x8e\xa8\xb5\xfa46\x9e\xf7\xa4\xf54\x1aG\xa9\x18\x1c\x8eF\x87\xa3\xa1\xb1=\xccV\x8d\xb5\xa8\x8cnS\xfa\xf8}\x03\xfdq\xf1|\xe2@\xbf\x03\'\xa8\x81=\x06Z]\x89\xa2\xaeKLJ\x97\xdd..\xa8\xe2\x123\xd3\xb5_\x19 f\xe6.\x17&\xa6\xf8\xc3\xb1\xa40\xc7\x13?\x10\xe3\xe0\x13\x99\xb5\xdf\x83<\x8b\r\xc5\x86\x97\xe9\xb78<C\xf9P\xbf\xc5\xca\':\xc4\x9f\xbc\x99\x85\x1a\xea\x18\xeaH\x18)^\x0c\xa3]\xfa^e\t\xd8\xd1Z\xf5\xda\x96\x88\xb7\xea\x11\x87x\xb3\xfa|U\xf6#v\x11z\x11r\xb9)j\x19\x9d\xcb\xbduh?\xf1\xfb\x10M\x0el\x89\x99{\x9b\xb4V{\x89f\xf76i\xed\xeaE\xc38\x7f\xd0\x0e\x89\xda\xbep\xd3\'6I\x9d<*\xd3\x99\xba\x9f!\x9c68O\xdeD\rjm\xfe\xaa\x9b\xabF/\x99>\xa2\x9b\x05\x9b\xa5):\xa7\xe4\xcc\t\xb9U\xf9=\x06N\x9d\xbf\xb8qj\xce\x88\xf9\x97\x96\xfb\xa6O\x1a\x19g\xd0)\xaa\xc1b\xb4d\x17T\r\x1fR2(y`\xd9\x82\xc5\x0b\xcar\xf8\xc2\x99\x17\xd5\x0eL\xf0\xa4\'f\xb8q\xb86\xa6\xf7\xf4v\x1fZ\x923t\xf2\x88\x019\xff\xc3\xde\x97\x80\xc7qU\xe9\xd6\xd2U\xd5{U\xf5R\xbd\xef\xadn\xed-\xf5"\xa9%Yn\xed\x8bey\xb7%y\x95\xac\xc5\xb2\xdb\xf2"\xd9\xc6IH\x98l\x90\x90}\x80y\x81|\xf3=\xf8\x86!\x0f\xde#ql\x07A\x86]a\x0b\x0e\x84\x97\x81\xf0 @\x1e<\x96\x991C`\x12b\x12K\xef\xdc[U\xad\x96l\x07\'\xc3\xcc\xc7\xccH\xc7.\xdd\xbau\xef\xad\xb3\xfc\xf7\x9cs\xabn\xab[\xb6\x1e\xdb\xb0\xe9\x96\xedU\xbc+`5\x88N\xab\xc5k\xd5y#>_M[I\xdd@s2\xb5f\xcb1\xe45y@\xff\xf7\x00\xfda\xe2]\xc8\xca\x9fr\xe6P\xc4\x12\x91\xde\xcfA\x89\xb8\xee\xa9\x80\xdc\x8b\xb8\xf8\x85\xf3pMd-(\x84\xfb\x14\xb4\'\xc9D\xc5\xcbX\xbdOW\x08\xf3H\xc7O\xb0>\x0b\x8e\xdb>\x15\xdf\xc9\xa5\xa0]\x00wH\r&\xd8\xb5~\x0f\xe7$\xef\xd3\xdaB.\x14\xa3\xa1\xa4\xe4,\xf4\xed8c\xc1\xb1\xfa\xf5\xbf.`zT+z\xadVy\x95\x00\xb3\\\x009\x7f\xa6\x89\x11Q\xa2\x948\x86$=\xeft\xc4\x8d1\xd3\x1cE\xe6t\x8eX\x10\xea\r1\xfd\x1c\xd5\x94\x13\x88X\x89\xaf<\xfe\x9a\x11\xf2\xf1q\xcb\x01\xe6\x80\x9c\xd7\'PX%]\t\xe7\xf3/\x81\xc1-Y\xb7\xf0\xa2\\@k1\x01z\x18\xe3\xaf\xe5\x97\xfa\xc89|\x02\xc5\xcfe\x89{<\xc4-O\xdc58q\xa7\xff\x0fG\x0b\xb1P\xa8\xc4\xa6\xa5w,\xe46k\xf4\xd6\xa8\xd7\x171SZrJct\xc6\xfd\xae\x88\xd3b\xd0\xd2\xef\xa4\x1e#\'\x9b%H\xe2i\xd6\xa8\xbb\xf8\x8f:\xa3\x96f\xcc^;\xfd\xb4\xc1\xcc\xd1$,\xb9\x8c\xdaw-\xe8\xd1_C\xfa0\xc4\xc374A\x9c\xbb\xb7\xc8\xabQ+\x95E\xe99e\x83\x04\xd5y\xc9<\xe6\xb9\xc4L\xaa\x19\xb7\xbc\xa84\x9a\x9d\x97\xf2\xe61\xc6s)\x0f\x97\x96e\xd8\x91\xabg\xd8\xf4\x1b\xbdw\x7f\xed\xde\xd7m\xd1\xa8\x8d\x14\xef\xfe\xe2m\x1d\x8f\x97n{w\xfe\xc1\x07&\xee\x1c\xaa\xa4\x02\xf7|\xf3\xceV_\x88\xfe\x9b\x90\xaf\xf3\xf6\xcf\xdf\xbc\xf9\x9e\xc9\xc67~];\xfeW\x08y\x88?3\xf0WI\x0c\xaa\x1960f\xd3A\xe2l%t\xee\xdf\xa3\\\xf95\xd3X\xfc5vR\xcd\x92\x81\xcf\x0br\x86\x8c\xdce\xce\x1as\xff>\x8f\x93\xe2\xd7\xf2\xa61\x16\xf4\xcfN\x16\xd2\xe1\xb7\x92\x0b\x9b5\x9c\x81\xbd\xfc\x0b$\x03e\xe1\x0c\x9c\x06\xce\xb9\x85}\xe4$g@\xab!(?L~\x0c\xe6\x9f\xa6\xc3\xe2\x169Y\x1eH\n-\x16\x17\xaf]\xf8&\'\xb8\xad\xa2\x0br\xe1\x8fr\x82\x0bK\xb6\xf8\x07\xea7 Y\x84\xd8\x88%cD$\x99\xc5k0x\x08\xaf\x87\xb9$\x8a\x0e\xcd\xeb\xc11\xc7\x81\xe5\t\xae*\x16/2\x97\xf2\xd0&\xa8y=\x8f[-\x0b\x00\xec\x9b\xe5\xb5\x12\xf5\x1b\x9e_8M\x1ee\x8dH\x08#\xbb\xf0\x80\x16"\x81\x13"\x01\x98\xe7\x12\xcf\xd3?\x88\x06\x17\xcei\x05\x17d\xef\xc0\xfbV\xad,\xac\x96\xfeF\xc8\x17B\xbc\xe7\x17\x7fM\xffZ\x93$r\xc4Q\xc4\xfbY\xbf\x9fw\xa2=\xc9D)\xa4\xa0\r9}&\xf2\x8a\x8b\x01\xaa\xd1\xa3MY\x8d\x13\x90/Z\xce\xd4L)\x16B\xb6\xc1`\x9a\x87\xb9\x81\x92\xcd\x9c\xc1\x15y%\x8f;4\xa2\x1e\xe7\xf2\x8d\x135\xa8\xcf\x13y\xe8\xa4\xd8\n\xb9\xcfk\xa5\x98\x91%\' A\x8a\xc9rr\x16\xa1&\x99\xf4\xaf\x19N\xa7\xe1k\xfb\x0f\xf7o\xbf{$]\xbf\xff\xaeM\xd5#\xf1\x7fRmH\xee\x95\x82\x82\x18\xda\xb8u{\xd9-_\xbf\xa7w\xc3\x03_\xbf\xb1\xfd\xf8\xb6z\x9b\x9e\xbe\xc7\xea\x11\xb4\xbe\x12_\xf3\xc1\xf7\x0f\x8d~`2#\xd9I?\x98\x0f\x99\x94\xf3\x05\x16\xf6\xdb|\x9c\xc5m5\xf4\xdf\xf3\x95\x1bny\xf6\x81\r\xf6@\xc0\x1aPPK}\x1f\xfc\x88\x93H\xcbQ\xd1J\xd9\xce\x11\x9ci\x1c\x842\x9f\xd1L\xaa\xd9#J\x1cM\xe3\x1aT\xfbD^3\xb9\x948\xb2W\xc9\x1b\xa9\xef\x0b\xfcB\xc0\x16\x05\xe7\xe6t\x05!k<\x82<Xg\x14lB\x7f\x93\x95ea\xdf\xf8\x0b\x0e\x96Z\x18]\xcc8\xa0\xab\x818\x8888Wi\xaf\x8aCF\xbf\x98\xd3\x85M\t}UU8\xadGg"\x11\xce\x8cUI\x06\xda\x17\x1b\xf3\x1d\x10\x14?\x8623\x94\xdc\xbd\x94\xb4@*\x07\xaa\x07\xcc\x81\x17\xc3\xb0[\xd9\\\xcd\xe4V\xe6q\x8a\'{\xb3<N\xb23\xe3\x9c5\xe8p\x05-\x1c\xb5\xf0^M\xa4\xd4\xee\xb5\xe8\xe8\x85\x87)\xce\x12t\xb9\x02\x16.\xe6\xcc\x07*C\x90\xc4\x95i\xc8\xa4\xd1\x15*\xf3N\xb8\xa2\x0e\xd5n\xf4\xa97n7\x1aiV\xc7\xd27\xbdqW\xa1\xf6\xab\xe1 J\xe0.\xa7\xa9\xaf\xf9\xcb\xdd\x86`\x18\xfb9\xf0\xec\x07A\x1f>\xa2\x82\x18\xc0\xf3-\xc6>E\xd9\x08\x91\xf0S\xcd\xb0\xda\x12\xe3\xaf0\x8c\xb1\xe4U\xfb\x98\xf1@q\xf2\xa5\xce6&\x0e\x00e\x8c\xf6\x92W\xf3\xb8\xc9\x1fK\xb7$\x87\x9f\xe6\xd2\xb1x,\xa6z\xc0\x83\xe9\xfd\xf7\x8f\xbf\x0f\xa7\xa70\xd1bN\xd2\x14\xe9\x086\xee\xcc\x85\xcf\xb6\xb5\xd8\x13\xd2C\x7f\xdd\xd4[\xeb\xa2\xfe\xdf\x96[w&\x16\x1e,\x16\x86\xe5\x8c\xa9\x81\xf1\xbe\x9eQ\x91a\x16\x0e\x07\xea\xd7\xa9\xf2<\x02\xf2\xa4`\x0e\x8e\xc9\x18\xd3S\xf6s\xb5B\x85\x98F\x1f\x9e\x885aw\xc2{+\xc4\x9f759\xb2\xaf"\x1f![\x17\xcb\x96\x85\xf9\x97|\xfe%\xb0\xedw\xb1K\xb7T4\x89?\xcfC\xcb`\xf6\xd5\xbc\xd2\x16\x99\x16\x0b\x99-\xb2m<^M_\x99\\bG\xc3\xf9i\x87C\x92\xe8"\xb7\xff\x88\xd6^\xe2\xf5\x84\xeczz;\x1f\xadiMO\xaa\xf2\x83\xa3q\xef\xbbcg\x8d/\xd3_\xeb\xa9*\t\tCz\xee\x9f\xec5\xebr\xef\xbf\xafe \xe9\xb2r`TZg6\xfc\xb6\xbc#\xe1^\xd8P\xd0\xc73!_\xack\xb25\xbd\xbd3)\x18B5\xb9\xd2_\xb9]\xd4\x8f"\xcd\x15\xae\x85O\xba\x12\xe8o\xdd\xf4.\xfe\x9az\x03|\xd3:\xe2vY/m\x94\xe5|,\x1dK\x9b}\xe8\xb3"\x84\xb9f\x8e4\xe5t\xd9\x96K\xbev\xa6b\x02\xa6\x81\xf8d\xd0Zc\xa5\xac0?Lg\x18\xf0R\x97\x9f\xdf\x8d\xf3AX%#\x0c`\xdf\x83\xb4t&\x8b\xfb\x9a\xf2\xd9\x8a\x96Ky\xdc\xdd\x8a\xfa\x9f\xcd[\x19\xd4\x19\x12>\xec\xae\xe6\xe5\x94o\xbe\xc8_\xb1\xd7\x9b\xedQo4M\xdc\xb7%\xb5\xb7?#p\x0cE\x81\xd75Tu\x8d4W\xf5\xd7\x07*\xba\x86w\x0fw\x97\xa7w\xdd\xd4S\xbe\xb9\xbd\xd6\x8c\xaf\xeb8]\xd9\x9a\xcd\xa9x\xae\xd2Y\xd9=\xbcg\xb8\xbb\x92\x8c\xf7\xcdn\xa8\xb4x\xbc\x82A\xb0\x0b6\x9fM\xe7\x8b\xf8\xa4\xb2\xa6X\xd9\x9aDIy\xaas\xa457\xd5W&H.\x1e2>\xc1\xea\x16\xb5n\x9f\xdb^\x92\xf2U\xb4T\xc7K\x93\x1d{\x90\x07\xf3\x02\xbeZ\x00_A\xa2\x11\xcf\x16B\x03p:+\xf1\x1a\x01|\xd5Y\xcf\x98\xfe\x80\x92\xb4\xcd\xbf\xfc4\xca\xd54\x1et\xe1\\\x1e_Y\xca\xd5\xd8k\xa7j-\xbcy\xe1%\x9d%\xe4r\x07 Q{I\r\xa2\xd4/\x91\xad\xe9\x1f\x94\x84\xde\xb8\xb5`\xf5\x9b\xb5"\xc4Q\x8f\xc8!\xe7\x06\xe8\xdf\x07\xab\x8eG\x98\xc3D\x8c\xc8\x12\x7f\x87\xd7\xc4\x81\xb5M\xa4\xc1\x93E\x0b\x87,Z\xcdf\xd1\xea!\x8bV[Y\xb4z\xc8>E^\x82\xa4&\xb1\xf8\x13\x94\x96&\x94t5\xa1\xa4\xab\tem\x92P\xd2\xd4\xc4\x1c\xa5\xcf\xe9\xad\xa1.C6\xee\xd1\x98\xcb\xd1f`g_z\x8e\xd4\x9c5\xafg\xfa\x91\xe40\x8b\xb0\x8f\\\xf6\x0c2\x99\xc5K^\xbd\xda\xd1\x89z\x9e\xcb;\xfb\xcc\xa8\xef\xb9<\xee\x8c\x94\x03\xd3j\x85\xc7\xcc\xc8\xfeRF\x85\xe4(x~:\x16[\x8at-T=\xfd\x08\'zm\xe8\xf9v\xf7\xc3;\xf7\xdf\xb3\xa349\xfa\xe0\xde\r\xb7\xe58[\x00\x82\x82E\xf7\xb7\xed\xef\xecX;X\xef\xb2\xa7\xb7\xb7\x86\xd6\xe4\xba\xe2.\xad\x1c\xe4\xb5\xa7\xd6o_\x7f\xdb\x99\xd1\xd9\xa7n\xef\xeel\xa7\x0c\xeaC\xaa\xcb\x9d[v4\x8f\xde\x94\xeb\xb8u|\x8d\xa5\xbc\xbd\x16l\xff0d&\x1f\xa3\xbf\x01\xbe\xe5N\x1c;\x8ef\xc8\x18\xafd\xf2K\x8f\x9a\x16\x7f\x83\xd7y\xbc\x92\xea\xf3s\xe4k9\x0b\x91\xb3\xc2r\x00-\xe7\x88 Z\x18\xb8az\x94\xe4t\x15}1\xde\x1e\xec\xb5#\xd5\xc1\xcc@\xa9\xe4\xbc\xba\xb6\xc2:;S\x81\x1b\xea\xf3K-\x9dr\xd3\x951\x9f+r=\x8a\x8e\xec8Ef\xa9\x8fQ\xacN\xabu\xf8\xa2vWM\xa61\xa2\xb5\xc8O\x02X\x8b\xd7!\xf9\x04\xae\xa4\xb51\xeb3\x85\xa2>\xa3\x06r\xe0Q\xc9/\xeat:\xad\xad\xba\xbf\xfe\xf2\xe3Z\x83V\xa3\x81\x03,\x13\x0c:p<\x06\xedmu\x1dq\x9e\xd6\xea\xf5:\xb3\x07\x10\xd7C=M\xdd\xc0\x8a\xb02\xc8\x10\xc3H+O\xe8\\\x99\xa7\xc8A\x00U\x15yWN\x10\x03\x87]:\xba\xf4q\xe9X\xf2C\xc6YzF\xc1H\x16c\x04\x02)\x0e\x9eV\xdcH*}</\x1d3&?\x94\xc7\r\x15<d1\x1eH\xe5]\xcbu\xc1\xa1\xae\x9e\xba\xc1\x15\x12%\x9eM\x8c4\xb7\xed\xcc\xba\x83\xad{\xd7\xd6n.\xe5x\xb7\xcd\xe6\x16\xd8\xf7\x94v\x97F\xd3\x01\xde\xe8O\xc6\xa2\xbd\xd5\xd4\xcf\x8c&\r\x04\xcb\xd6Dmb\xc3Ts\xd7\xcc\x86\x8aX\x8c\xacf\xb4\x1a\x9a\xd6h\x99\x85-\xd5\xd5\xc1t{$\xda\x95\tUdp\x96G=C>\xc7x\x88*\xa2\x0bgya7\x01V\xde\x913\xba\xf5\xf3\xf1ca\xde\xee?j\x9fY\xb2\xe8\xcb\xf3\xf22\xc7\x14\xd7\xcf\xe7\x97\xae_\x87\x1d\xebP. [QC>Gi8Fk\xe0\xed"\xef\rF$F\x90\x85qE"\x0egy,b5\x87$NCj\xbe#:\xc1\x01\xb2\x8c\xc1Y\xea[x\x14\xc4\xd2 \xd9(\xa7\x11~\xba\x03\xa5\x0e\xadF\xcb\x9a\x1d\x04E\xea\x17_%\x7f\xc8\xec!\xecD\x19Q\x82\xd7tL\x89g\xbd\xd0\x05\x8c\xbf\xf8,\xf0\xfb$S\x92\xc3\xe7\xc0\xa8\xfb\xc5g\x8b\xd8\xcc\xd01E\xed\xd6\x95o\xb7>\xcb\xa1\xb7K^\x0b\'\x92Z{\xc4\xeb\x89\xd8\xb5f\x9d\xab4\x10(s\xc2\xa2\xa9,\x10(u\xe9\xc8\x13\xb0\xcc\xd2\xa0\x15;\xfd\x19\xa3\xc5\xc8\xb0F\xd1\xf8z6T\xe1\x81\x0c\xbf"\x14\xaar\x19\x0c\xae*\xe4\xcd..^$\x1f\xd3\xec\xc5\x1c6\xc8k0\x89\x1a\x03\xd7k\xa7\xb2O\x1a\x84r\xe0\x17\x82\xd2\x8b\xcf\n\xf3\xea\n\xecIT\x99\xf3\xa0`\xe3F\xf5EL\xc7\xe9\xf4\xb5\x98~?\xc7{\xec\x92G`I\x91\x85\x85\xa3\'\x0cQV\'E}\xde\x98C\x07\xab[\xaf/*\xe9\xc8\x0cz(F\xc3\x81Z4\nz\x861\xf0\xc67\x82\xbe\xb8\xd3`p\xc6}\xbeR\x97^\xef*\x05\x9e\xdfKOP\x1fdN\x14k\xd5\x13\xeb\x16\xbaA\xab\x17\x92X\xab\x9e\x1c>GZ\xbd\x90\\\xa6U\x85\x1fnE\x8dd\xa7nc\x05\x87\xc5\xe2\xe4Y\x87\xde\x16r@\x9e\xa0#\x17\xde\xbd\xac\xae&F\xdf\xa9\xaa\x95\xfc\x96ZZ\xa8]^\'\x08\x08\xbf\xa3\xb0v\xbcK\x93"Z\x88Y9\x13\x90\xa8\xa9\'S%@Dv\x8e\xba\xfd\x9c!\x18\xccz\xe6\xc8lN\xd7 J4[\xbdK\xc8\xce\x91\x8dg\xd8\xdd\x90\x9e\'QN{\x11\x96\'\xa0re5\tR\x9d\x83\x1e\xd5\xb8\x8b!\xaf\xf6aQ\xa7\'\xf2\xd0\x0b"?\xeeV\x01\xdd\x96\xd6\x95\xb2\x01\xeaKZ\xe8LZ\x86\xbeb\x146\xa5\xe6M\x1c\x0e\x88w1z^w9k\x92\xccZ\x8d\x8e7\x91\xf6\xee\xe1\x94\xd5Y\xbb.\xd52\xd6Wc`\xc1C\xc1\xc2]l\xdaq\xbcm\xdb\xed;\x13\xee\x8e\x99\xc1\x7f\xa4j\xb5\xbc\x9e\xe9\xb1x,:N\xf4;\xedA\x97U\xf7\x0f\xcd\xfb6v\x86\xe2\xb9jw0\x1ed\x05\xafd\x96\x04\x93\x10\r;\xe3\xfdG\xba\xd2\xa3S\'\xbb>\xaf\xb3\xe2\xb71\x9b\x16\x16\xe8\xd3\xa0\x9fa\xe2~Y?)\xaa7g\xda\xb8\xadtc[\xe9\xc6\x8d\xa5m4\xca\x98\xa6>E\x98\xadk\xack\x9c\rs\xa43\xa7_\xb7\xadz1\x1cf\xd6\xed\x82|\xc7u\x86\x19\x91\x9f\x9cA>)\xc8\x0f\xcfp\xbe\xe4\x80BB\xb4d\xb1\xce\x9e\xc4\xbd\xd7\xe1\xee\xa6\xfc\xb6p\xf5b\x1e\x0f\x802&\x17dL#\xca#2H3\xe5\x87dKaqe\xd2\x84\x1e/(x.\xd4\\M\x9fv?M\x9fn:\xfe\xf1#\x9d3;\x1a\x8c\x1cC#\xd7`Ho>\xd2\xd9\xb6\xbf#\\\xb9\xe5t\xff\rF^\xa7a\xb4\xbc\xe1h\xdbTo\xdc\x9d\xd9\x98i\x1a\xedK\xeaY\x1d\xa7\xa14Z{\xd3\xb6\xc3k\x87\xdf3\\\x15l\xd9\xd9\xb8vzK\xe2\xe6M\xef=\xd0,\x05\x02\x06\x93\xdd/Y]<\x1b\x8a\x05\xc3-\xdbSu\x83k\xc3\xb0\xb0\xb7[]\x02\x1bY;TW\xd6[\x17\x88\x94E\x18\xc1#\xf1\x92h\xb6\x95D\x1c\xd5[Ot\xad\x99\xda\xdc`\xa4\x98\xe4\xe6i\xd0\xfaq@\xe5#\xa0\xf5FbTE\xe5\xa1\'\x13\x11 "\x83\xfe\x82\x93AJ\xa0\xd7\x7f\xd9\xb3\xe5\xbb\x84L\x11\x1eQ0Y\x0eFhX\x8eZ\x9e\xcfCS6\xb3\x0c\x86(\xa0\\\x1d\x83E/\xef[4+ \xf8\x08\xa3\x03\x08f\xccv\x9e\xa3\xf5\xbc\x91t\xf6\r\xd7\n#\xfb\xd7\xec_\x9741\x06\x1d\xa3\x97\xd6\x0e\xcf\xac\x1d\xbac\xa8\xd2\xd51;|\x91J\x83\x06W\xc2o\xed\xc8\xc6\xae\xe8\xfa\xe1`i\x08=[s\x87\xa4h\xc4U\xba.\xdfV?~P\x81\x1eIL\x02\xf2\x1e\x02\x1d\x0c\xaa\xc8\xab\xa5\xfar\xa6\x81-\xb1\x81\\l` \x96\xa3\xcd\x9e9\xea  \xafIl\x12\xa5:\x8c\xbc\xde-\x95\x8b\xc1 \xd3\xbbK\xban\xe4\xe1\xde\xbdu2\xf2\xb6\x04+\x17\xf3x\x00\xf4p\xf6\x8f#\xaf\xeem\x02\xef\xa1\x96\xd9\x8f\x1fj=6\xd8\xc8kY\xdal\xd2e\xb6\x1c\xe9h\x1b\xeb\x08Wl9\xbd\xfeF\xd0\x17\xc7\x1a\xcc\xbac\x18v\xe9M\x99\xc6\x91\xfe\xa4\x1e\xa5\xb84\xc3\x99\x1b\xb7\xce\xb4\x0f\xbfg\'\xc0n\xb8\xa9\xfd\xc8\xc6\xaa\xdb\x07\x1f\x98\xac\xb7\xfb\xfd\xbc\xd9\xe6\xb3G=\x81X \xdc\xb2-U7\xb4\x04\xbapn\xa8\xbe\xac\xa7.\x10\x06\xd0\xf1\x1eItX\x8c\xe6h\xd4\xb3\x04:.\xbd\xe9\x10\x9a\xeb\xbb\x00u\x15\xb0*j&\x8e\xa8\xa8\x1bY\xf2\x85\xb7\xaa\xbe0\xfddJb\xab\'\x90#\xcc\x9c\xc1\x8f\xd4\x92\xca\x83\xf1\xab;\xc2tN\x97\x97{ 7\x98yBy\xb6\x96T\x1ey_\xe9\x06\xeb\xdf\xdc\rJ\xc0\xa4\xd6\xa4\xbd\xfc\x1e\xb3\xdd\xc42z\x8b\xe9;\x1d\x83)\x9b\xa3\xaa\xbd:\xb5um\x85\x8e\x85\xd8\x04\xf3S\xac\x1b\x18\xc9l\x7f\xe7\xe62w\xeb\xec\xce\x8f\x91?\xb4\x88]\xa2\xdb\xa2cA\x03v\xbf\xcbaz\xae\xe3\xc8p\x7f(\xdcT\xe9\xf4\x84\xdd(_6\xd9D\x93\xe0\xf7\xd9+\xd7\x8de\xd3c3w\xed\xf8H\x1ct2\x04\xab\x88\x12\x8c\xc2\xdbT\x146\\\x81\xc2\\NRax\t \xf8S\x84\xa0\t\xe9\x123\xf5\xc7\xf1\x97s)\x00\xbc\x84\xc0\xf7S\x0c\xbe\tF\xba\xa4\xac\x12W \x8f\xfcW#\xaf\xa41\xff\xc1\x91\xfa=\xbd\xb5<x1\xa3\xc1P\xde\xb6{M\xe3P\xb3?\xd81\xd5u\x1c\xf2\x13\x06\xbd\xcc\xcf\xa7w\xac\r[\xcb\xdb\x12\xa9\xc1\xce*\x8e\x05\x8c\x82B\x85zP\xe8\xc0\xa9Me\xfeL\x7fU\xf3\xbe\xb6(Y\xdesrs\x95\xe0p\xf3F\xab\x07\x96\xec.\xbf\xcb\x9dh+-\xef\xacv\xb1f\x97\xcd\xe223\xee\x9a\xce\xb2`}\x99\xd3\x1dv3f\x97\x95\xb7\x0b&\xde\xef\xb5E\xdaG[\x92\xdb\xda\xab\xf44S\xde6\xb4\xb8H\x8c\x03\xf2\xd2\x80<\x96\xfe\xb6\x8e\x80\xf3Q\xd0z5h\x9d\xa5\x9f\xd3\x15\xa24\x13\x82(}\xa3\x8a\xcc\x9dK\xc8|\xd7\xa7\x0cbCV\x06g5\x06\xe7\x16\x04\xceR\xf9\x15l\x01\x9c+}\xe3\xa7\xe4N\x08\xa2\xd5\nD\xb7`\x88\x96\xaa/h\x0b\x10\xbd\x9a\xa3\xb4^G\xb0F\x9e\xb2A\r\xd6\x7f\x18\x9c\xaa\x17\xbd\xf5\x9b\xd2\x8d\xfbz\x12z\x1d\xc4\x1cX\x8b\x88\x8d\xdb\xa7[\xf6\xdc\xbb\xbbZ\xea\xbe\xfd\xf0\x05*\x81\x9ce\x1fz\xc3\xc2\t~\xc9\xe6w8L\xa4~\xd7C\xef\x18\xad\xa8X\xdf\x18\x0e\xc7\xc1_\xfa\xecf\x87h\x16J\xa2\xee\xcc\xae\x1b:[nz\xe0\x93\xc7\xbe\xab\xb3 \x8f\xb9\t\xb4v\x1a\xb4T\xe41\xd3W`u\xb8\xc8c\x1a\xb0\xc7\xfc\x1d\xc2\x1cz\xcbe(\xbc\xe5\xba>\x8fi\x90=\xe6\xef0h\xf1\xeb,C\xd1\xeb\xac?-nOg\x8f}\xe2X\xeb\xd1\x1dYQ\xcb\xd0&\xb3!\xbdq\xbaK\r\xd4\xa7U\x8fy\xa4\x10\xa8G\xfaR&\x05\xb7\xd6\xcc\x8e#\xad;\xefZ\n\xd4\xe4\xc1MwO6\xd9\xfcA\xb3\xc9\xe6\x97"\xe02W\xc4i\x9e\x0b\xe7\x06\xebQ\x9c\x0e\x97\x85XX(\x99\x1c\x16\xde\x12\x8az\x12[g\xbb\xd7Lm\xca\x1a No-\xc4i\x8c\xcbo\xe0\'\x0c\xa6\xb2:\xb2\xc2O\x96\xf9\xc8\x98\x9f\xcc\xa1\x17\x8a\x0e\x9eZ\xbf/GJ\xe8\xc5\xae\x84\xdf\xe9J\xe8\x9d\xae4GU\x15\x00,?h\xc8~\x86\xba\x850,~\x01\xad\xa0\rs\x8b?\xc9\x19x(\\7\xb0\xd1J\xf9Ba\xd3\x0f\xac\x97+\x88\xdd\xe4\xee\xdd\xbb\xff\xeda\xbe"!x}\xc7T\xd6\xe2\xcdlL\xaf\x19\xe9\xad5\xa2\xc73\x14\xa3u6\r\x1dj\x92a~\xe7\x91\x0bT\xea\xcda^\x1a\xd6Z\xfcv^\x12\xcc\xf6h\xc4\x89a~\xe3\xfd\x8f\x1d\xc70G\x99\x01\xe0\xfc!\x84s\xb2[\xc6\xf90(\xda\x8b\x14=L\xd6jA\x95\xb5\xe8\x99N-\xd6v-\xd2v\xed\x1c\x95\xc9\xe9\xd1D\x18pZ\xc9\xf5`\x98_\xe6b\xd0$\x16\x84Canh\xf1\xbbd\x1e\xbfP\x86\x9e\x1e\xd4\xd33\xb7\xf8\xdaY\xfc\x9b\xaa:Oh\r\xf8=\xf2/\xcf\xc1\xbd\x083\xd8\x08=\x182+\x0f\x88\xcc\xc8\xdcV0\x9e\xb9)\x07\xa7M94H\xa2\x89D\xef\x95\xd1u\xf9\xfd2\xaa|\x0b\xd3\xaf\x02m\xf7C\xc6\xadx\xbe\xf0\x9a\x19\xcfF(\xe0\t\xa9lk\xab\xf0\xe4\x8c|\x13i\xa0\xdf\xea\xe4\xdc\xbbg\xf7\x9fd~\xbe\xcd\x8c\x86b\xb5\xd6\xc6mGr\xc5\x19\ry|\xe8\xfe\x89z\xbb/`\xc6)\x8d7X\x02\xf3s[\xb2~0W4?\x87\xeaKQ\x1e]\x8aS\x1a\x1e\x1c\xa2\x15\x90\x02)\x8d2?\xb9\xcc\xc6C\x10G\xd6Q\xcfQ\x93\xcc/(N\xc3\xc1L\xfd\x10\xd4\xb4R\xf3\xd4\x10\xae\xd1\xa2\x1a@\xd3\xba\xc5:j\x92\xea\'\xea\x88>\x19M6\xf2_\xceW\x85\xaaBDj\x8ej\xcb\xe9u\x8e\x17JO\x1b\xd3_\xa6o\x90Sl5\x86\xe0\xe8m*u\xbc\x90\x87\xcbt\xfa\xcbyh \xa7\xd5\xa0P\x06\xbf\x9d)\xceg\xae\x99RK\xd4\xa4\xd1\xbcPn\x10\r\x0c\xad5\xe9\x1fN\xae\t\xebsM%MUA\x88\x1a,\xcdZ\xca\x9bzJ\xd7\xeem\t\x98\xaaw\xf4\x1e$\x07\x8c\xfc\xfd>\xbf\xc6(\x89\x82d\x15\r\x1f\xa8\x19\xc8\xd59\x13\xcd6\xc9\xc6\xf2\x0eA\xf2X\\vs\xb0a\xa0*\xd2\xb9\xed@\xc7\xb8\x1f\xcd\x97\xd6\xc52j\x08$\x1cPs\x98*\xf2;9SWo\xb4\xab!\xda\xd5\x15m\xa0\xcd\xb0B\xf8]\xceM\x98\xfb\xcas\x92\xbb\xa7\xfc\xb1o\xfb\x7f\xe2\xa7\xfc~\xa6\xe6\x8b\xad\xa7\xa5/17\x156\x17^\xac\xc8^%\x87\xf1\xf4\xf9\xcb\x1f\xcb\x13~\xc1OI4tk\xad\xf9b\xbe\xf54#})\x0f]\x8bw\x15f\xaf\x96=\xd7\xad\x84Z]A[\xb1%\x9c\xb1\x08f\xd4P\xc5\x86\x99\xaeD\x7f}\x10\xf9v\xbd\x91\r&\xdb\xcb\xfa7;k{jz\xb4z\xf4\x0cS\xcfun\x19l^\x13][\x1bb\r:\x8af\x8c\x95M=\xb1\x96\xddk|\x03\xebK;\xd3^{\xc3`s\xd0(\x8a\x9c\x81wX$\xaf\xc5&6\xd7\xfb\x12A\x81\x85\x15\xb0\xd9fd\xdb\x9a\xaa\xeb\xac\x0e\xab\xd3g\xb2\x98tF\x87\xcd\xecMwW\xf4\x8c\t\x14\xed\xabEo\x0e\x9a\t\x82rS\x1f\x00\xb4lU\xd1\xf2\xfc\x93\x08-U\x08.\x9a\x9c\xa0\x13\x1c\xa4\xe3\xb1\xd2[L\x814\x99~\x8c~\x17\xa8\xee\x18\xa0\xe6\xd8\xb2\xd4\x03\xe1\xe6\xb1<4\xa2\xd3\x8f\xe5\xa1M\x017%o\x057n\x93~a\xbf\x11\x16\xf7\x14k0\xdcQ\x92\xf4\x9b\xea\xaa\xc3\x99\xb8\x1b\xb0\xcd\xd0\x8c9\x9ei\x8d4li\xf0\x88e\xbd\xf5{I\x9f\xd9\x94\xf1\xba\x007\x90\x85Yx\xdd\r\x91tu\xa5+\x9e\x14\xacHt\xd1f\x13l\x16\xa3\'\xd9Q\x16Z\xdb\xbe\xbej#\xc6M\xd5\xe2\xcb\x94\x00\xb2n"\x1eTqs6g\xeaY\x1f\xedi\x8c\xf6\xf4D\x1bi#\xe0\xe6\xefsA\xc2\x98\xc9\x94\t5d\xcd\xc7\xdb\x03ed\xd9\xa3\x01\x9e\xb7\x05\x02L\xfb-\x01\x1bi\xfb\x04s+R\x01\xf29\xf0O\xb8x\x0c\xfe\xe1\x95\xc2\x95\x990\x8c\xd2^\xf3\xf1|\xa0\xec\xd1\xbc:\x02c\xfbD\x1e\x06P\x9c\x16\xf2[\xc5+\x06\xbcA\xe6\x9a\x1e\xabn\xb9\xf2\x96\xfc\x15\xe0H(\xed\x99h\t\xafM\x97\xf0\xacN\xa7\xf5\x967\x97Gj\x03\xbc%\xdeR\xd9\x86\xf6z\xe1G\xa0\xdd}\xe9\xac/]\xe6c5\x006\x92f\xf4\xd1\xba\xf6X\xc3\xe6z\x8f5\x92\xf2\x97\xae)\x93>]\xd5\x97\xf6\xe9\xcc\xa2\xe0r{,<\xe4d\xae\x90\xe8\x88\xbaM\x8c\xd1f\xe6\xad\x06M\xaa*\x92\x10\xac\xbc\xc6h5\x1bx\xa3Vo\x15M\xae\x8a5%\xbed\x99O\xabq\x97fP\xa6\xdbL\xbd\x9br3>\xf0G\x12 \xeb\xddPSE\xbd\x83\x12p\x8d\x03\xd5\x10\x021A\x0ckvj\x06\x08\x8e\xe0\t\x07\x11 \xe2D\x82\xa8\'\xd6\x12\xdd\xc4\x06b\x07\xb1\x97\x98$\x8e\x10\xa7\x88[\xc8~\x9c\x83Lo<\x90\xdf\x9aox\xc7M\xcd7\x95\x1e\x9d\xad\x9c\r\xee\x1b\x8b\x8ei{\xfa\x8d\xfdD\xaeC\xd3!\xd4\xa4m\xe9\xfcM\xb3c\xfd\x1d\xe9tG\xff\xd8\xecMy\xce;\xb8\xcb\xe9\xed;~r\xe0d\xdb\r7w\xdd\x9c<8]7\xed\x1e\xde\xe3\xdfc\xd9\xbc]\xdaN5\xb6\xb0-\xfa\xf2js\xf5\xc9\x9b\xa7\xf7lo\xa9\xaen\xd9\xbeg\xfa\xe6\x93\\lb4\x1c#\x12\x17\x12\x17DlI\xf4#\xa6\x84\x0b\xc97?\x90\xa8\x87\xe5\xad\xf4@\xe8hx{\xfc\xe5b\x843\xe1~\xab,\xe2\x90\x18\tg\xd2\xa9d\\\xf9mU~;\x94\xdf\xeaun\xc5\xf9\xca\xdf+\xafs\xd2\xf2\xf3\x92\x15\xe3\xab\xf7\xa3\x9f\xafI\xa7k\xde\x87\x0e\xbfO\xd5\xa6j\xa3\xa8\xb4P\x9f\x84\x9f\xff\x95\xaa\xadMQ\x9b\xd1\xf1\xb2\x1bUP\xb7\x15\xda^\xfedM:\x99\x8c\x92\xb5\xe9t-\xf9Utqa\x17:\xfe\x1e\xb5~\x1f*\xd1\x1f\x80C\r\x9c-|/\x95\xaa\xfd1\x9c\x90\x7f\x05\x85\xedh\xb4\x1b\xe1@~6\x99\xc8\\\xee\x81\xd2\xfbkj\xd2TPi\xb4\xc0A\xe1\x97\xa8\xdb\xf7\xd35\xe9j(\x00V\xbd\xd4\x05\xeay\xe6W\x10\xc5\xcf\x12\x08\xcd\xf7A\xbc}\x99\xf9\x19\x9c\x7f\xaap>\x88\xcf\xe7\xd0\x07_\xe0\xfc\x02\xd5\xca\xfc\x8c\xf0\xa8\xfbYLs\xe4P\xceh\xd3\x116f\xded\x125\xf3\xce9\xea\x8e3\xe2L\xd1\xeb\xf5y\xe1\xf2<\xdePdb\xe6\xf3\xd0\xc6\xa9\x99\xcf\xab\xadV\xeeg\xb1\xa3\'\xc4P\x88\x88\xe8\x1dI\xac\xb0\x97\xa5U/.\xbc\xbc(\x98L\xc2\xa2?\x1e\xf3\xbb\xdd\xe4\x98\xa8g\x1e\xf5\x05~"\x85|\xe1\x85\x17\xccV\xab\x99\xfar\xc0\xe6\x03\x9e\x87!Cx\x91\xf9\r\xf0\xfc\x99\x82\x0c\xad\xcc?\xc0\xf9\xe7\x95\xf3o\xd1?f~\t\xe7_P\xce\x9f\xa1n\xc62>\x8de\xec\xa2\x9e\xa6\x1a\x99\x7f&:\x89i\xd9k6\x93\x83\xe7\xa3\xb5\xd1Z\x93{\x8e|w\xceD\x98\xf8\x14\x9frd\xcf4\xbb\x99\xb29\xea\xce\xb3\x8e3\xcc\xec\xb2\xcd\x85 \xb4\xbc\x03\xe6"\x0e\x15\xb8yY\xf6L^\xe9p\x9eq\x9c\xc9C\x97e\xbb\x06\x0bI\\,^M#\xfc\xa0\xcd\x05Jl\xc55\xf2CR\x87\x04\xfaA\x8d\xd0;"\x16\xbd"\x82fTcy\xefxS\xf3n\xaf\xd9\xa2\xa3\x1d\x06\xb7\xd1\x10\x88\xd7\xf8\x9az\x1c\xb1\x94\'\xda\xd3\x14-i\x1b\xae\xf3d\xaa\xa3\x06\xbdV2:\x0c\xb6\x96\xaa\xba\x8c#\x9e\xf4F\xfb\x1aK\xe8\xb3\xd9\xa15\x01\x8f\xa05\x0b\x92\xd8.r\x9c\xc0\xeb\x9b\xd2\xee\xb8\xdfm\x14c\x99uu\xe9\x8du^-o\xd5\xeb%[\x87\x991\xf821w,\xe0\x82ku}\xa0;\r\xe8n3\xd6\xddW\t\xf4\x96C\xc1\x13\x11&J\x88\x0e\xbc\x8b0:\x1f\xf1\xa1\xbdp`\xf0\xb3\x96\x19fF\xd9Bg\xc9b\xdd\xe8\x8d\xd1\xf9\xfc\x8a\x06N\xb5\x05F\xc5\xb5\xb7\xcbQ\x0e\x8eNQ\xcf2\xa4\xc1\xeftz\x05V\xd3\xb6\xf0\xf3fJ+z\x9d\xce\x80\x81dH=\xa5\x13=v\xc9/\xea\xa9\xad\x13\xcfR\xaf\x9a\x05\x1dE2\x1c{\xf6\x0c\xa3e)Z+\x9a\xa8\x179\x9d\x86\xa24z\xf6\x83\x0b\xdf\x02\xee\x15\xf4\xe3}rm\xca>9\xf2n\xb4O\x8e\x1c:\xabs\xcd\x9b\x10\x8f\xeey\xf6\xb8\xb2S\xee\xe2\xf3H\x88s&\x17\xe0\x1a.\x9dg\xdd\xf3y\xb8x\xd5\xbdr\xa9\xe5{\xe5\xa8\x97\xd3\x13\x7f9\xfe\xa8\xd9\xe31\x9f\x9b\xb8\x7f_\xed}\x9e\xc6\xc1\x8e\x9d;[w4\xf95\x93\x13\x0f\x8f\'\xadN\xea\xb3Nkf\xec\xde]\xf5\xfb{J/\xbf\x14\xee<\x80\xe7\x1f\x9e\x8fD%1\xa1\xee\x94\x83\xf9\'\xe8\xf0>\xb9y\xe5c%2\x9fq\x95O\x9c\xf6\x91\x89\x17\x0b\x13Q\x8c\x01\x9fK\x1f#Q\x99\x8f/1\xbf\xf4\x19\x92+>Q#o6\xb3\xab\xb18\x12\xb1\xe3mK\x834\xabc\x16N\xf1 \x0fy\x07\xa3c\xd0\xa3Nf\xe1\xfb\x7f\x80#.\xfe\x81\xac\x04\xd5\xd3\xb4\x81\x97\xcc\x9c,\x1b\x07\xe9./\xf1\xdcW\xb4F\xa7Yp\x9a\xd9\x9fs\x82\x03dT\xe6/\xc4\xc7<~#\x89>F\x81\xfe\xf8\x1b\xdawF\xde\x9d3\xa6\x19F\xef\x9c\x0f\x87\x13\xfa\xf9,\x9a~\xb6\xf9\xc4la[\xa0\x05e&\x17\x9f\x9f\xbf\xa8l:\xe3\xa1q\xd89\x9f\x87\xe6Y\xfd|\x1eu8\x9f\xb0\xcd\xe7\x13\xb3K\xdb\x03-\xd9D\xcd\xd5\xf7\x9ce"o\xf6\xb1\x06\xeaE\x90L\xa3\rg7\xd67\xee\xca\x85KZw\xd6\xf9\x9b\xdd\xffS\xaf\xa7\x01`\xa4\x81\xe5\xcd\xac)\xda\xd0\xb4\xc6\xbf\xeb\x81\xfd\x99\xec\xe4\x83\x83U\x1bZ\xca\x05\x96\xd9j\xb0\x185\x0e\xaf\xa3\xbco\xb2\xa9}\xb2\'j6\xcf\x85\xc3\xbc\xcd\x80\x9f\x85.|]tZ$^\x9b\x9dzh\xe7\x9e\xffv\xa8Y\x90\\\xd1\x12\xc5\xf2\xe0\xc5\x08\xb7\xbc\xdb\xec\x0cG>E\x0eAn!\x81\xa9\xc9y\xd3qy\xb7\xd9\xc5\x0b 4z\xbav\xc7y\x13\t\x86=\xae\xee6#\x8bv\n\x16m:#\x1d\xa4\x1d\xdb\x05Y\xef>\xde\xa3\xe5=6\xabG`\x98\xef]\x9e\x01k\x88\x8a\xb5~\x00r\xd24\xac\xc1H\xd5{\x12M\xc4>\xccG\x95\x0b\xfd)\xbe\x08\xda\x048\xf8\x04\x11\xc9 (U;\x0c\xb4\xbf\x14\x95\xfc3\xa22\xe7\xd5\xedf\x17\x93\xc2\xc5$f2s\xb5\x96\xc5;\xcd\n\xaf\x0eEZ\xf9\xc0\x00\x1d)\xbc\xef,l4\xb3\xa6\xac\xea\x07\x06\xe8\x1fs\x82\xcbn\xf5\x98\xb9_\x91:\x80\x96 \x99u\xe4\x0fI\x92\x13\x9cP\xcbs~k\x97#\xe8\x12\xd8\xaf\xd3\xff\x9b\xb3\xd8]\x96>\xbd\xd5\xa8\xa3~\n\xc2\xc1\x0f\xc7P\xb9\xcb\x7fG\xb3\x0cEkX\r\x94\xbf\\\xa8\xff\xae\xdb\x0eC\x88\x97\x7fK\x99,n\x9ee\x8c\xa2\t{\x0b\x1c7\xf0\xa7\x05\xb6*\x9f\x16@6\x11\t\x1f\xc0TO\x88\xd1y\xb4\xdb\x7f\xde\x8eb\x9d\xb18"^T#"\x0b\xde\x0fo\xf1\x9f\xcf\xab\xad\xde|\xcfYj\xf9\x16\x7f\xea\xe6\x92\xee\xd1\xce\xadZ\xb3\xdbns\xf3\x9c[\xfc\xb8\xa7\xa6\xb5;\xe1\xba\xcfWQ%\r\xf4\xc7Ra\x8b\xe6r\xcb\xfe\xce\xf8\xc2?\x17\x84y\xc1e\xd3\x98c\r}\x99\x92\x94\x93[x\xc3^\x92\x06\xab*~\x1c\xfc\xb6\xb2\x13\x88\x05\xbfr\xde)\xb2\x96y\xdf\x12\xfbh\'\xd0e\x84\xb0\xf3\xac\xcf2\x9f\xf7\x15\xb1\x9c\xbc\n\xbfE\x1b6\xc1Cl\x86 \xc1\\`D\x040\x91\xf9\x16Z\xe2\xc0<\xd1P%\xc8\x1b3\x7f\xcb;x\xee\xf2\x89\x02\x97\xef\x05\xef\xc0\x8bN@\xa2\xe0\\\xf6M\xafF\xc4\x9f\x07\x1f\x86\x86jP\xbc.!\xb3\xd4:\xcd)\xc8\xa9\x03g\x05:l\x9d\xa3\x9e9\x9b\x0f\xd3UOQ\xcf\x10y\x82\xa6\xbeC\xac\xad@\x93\xbc\xa6\x96T\xb6\\\xa6\xeb\x96-\xcd\x96>\xe0\xaa.\xcd\xa8u&\xf3\x82K\xb4\x9am\x7f\x93\xe9*\x13\xfb\xd6E\xd6\xd4Ftv\xce\xac+m\xec.m\xdd\xb76`K\rw\xddK\xbe\xd3C\xe6\x9d\x1e{\xc0\x1f\xb1|4\xb3\xbd\xbb\xc9\x93]gw\xd9\xc1w\x1b9\xbb\x9d\x0fg\xfb+\xe2\x03\xc3\x87\xda\xef\x02.cd\x88\xea\xd5\x1c\'z\x89\xe6\'j\x9b+1\x93\x1da7\xfc\xceY\xf3|8\x10N\x84\xf7\x86\x8f\x84\x99p\x98i\xe6\x19\x9b\xcc<C=\x07\xcc\'\xd1\xba\t\xd6\xdeH\xc9\x85\x1d\x00\xb1\x18J\x12\x94\xe5w\x0c\x87\x99t\xdd\x8a\xc7<1U2I}\xccC\xf5Vm9\xd9W\xd6\xddP\xc2\xe9\x19\x8b6\x9c\xea\xaa\xda3z\xf0\xc4\x16\x83(\x186\x96w\xa6\xbcB8\x13\x8b\xb5\xa5\xa2Z\x83\x0e\xa4-k\xec){\xc7\r\xae\xca\xb5%\xb5\x1b\xea|\x94\xb3ag.j\xb2\xda8\xad\xcd[euZ7\xb6v\x0fX\xddN\xab\x14\xaf\x0f\xbb\xab\xc26\xc9%Y\xdc\x0e\t\xb2\x0c\x9byr$\xde\x9e\x89j)M(\xd5\x89\xac\xb4\x81\xf8,\xe5\xa0\x0f\x13\xd5D\xfc\x1cO9B\x16Y\xc2\x10\xf5\xc2\x13:\xaaR>\xa1\xa8\xbf\'\xf0B:\x85\xac\x05\x89\xf5\xf5\x19\xcb!-\x1c2\xf3\x06\xf1\xae\xcal\xd8\xbc\xa6\xc5\x9f*\xf5iE\xd6\xc0\x85k\x9aBu\x1b3.\xa1\xa2\xaf\xf1$\xb9F\xfaE\xb9\xe0v{\xf9\xbb\xaa\xba\x9bk\xa5\xc4\x1a\xd1.\x96\x896\x1dk\x11\x8d\x9e\x9a\\4\x94\xeb\x1d\xcc\x1e\xc7\x9c~\x82\x92\xe8CD;\x91z"\xe7\x0e\x83\x85\x9e\xcc\xbb\xddL\xa2\xb1\xfcs\x98\xcbF\xea\x05\x82!l\xd43O\xe4yf\x8e\xfa.\xb16U\x81Y\xc6{(\xff\xa8\x81\xea\xaen\x1f\x96\xb3K\x12%\x95t\x8e\xb6\x84\x9b\x12~\x98+<\xe7\xadh,\x19\xd848\xd2\xa1\xe3M\xfa\xd6\xaeA\x93\xb72\x18\xa8\xaf\x80\x8bZ\x10/R\xd3\x1c\x1a\x9bX\xbfv\xf3n\xf2T\xf5\xba:\x9f\x81\x17\x19Nt\x94\x08V\xa1\xad\xae\xa9\x95\x97lB{V\x8ay\x05\x8b\xdd\xc2K\x16\xab\x96\xb5\x8a\x86\x1d\x1b\xda\x06\xcd\x94v\x10\xcd\xa9\xc5S\x9a\xdf\x12.\xc2H\x88g\x8c\xd4S\xd4W@6#\xf5\x05\x02\xe5.\xf6L(i\x97\xb7Xk~\xca\xebt\xb1\x1d\xfb\xc6\xd3w}\xc4%\xbai>\xe8\x11\tr\xf1Q\xe6^\x8d\xc0\xfc\x960\x10\xe63\xac\x01\x94t&\xcf\x12\xc8m\x91r\x06\x1fB\x8b \xfa_\xcc\xf0\xf3\xfa\xb7\xbd^\xe6\xb7v\xaf\xcfQ\x0b\xbef\xf13\xdc\xfdT\r\xf7\nA\x13\xda3\xe0F\x13\xa9\x9aZ:d\x0fuQ\'/\xdf\xcd\xbd2\x01s\xfc\xf32\x91\xf9\xeb\xa4_\xc9D\xfd\xc5U\xe82\xfd\xa5\xb7B\x1ao\x11\xfd\xe8z\x889XL\xec\xee"z\xee_C\\\xdfu\xd2\x07e\xd2rW\xa1q\xed+o\x85tuE\xf4\xb9\xeb!}\x0c\xd3Y\x99\x0c\xdb\x8b\xe8\xa3\xff\x9ed\xdc\xfa_\x80~\xf4\xe7G\xa6\xc17\xa1\xa7Vi\x95\xfes\x90\xd9\xb8\x8c&\xfe\x8ch\xeeOE|\x8f@_Aw\x88-W\xd0\xd7,7^A\xb7Y\xde\xbb\x92\xac~\xeb\xf7V\x92\xed!\xfb\xc7\xae\xa0\xc7\xed\x9f\xbe6I\xe5\xd2\xb7\xafM\x8e.\xc7k+\xc9I:\xf5\xab\xf4\x9f\x89\\;\xfe(\xed\xc54\xe9:\xe2\xfa\xa2\xeb\xeb\x05z\xce\xf5}L/!r\x9fr\xdf\xb2J\xab\xb4J\xab\xb4J\xab\xf4_\x9c~$\x93\'\xe1\xf9\xb0\xe7\xc3\xde\xca\x02\x1d\xf5\xbe\xa2\x92o\'\xd0\'Vi\x95Vi\x95Vi\x95Vi\x95\xfe\xc3\xd3\xa7Wi\x95Vi\x95Vi\x95Vi\x95V\xe9OG~\xa3\xff\x9e\xb7H/\x05\xb6]A\xb3\x98\x1e\\\xa5UZ\xa5UZ\xa5UZ\xa5UZ\xa5UZ\xa5UZ\xa5UZ\xa5\xb7@\x1fY\xa5?w\xc2\x9fo\xac\xa2\xc2p\xa4Q\x91\x12p\r\x8d\xff*\x81\x19\x9f\xd1\xf8S\xf6f\xcd\xe3J\x99&\xa2\x9a\xcf)eMQ\x1b\x86pj\xfe\xafRf\x8b\xea9\xe2\xa4\xe6\x0fJYK\x9437+e\x1d\x11\xe4nU\xcaz\xea\xbf\x17\xda\x1b\x88\xed\xdcG\x94\xb2\x91(\xe7^S\xca&3\xabU\xf94\x13y\xa9T\xfd\x8c&\xa9\x95\xde\xa7\x94I\x82s<\xa2\x94)\x82s\xfe\x93R\xa6\t\xa7\xf3wJYS\xd4\x86!\x8c.\x83Rf\x8b\xea9\xa2\xc9\xe5P\xcaZ\xc2.}H)\xeb\x08\xc1\xb5Y)\xeb\xc9\x8d\x85\xf6\x06\xa2\xc25\xaa\x94\x8d\x84\xddu\xafR6q\xb4\xeb#J\xd9L\xd4\x05?\n\x9c\x90\x1a\x1d0ga\x8e*eY\xcfrY\xd6\xb3\\\x96\xf5,\x975Emd=\xcbe\xb6\xa8^\xd6\xb3\\\x96\xf5,\x97e=\xcbeY\xcfrY\xd6\xb3\\\x96\xf5,\x97Mfg\xf0\x07JY\xd6\xf3\xff \x82D\x92\xa8!j\x89\x06(\xad\xc7\xdf\xd2|\x9c8B\xcc\xc0\xff\tb\x16\xea\xda\xf1\xb7[\xcb\xdfq=\x025SP\x9a&\xaa\xe1J+\x91\x07\n\x12\x9b\xa1n\x928\x00\xd7f\xf0\xd98\xfc\x1e\x87\xd6\'\xe18\x06-MD\x0f\x94F\xa1f\x9c8\x05-6\xc0h\xe30\xc6V\xe24.\x05\x89~\x18\xf94\x8c{\x02\xdf1\x0f\xa5I\xccI\x10\xfe\x1f\xc1\xdf\x0f}\xbcp\x8f`\x81\xe7\x1a"\x05\xa5X\xe1\xac\x9e\xa8\xc4\xf7\x1f\x81\x11\x8eB\xdb \xdcw\x04\xee\x83\xc6\xd8O\x1cR\xda\xf6\xc1\xd9\x01\xa8EWO\x00\x7f3\x05y\xb6\xe2o\xa9\x9e\xc1\x1c\\\x8b\x9f\t\xac\x87 \xd1\x06\xe7\xa3p\x05\xd5\x8e`-,\x97Q\x1e\xe7\x88"i\x10\xdf\xe5\x04\\\xdd\x8f\xe5U\xb5{\n\xfa\x1e\xc75\'\xa0\xd5\x18\xd6Z\x10\xea\x0f\xe0\xba\xf5D/\xf0\x84\xb43\x85\xfbMc\xbd6\xe1\xfe\xe3\xb8\xc58q\x18\xee\x89\xb4<\x86\x8fA\x85#\xb5m\x10\xd7\xcf`\x9bN\x01/\xaa\xf5\x96\xe4@\xd7g\x81\x8b)\xe89\x03Zh\xc7\xd2LaI\xa6\nr\x8c\xc0\xff\xc3\xd0C\xe6P\x96g\x04\xdf#\xa8\xd8z\nFD\xa3\x8e@;4\xd6i8;\x05\xa5Yl\x07\xf4\xfd\xe7\xa3P\xcec\x9e\x8ec] y\xd1\xf7\xabO*\x9a\x92G\x9d\xc52\xc9\xf7\x9c\xc6\x12\xed\xc7\x9cN\xe3\xbb\xcc`;\xf5b\xabL@\xcd\x08\xfe~\xef\xe3X\xc6 \xfe-\xdbb\n\xcb$\xebb\x06\xa3b\x06F\x1dQ\xf0\x8a,vT\xa9W\xefr\x18\xc6\xc9c\xfd\x1cU\xb8\x9c\x86\x9a\xc3\xf8\xae\xf2\x983XSK\x1c\xa0;\x1e\xc5\xb2\xa8\xdf\xff.\xebV\xe6=\x8fQ\x83\x90p@A.\xe2\n}\xd79\xfa\x0e\xf9Y|6\x8dm\xad\xe2Z\xd6\x99|\x17\xd9\x8e\xd3\x8a\\G\xb0nGq\xcb%\x8e\x8b%BZ{\x07\xee\'K}\x08\xce\xab\xf1\xdc-\xb6f\x1c\x8fv\x18\x8fp\x1a\xeb\xe1\x842K\x8b\xf5\xad\xa2oZA2\x92_\xb6\xcbq\x8c\x06\x15\xa3\xe3\xd8\xd6\x08\xb9G\x0b\xd2\xc8<N*mf\xe0\xec\x06e\xf4Y\x90B\xb6\xd0\xc9\x82\x95F0F\xd0\x0c8\xbcL.\xd5\xf3\xec\x07NF\xf0\xfd\xf7+\xf7\xaf\xc6\xdee\x12\xdb\n]\xb9\xd2_5^!\xf5v\x059*\xf2\xeb`\x94$\xd0\xb5\x91>\x8b\xef9\x86\x91\x88\xeer\xa8`\x83\xa5\x99y\xa5\x9f\x9cTp}\xb4\xd0\x1a!W\xb6\xf84\xb4\x1f\xc7\xd8\xf9\xf7\xf1\xb7\xfaU\x8f\xfb\x1f\xc6\xe3\xf6\x03\'\xfb\x89R<\xcb\xca\x94\xebA\xa2\x1b\xa3\xe2\x08\xe6l\x16\xe8( ;\x01t\nS5\xf6\xb2\xcb\x91S\xad\xe0-\x01\xe5\xd3\x18?\x93\x18A\xc8.\xa7\xa1\x16\xcd\xa1\t\xcc\x0b\xc2\xcd\xf2Q\xf3\x98\x07\xc4\xc1R\x0bu\xbc\xabat\x06\xe3\xfc(\x96]\xd6\x82\xda\x0fYu\x08k^\xf64\xa7\xb1\xa6e\xcd\xcc\x16\xac\xad\xb6V\xfd\xc2~\xc5w\xa3Y^\x89u\x80\xda\x1dUPQ\xec\xa7\x8fb\xbdN+\xfeA\x1ee\\9\x1fQ|\xf28\xf6(SXB\x99\xbbQ\xcc\x87j\xe5\x95\x16\x9bUz\xc8\xf89~E\xcdDA\x86\xca\xeb\xf2\x04rT\x18\xc3:\x9dU\xa2\x8f<?\xe5\xfbV\x16\xee\xb3R\x02\xd9\x8b\x9e\xc2z\xda\x8f\xe7\xd3\xd5tvJ\x91t\n\xcf\xb4<\x9eS\xf2\xcc\xbfR\xf7\xa8\x8f\x1cYJ\xa1}\xd92\x04_}t\x99\x87\xb7\xab\xdb\xe2\xf9!G\xf7\xa0\x12\x9fg\xb1\xe5\xf6/\x8b\x93+%X\x8a\x8a+\xf9j*\xc2\x00\x92D\x96E\xce\x16T_y\xbc\x90y\x8c\xe1\xd8;\x8d\xfd\xc8\xc85%\x95\xb17\xb2\x0cU\xb2?8\xa2\x1ce\xa9\xe4\xf2\t<_d\xff4\x86\xe3\xd8\x94\xe2[\xe4qP\xcb<\xf6\xfe\xd7\xc6\xa8\xec\xc5\xa7\x15\xcb,\x8d\xae\xce\x90\xa9\xa2\xac\xe2\x00\xf6wS\x8a\x9e\x91W7a\x7f9\xae\xc8\xa0f\x18\xaa\x96\x97\xa3\xba\x12[f\x04\x97\xc7\x085\xbfZ\xe9\xe7V\xce\x84\xd2\x15~a\x1c\xfb\xe9S8\xa3\x98\xc2\xd6GV\x1d\x81:\xa4\xa1I\xec\x8f\xe4k\te\xcc\xbd+|g\x992{\x97\xbc\xc5R6\xa0r\xf3V\xa2\xd3uF\x83\xa0w\xc5\x18\xfd\xea\x18A_\x01\xcd\x07\xa1N\xb6\x93\x8a\x1a9;\xc9+Qd\t\xddo\x16\xe1TT^;\xca!\xcbm,\xcc\x9c\x99\xa2\\D\xb6\xb7\x8c\x82q\xe5^\xb2\xd7\x9eV\xec^\x89e>\xaeD\x1f5\xaf\x90\xf3\xa2I\xc5\xce*\x8ee\\\x1dU\xf2\x1d\xf9\x0eGp\xde=\x82\xe5T\x912B,E\xf9\x95\xfe\xec\xdf\xc0\x16\x05\r\x8d`\xd9\x91\xde\xa6\x14_?\xa6\xcc\xd5\xfdJ\xae=\x8dy-\x8e\x99S8\x1b\x9f\xc1\xd8Tx\xbc\xb6m\xa1\xbcey\x9c\x07k\x97\x15\xe9h\xach\x85P<\x1f\xae{<biU\xa3\xb6\xbe\xbaw\xab\\\xe1\xddT\xdd\xaf\xec\x9d\xc7\xab\x82\xa9\x15r\xab|-\xe5`K\xb3f)\x12\xa96\xac$\xd4\xd5\x19Z\x85\xa9\xe7\xe3E\x089\x8a\xd7_y\x8c\xb7\x03E\x11V\xe6z\x14\xf32\xaeD\xaa\x13\x05[\x16\xfb\x12\xd9\x86\t\xc5\xe23x\x96\xe4\x0b<\xa8\xf3z9\x96\xae_\xab\xc5\x11^\x96\xb28\xd2,\xc7\xf4\x92&Na=\x1e~\x9bvT\xa3\xc1\t\xbc\xba\x9453^\xc4\xc1\x18>\xa2{.\xe9\xe5 \xb4\xd8_\x14;f\xdf\xc4\x1f\xcb\x9e\x7f\x0cK\xa0F\xbc\xc6e^|\x04F<\x82=\xce\xd5\xb3\xeei\x1c#\xd4(S\xbc>S\xe3\xc4\xd5|\xca\xf2^3\xd8W\xc8\xb6\x1aU\xe4\xbez\xcc\x1d\xb9\x86E\x8f\x17\xa4\x9f\xc1(\x9d\xc6\xa3\xcb\xb3\xe8\xca\x95\xef\xdbE\x80\x1a\xdfz\x88N|u\x03\xd1\x05g; Zn\xc65\xbdP\x17\x04/\xba\x19\xael\x87\xb3\x0e\xa8\xed\x80\x9a8\xb4\xd8\xa2\\\x8fcK\xed\xc0q\xa8\x07\xdam\xc31N\x1ec3\x1c\x07\xe0|\x08\xfb\xb8."\x88\xcf\xd1\xd9:h?\x00c\xa1\xbe\x9d\xc4\xe0\xffo\xe7:\xa0\x9a\xc8\xbe~&\t!\x05\x04\x05\x15\x912\x88\n*\x84\tEA\x05\t\x10 R\r b%$\x01"\x90\xc4$H\xb1\x85\x88\x88\xbd\x8b\xe8\xaa`w-\x88\xae\xabk\x05\xb1`\xc7\xae\xeb*\xd8+\x8a\x1d\x15\xf1\xbb3\tE\xd7\xdd\xf5\x7f\xce\xb7\xe7\xff}\xe78\x03d\xde{\xf7\xfd\xee\xbd\xbfw\xdf}3y\t\x84\x0e\x1e\xa0E\x11\x92\x02\x02;\x0cjC\xe1\x95\xa7\x97\xc3{\xf8CM\x0c\x94\xf1\xeb "\x0b\xea\xf4\x85C/\xdd3\x04_\xbf&\xea,\x8d\x86z\xb4\xd9\xc3/\xad\xe2\x13\x1a\x9b,\x0b\x83\x92\x00\xf0\x83\xf5\xad\\\xc0\xe6\x13x\xb8\xfd\xb8\xfe@\xe2:\xbc\xd9\xce@\xbd\xa5\\\x82#\x1c\x19\xc7\xf4\x07\x8bB\x89\x12^\x1b\x03\xaf\x91 \x17E\xe8\xe7\x12>\xeb\xac\r\'|\x08\x84v\x9d/<\xc2\x02\\3[\xef\xabN\x0e\xe7g\xb0\xbe\x05\x1f#\xdc\xbeP8[\xbc\xe2\x12\x1c\x04\x13\xd6\xb4\xf0\xe7\x0f\xaf\x91`9\x8e\x1f\x04\xad\xd1\xc4\n\x11\x01=\x03\x08O\xa3\x08\xf6xz\xcepoC\x89R\x8bW\xba\x91\xf2\'\xbc\xc1Y\xc59\x08\x80\xeb0\xf8\rj\xe6N@\xfc\xd5\xd9"h\x85\xf6%w\xb1D{\x8b\x94\xce?\xae\xfe\xaf?\xc1\\\x04Q\xd2\x8d\x86?Q\x8a&\xc6\nou\xd2\x8f\xa5\x80\xf0\xe3k\xad\xb1D$\xf2\x08).\xe1qTs\x84\x04\x12\xd1\xab\xb3\xbe):u:"ZY\xa2\xd3\x87\x8fmk[\x9a\xa2\x1a\xfd\x9b9\xa2Cij\x8f\xd1\x8f\xf4\x9fy\xc1Y\xe7\x12\x9c\xe0vE5k\xfe+d|n\xfeo=\x85\xb6<_\xba\x10\xf9\x07\x7f\xc7P\xf7\xce\x1b\x9b\xb8?P\x9027\xa2\xae\x18\xc7\x13\r\x93\x8a\x94r\x95<Q\x8d\xfa\xcb\x95\n\xb9R\xa8\x96\xcael\x94\x9b\x9a\x8a\n\xa4I\xc9j\x15*\x90\xa8$\xca\xb1\x121\xdb8X\x92\xa0\x94d\xa0\x11\n\x89,:K!AC\x85Y\xf2t5\x9a*O\x92\x8aP\x91\\\x91\xa5\xc4{\xa082\xe6\x86v\xc7_\xfa8\xa1\x02a\xaa"\x19\r\x16\xcaDrQ\n\xd4\x0e\x94\'\xcb\xd0\xe0t\xb1\n\xd7\x13\x9d,U\xa1\xa9\xadq\x12\xe5J\xd4O\x9a\x90*\x15\tSQ\xbdF\x90\x91\x83RT%OW\x8a$(nn\x86P)A\xd3eb\x89\x12U\'K\xd00~4\x1a*\x15Id*I?T%\x91\xa0\x92\xb4\x04\x89X,\x11\xa3\xa9\xbaZT,Q\x89\x94R\x05\xee\x1e\xa1C,Q\x0b\xa5\xa9*\xb6\xbf0U\x9a\xa0\x94\xe2:\x84h\x9a\x1c\x00A\x8fP\xa6\x02\x14\xa54\x11M\x14\xa6IS\xb3\xd0\x0c\xa9:\x19U\xa5\'\xa8S%\xa8R\x0ez\xa5\xb2$0\nD\xd5\x924\xe8)\x13\x03\x01J\x99D\xa9b\xa3|5\x9a(\x11\xaa\xd3\x95\x12\x15\xaa\x94\x80\x17R5\xe8\x10\xa9\x9cPU\x9a\x10x\x15\t\x15p\x8dwIKOUK\x15\x00)KO\x93(AR%Q\x13\x00*T\xa1\x94\xc3h\xe0\xd6\x02zj\xaa<\x03M\x06rQi\x9aB(R\xa3R\x19\xaa\xc6\xb9\x06\xcb\xa0\x0b\xf8(\x03]\xf2D4A\x9aD\x00\xeb\x14\xa9%\x99j\xe8,M\x91\xb0Q\xbd\x9b\x0e*4M(\xcbBE\xe90\xa4:\xbbq\xfad@\xb2R\x08\xbe(\xa5*\x9cQ\x890\rMW\xe0j\x001\tjT\xd2l\x10W\xcb\xc1\xa1\xb1\xb8KB\x14\x06 M\xa7\x0b\x0f\x1eQ\xb2P\t\x86I\x94l\x81$)=U\xa8l\x8e\xab\xbeM\xaa\xfb\xe2\xf1\xe01\x18(\xc2\x87\xa07\xdb\xd5\xf5\x0b\xea\xd5J\xa1X\x92&T\xa6\xe0~\x10C\xda\x1c\x99I\xc0\xb8\x02\xaf\x16\xc9\xc1}\x99T\xa2b\x87\xa6\x8b\x1c\x85\xaa\x1e0\x8ah\x90R.W\'\xab\xd5\x8a\xbe..\x19\x19\x19\xec\xb4\xa6~l\x10wQg)\xe4IJ\xa1"9\xcbE\xa4N\x94\xcb\xd4*\xbdhj\xbaH\xa8"*p\xb9\x16e\xaat\x85"U\n\x81\x83\xb7\xb1\xd18y:0\x96\x85\xa6C\x08\xa9\xf1`\xc5\xabq"D0\xb4j\x89\x13*\x96\xaa\x14\x10\xc0\xba\x01U(\xa5\xd0*\x02\x11\t\xbc\na\x18%\xca4\xa9Z\rp\tY\x84WM\xe1\x08TA\xdc\xc8\x95M\x17\x89\xb8\x06\xa7?\xfb\x0eq N\x17\xa9\x9d\xf0p\x1c\x0b}\x9d\xf0>M\n`|2\x92\xa5\xa2\xe4V\x96e\x80R\xa9L\x94\x9a\x0e\xb1\xdfb\xbd\\\x06\x91\xe2(\xed\xa1\x9b\x16\xad\xc4\x01\xe1\xef\xac\xd5\xcd"\x88u\x18w\x95Z)\x15\xe9\x02\xb2I\x01\x11\x87MX\xfd\x08\x06\x1c\xa5\xa0\x05\xe6\x04\x9eJ\x94\xf8\xcc\x11\xcb3d\xa9r\xa1\xf8K\xf6\x84:\xaa \xb2\xc0\x1d\x18>\xfc"]\xad\x80, \x96\xe0n\xe22\xc9\x92T\xc5\x97\x8cB^\x82\xd8\xd5\x89\xe3\x03"%\xe6I\xb24A\xaa\xc6\xf3\x93q4\x98\x9c(\xc7g\x0bn\xb2\x9ej\'4A\xa8\x02[\xe5\xb2\xe6L\xd14\x08\x8e\xfaX\x90\xc8\xd8\x19\xd2\x14\xa9B"\x96\n\xd9re\x92\x0b^r\x01\xc9Q\xfa\x9c\xd2\x03\x86\x97\x08\x0bb\x0e\xe00\xdfN\x82\xdfJ^\xe7\xf5\x12\xa1\xb8\xc4\x05\x9c\xe6\xd1r\xf0\t\xa7\x06\xe6R*$6\x82\xee/\xd3$N\xe5\x17\x89\xd2\xd88\x12\x1f\x1c\x151y\xc0o\xa0@\x02\xbd \xb4\x81\x19\xb1\x13\x9a\xa8\x84\xa4\x87O\x11\x98\x88I\xe03\xce1p\x05#\n\xddQy\x02$;\x19N\x8a\x90H\xd4Mq\xf6\xfd^\xe0\x06\tU*\xb9H*\xc4\xe3C,\x17A\xca\x92\xa9\x85\xba|*M\x05f\x1cq\xc4/\xbcE\xa3\xf4\x99\xfaB\x0f\xc2"1\x91\ru\xe3\xf0M9"\xcf\xe2\xd5\xad\xc2\xcdI\x1fn\xb8\xf5M\xcd\xa9R\x88S\x9dn\x1cK\xa9[\xa9@\x031\x89p\x0f\x9d\xf0\\.M\xc4_%\x04!\x8atpH\x95LLX\x80NH\xc7\'\xaf\n\xaf\xd4G\tx\xe8\x02\x8e\xab$x\x8a\x96+\xa4\xba\x8c\xfa\x97\xa6\xea&<\xa8\xd4M\x1a=\xd3\x84\x11\x19\xc9\xf2\xb4\xbf\xf1\x11\x9f\x06\xe9J\x19\x18#!\x00\xc4r\xc8\xa1\x84-\xa3%"uS\x80\xb5\xc41\x04\xbfXJL\xbc\xbe\xba\x10\x17&\xc8\xc7JZ-\xb82\xb9\x1a\x9f2\xbad.\xd5Oc]\xa4\xe8\x9bT\xc9\xf8z\x90 \xf9b\xe6\n[9\xaa\xc4\xd5\xab\xd4\x10LR\x18\xa2\xe6\x95\xe7\xef\x08\xc0\xe7[0\x0f\x8d\x8a\x08\x8c\x8e\xe5\nx(?\n\x8d\x14D\x0c\xe6\x07\xf0\x02P\x07n\x14\x94\x1d\x9c\xd0X~tpDL4\n\x12\x02nxt\x1c\x1a\x11\x88r\xc3\xe3\xd0\x10~x\x80\x13\xca\x1b\x12)\xe0EE\xa1\x11\x02\x94\x1f\x16\x19\xca\xe7A\x1d?\xdc?4&\x80\x1f\x1e\x84\xfaA\xbf\xf0\x08X\xd7\xf90\x13\x014:\x02\xc5\x15\xea\xa1\xf8\xbc(\x1c,\x8c\'\xf0\x0f\x86"\xd7\x8f\x1f\xca\x8f\x8esB\x03\xf9\xd1\xe18f \x80r\xd1H\xae \x9a\xef\x1f\x13\xca\x15\xa0\x911\x82\xc8\x88(\x1e\xa8\x0f\x00\xd8p~x\xa0\x00\xb4\xf0\xc2x\xe1\xd1\xb0\xe4\x86C\x1d\xca\x1b\x0c\x054*\x98\x1b\x1aJ\xa8\xe2\xc6\x80\xf5\x02\xc2>\xff\x88\xc88\x01?(8\x1a\r\x8e\x08\r\xe0A\xa5\x1f\x0f,\xe3\xfa\x85\xf2t\xaa\xc0)\xffP.?\xcc\t\r\xe0\x86q\x83xD\xaf\x08@\x11\x10bz\xebb\x83yD\x15\xe8\xe3\xc2\x8f\x7f4?"\x1cw\xc3?"<Z\x00E\'\xf0R\x10\xdd\xdc5\x96\x1f\xc5sB\xb9\x02~\x14NH\xa0 \x02\xe0q:\xa1G\x04\x01\x02\xfd\xc2y:\x14\x9cj\xf4\x8b\x11\x01\x11\xbc\x1c\x13\xc5k\xb1%\x80\xc7\r\x05\xac(\xbcska\xb6\xf1\xf7,\xa1\xc4z\xe9"\x96$\n\xe1\xce\x85-T)2\x7fl\\\xfc\xd8\xb8\xf8\x0f\xb8\xfd\xb1q\xf1\xefm\\0\x89\xdf\x1f\x9b\x17\xff?7/t\xa3\xf7c\x03\xe3\xc7\x06\xc6\x8f\r\x8c\x1f\x1b\x18_g\xf3\x1f\x9b\x18_nb4\xb1\xf3c#\xe3\xc7F\xc6\x8f\x8d\x8c\xff{\x1b\x19\xcc\xa6\xef@\xc0\xf1\xd9\x82\x94G\xfa\xd6A\xd6\x7fk\x80\x848\xc2k<\xf1\xed\x83\xbf;\xa8T;##\x04d\x90\xfc\xef\x9576&\xe4\x1f~\xaf\xbc\x89\t.O\x0e\xfe^ySSB~\xc3\xf7\xca\xb7m\x8b\xcbS\xe8\xdf+of\x06\xf2T\xca{\x12\xfe-\n*!O\x85\xdfv\xc4_\x0b \xda\x8adI\xea\x0e\xa9\xcc\x81\xe4N\xf2\x81\x01\x08\x80\xa1\x89%\r#\x8d\x84\xb4\n\x8f\x98\x88%I\x8b\xcc$\xcd\xa1\x0c$-\xa5\x14\x90\xd6S\x9e\x91J(\xcfI\xfb(\xf5\xa4\xe3\x80z\x1eP\xae\x7f\x85_\xfd\x1d\xf8"\xc0W\x00\xfe\x04\xc0\x9f\x0e\xf8K\x00\x7f5\xe0\x97\x02\xfeo\x80\x7f\x14\xf0/\x00\xea\r@y\xf0%>r\xb4\x15~G\xc0\xef\x06\xf8nDb\xf6\x81@\n \x8d\x00|5\xe0k\x01\x7f.\xe0\xaf\x00\xfc-\x80\xff\x1b\xe0W\x02\xfe9\xc0\xaf\x06\xfcZ@}\x07x_\xf1C>\xd6\n\xbf\x13\xe0;\x02~\x1f\xc0\x0f\x04|<\x01\x8b\x01\x7f\x02\xe0\xcf\x84\xabe\x80\xff3\xe0\xef\x01\xfc\xa3\x80\x7f\x19\xf0\xab\x01\xff\x19\xe0\x7f\xa2\xbcG\x18\x80\xdf\xfeK|\xca\x1f\xad\xf0;\x03~/\xc0\xef\x07\xf8!\x80\x9f\x08\xf8c\x01\x7f\x1e\xe0\x17\x03~)\xe0\x97\x03\xfey\xc0\xaf\x06\xfc:\xc0\x7fOy\x8e0(\xf5H\'\xc0\xef\x06\xf8\x9c/\xf1\r\x8c[\xe1[\x03~_\xc0\x0f\x01\xfc\xe1\x80\x9f\x05\xf8\xd3\x01\x7f=\xe0\xef\x06\xfc\xe3\x80\xff;\xe0?\x05\xfc\x0f\x94\x02\xc4\x88\xf2\x0c\xe9\x00\xf8\x0e\x80\xef\t\xf8\x01\x80\x1f\x89\xcf3\xba!\xfc\x98\x9a::\x06\x8c\xd7j\xe94\x84N\xaf\xcb\xcf\x85#\xbf\x8eNE\xe8\xb4:\x8d\x06~4_\x144\x84\x98g\x80F\xf3Sn\x80\'\xdeb\xa0\xd1\x1dut:BgVT\xac\x85\xa3\xb0\x90n\x80\xf7\xc9\xcf\xcf\xc7;\x11\x00\xf1s5\xbe\xa8\xe9\xdcx\xba\x01\x89N\xabGu\x07.fH\xa7g\x82`~&\x8d\x82\xd0\xa85\x04\x18\x1dA\xe8T\x1d.IC\xa1\x80\x96\xa2\xa2"\xa2\xa7"\x9fN7E}\xeb\x9b\n\n:=_A\xa5\x90\xe8\xd4\x1a\xd4\xb7Fw\xe1\x8b\x96\xfd/\xbb\xc6@\xe8\xacrM\xb9f\x15\x9c\x0b\xe1\xcc\x87\x93\xb0\xfd\x9f]d\x18 \x0cp\xb1\xc9G*B3\xd8V\x86\xa32\x10\x84\xa1\xf7Q\xe7$C\xe7$\xa0\xb68\xa9+\x10N\x1aPHLj\x19\n^\xea\xaf\xe0d0H\x0c\x06\x9dd\x0eg\x178\xb9\xa4I$\x02\xda\x10a0\xeas\xb5\xf8\x91[OXP\xaf\xd1y\xd9R\xaao\x96\xec\xef\xa7\xd1\xcc\xd6j\xfd\xfa\xe3m4\xbdI \xc9D\x18Fep\x14\xfb\x16\xfb\xce\'\xce\x99p2h\x08\x83^\x0f\\\xea\x00p8E\xbeFC\xd8\xc80$1\x0c\x1bM\xf5\x07\x93\x860\xe9T*U=\x13\xa4g\xaa\r\xa9\x88\xa1\xdew\r\x13!3\r\x9a\x9d\xd7P\xa9\x08\x936\x17\x0e=\x1c\xb8\x8f\xfb\xdf\\\xd2\x11@%\xb1\x0cj\xa0\xbeN\x7f\x15oZ\xc3d\x90\x98@@\x0b\x05\x93\x80\x04B\x01\x1da2\x1b\xb49\xc4\xa1m Lih\xf2\xba\x81i\x800[H\xd0\t\xfbp\xe1jNN\x0e\xd7\x07\x176l\xa2\x01\x84Y\x08\xd3\xb8,\xbe,\x1e\x86\xa7h\x1e:\x0f\x9d\x0eg.\x9c\x04(\xce\x84\x8e\n\x02\x14\xa7"\xde\x147\x97iHb\xd2\x9b\xb90e\xd1\x10\x16N\xc6\xb7\xd8`!dV\x13\x1bz:X\x04\x1d\x84\x86\xcc\\*\x95\x88\x87\x86\xe6b&\xe0\xe4f\x1aRIF@\x83)\xc4D]\xd3u\xbc\xa9i\r\x8bIb1\x8d _\xe0\xa7\x1d\x9c\xbe\x9aI\x1a_\r\xfc\xf8\xb2\xe8\x08\x8bY\x9f\xa7\xe3E\x9bWOX\xd5\xa0i&\xa6\xa5\xdc\xa0\xb3\x8c\x81\xb0X\xb6\xa4x\x8d/\t\x0c#\xcd!*}5\xf1\x1a[\x12.\xda\xc2\x12t5FX&e\x16e\x16E\x8eE\x8es\x83\xe7\x06\xe3\x01?\x85>\x85\xae\xa5\xb3\x0c\x11\x96.\x1euL\x11Z2s\x01\t\xa3\xe3\x8e\xb0\x0cI\xacVT\x99\x1a\x19"F\x0c2\x1c}\x03\xf1\x10\x0e\xecKL/=Y\x1a#\x84l\xd4\x1c\xa5z\xba\x8c\x0cq\xba\x08=\x99\xb9\xd0\x91\x8a\xf3\xd5\xd8\\\x06\xc2\xc8d\x9c0\xc4\x98\xd6L\x98\xee\x1a\'\xcc\x88E2b\xb5!\xb5\x81\xd4\x8d\x9f\x1c\rG\x13_6\t\x86\x1c\x1fu#&bd\xd4H\xaa\x80\xe9_\xd6\xea(\xd7Th\x1aI\x84\xa5\x8dx\xb9\x81\xa8ml\xa9h\xd4\xc9\x11\xddm5\n\xdfxR\x19\x9c\xc7\xf4\xdd\xe3\xcb\x14e\xb6\x1a\\\x9a\xde\n\xb4\xd1\xa8\rbdZcUcU\xd7\xbf\xca\xe9j\xea\xd5\xd4\xca\xd0S\xa7\x0e\xcf<6\xb3\xc2\xa8\xc2\xc8\x88\x8e\x181\x1b\x8eVTT\x1c\xd5i#\x94\xf5O,+\xab\xc9\xb4jC\xa3\x9d\xca4\xa2\x93\x8c\x18\x9f-Z\x0ec:b\xcc\xa4\xc0\xd1/\xa9\x02?\x92\xfa\x11s\xeaj\x8d^\xa11\x99lLk\xd1O*+3\xa0!\xc6\xf4S\xf8A\xa8\x1b\x7f\x14:\xd3hF\x16X\xfc\xe7\xe6\nZ\x7f\x1a\xd4\x1e\x1d\x0f\x1c\xb6\xa1\xd5`\x18\x16_V\xd7t\x1d\x8fa5\xba;\x95\xa6\xfb\x18\xfc>\x8e,N\x95%\xe9\xaf\xbb\xa8t\xd7\x03\xf1k\xaeR\x98\xe0\x84r\x95i2\'\xd4?K\x99\xea\x84\x06)%)N\xc4\x0e\xa3\x13\x1a*T\xcb\xfeY\x82\xd0\x85\x10\xfa\xe0\xd7z\x05\xbc\x9a\xebT[/\xc6\xb4\xd6\xf3i\x8c\x9ey\xc1y\xef\x8c\x11Cr\x91\xd6z2TM"#\x08\x87\x851h\x06\xbd\xdaP\xc8\x96\x06$LHc\xf6\xa2!TD\xdb\x87\x8cP\x8b\xa2\xb0A\x98S\xab\x1a\xabU6\x1a+R\x7f\xe2\x8c \x9ed\xe5\xc4{K\xf8;\x1f>\xf8\x89\xd9\xb5\x02\xa3\x9a\xdb\xf0\x97\xbb\x9f\x1bZ>\xe8~Zz\xfb\xab\xf3b\xe3_\xdb\x93\x0e\x16i-\xa21-\xf5\x10\xa6\xa5\xfc\\D!#d\xb2\x99\x1b\x98X\xce\xa8\'s\xf7\x86\xfd\xfc\x07ap9f\xdcl-b\x00ve\x10fRb\xa843rL\x14\xc7\x0ck\x8b\x17\xe8f\xccX\xa1*Y*KR\xcbe\x1cS\xac\r^ihf(\x90\x88\xd3\xe421\xc7\x06\xb3\xc2k\x98f\xed\xbf\xf9Q\x1e\x8e\x1df\x8b\xb7S\xcc,Z\xda\xa3\xa5i\x12\xe7(\xb50M\x81F\xfas1\x9b\x8e\xc6\x9c\xde\x98\x17\xd6\x87\xd3\xc7\xc3\xd3\x03\x1b\nE\xcfVE,g\xfb\xbfb\x99\x11\xc6\xc4\xdbYf\x14n\x84?\xc7\x01\xeb\xa6+\xd9\xc8\xfc\xa5\n|\x87? \x8a\x87\xf2\xa2\xc2\xfbr\\y}\x9c\xdd\xb0\xde\xee\xce\xbd9\x1cWN7\xcc^\xe7\x90\xd57\x1d\x8a\xd2}N\x02\xd3"]Z\x13\x8c\x18\x90(Z\xc4\x84\x04\xf5L\xb2\x16n\x1a\xd7\xfb\xdb\xbe/\xe81\xfe\xb8\xdffO\x87\xbd\xda\xbc\x1c\xfe\xaf\x9d\x02\x12\x1eo\xe8\xd4K\xb3a\xf4\x8bs\r\x9e\xa7{\xf7\xba\x7fe\xbe\x17bp\xfa\xe1Q\xbf\x97V\r\x06}\xe6F\xaf\xa5Z\xbc-\xa5\x9d\xa4\x9c\xf3\xbd\x12\xb7\xe3\xce\xbc\xa1G\xa3\xef\xba\x8b6=N4\xd7L|)\xa2\x14T=lc\x1ba3\xc1\xfa\xc3\xc0\x19L\xf7G\xa7\xef09\xb3\xce\x98o\xcb\xd9\xb9\xc0\xbd\x90\xaf\xa9\x1c\xb4\xc5x\x9be\xc4\xbdI\xf7\x17\x8e\x0b\x8d\xed\xb0\xaaC\xc9\xe6\x0b\xbc\xb6\xa6\xd7\xcd\xf7\x0bo\x1a\xbf\x93\x9a\x8d\xb5c\x07W\xb9\x07\x07_\x1e\xf9a\xb6\xef\xfe\x07q)5!$\x8e\xd4\xe0\xa1\x83\xad\x83P6m\xe3l\x0b\xaf\xa2\x89g\xcf\xd8]\x8d\xdfx^l{\xe9\x97\xf8OE\xef\x9c\xc7\x1d;\xf9\xc0\xf2\xddi\x93\xe7/\x06W9\xf7\xf4\xccH\xecW\xe9V4h\xfdL-k\xf2\x90\xe8\xae\r\xe6/\xbb\x98\x1a\xcd\x90,q\xb6|c\xefy1n\xfd\xc5\xb8\xecs\xc8\xc3?l\xe7\x9c\xec\xdcv%\x99\x02\xd3h\xb5\x16a\x00#\x06\x985Pj\xdd\x86\xda\x81j~/\xa9w\xcc\xa8m\xef\x05G6\x87\\\x96y\x1c\xcc\xef\xbb\x85WB\x84\x90\xb5=\xd5\x02\xeb\xa01\xb7w\xaf\xbf&\x08T0k}?\x8e\xfd\xb8\xa3\xd7\xb6\n\x8f\x1d&X4.`K\r\xc3B0~QP\x11/\xcf_\xbf\x9d(R\xa6~\xb5\x9d\xa8H\x91\xe2\xb5.\xfaO\xb6\xa8\\\x9a\x87\x11\x1fEb\x10!(\xd9 \x82\r\xa1\xd1a^\x1a\x18\x18"\x085\x14\x1b\x88\x057\x951r^\xff\xbf\xdc\xaf$\x14H\x94\x7f\x83\xac\xc6\xccp{\xbbQ\xf1\x10\xd4CR\xe8_\xcdG\n\x1e%\xee\x9e\xac\x1e\xea\xe4\xf2\xe7\xa7\xcf<\xe3\xdc|\xa7~\xda\xf6\xd7R\xe5\xda\x9b\xf7\xe99\xa4\xf2\x12\x93>H\x82z\xf9\xf2\xacX\xf2k\xc7\x8c\xdd\xb9|{\x8f\xb87O\xea_o\xa8\xa1\x8c\x1d\xe9\x1b\xe2gS\x98\x1bw\xc3\xd2\x9b\xfbt\xd4mOt\xa1\xc1\x95e\x8f|\xd2J\xef\n_\x15\xde4\xd9\xd8\xa1\xb3W}y\xf6\xfe\xd9\x1b\x87\xd8T\xdaH\x19S\xfbyxf\xbd\xd9\x1c\xc5\xf5\x98\x12~%\xfe\xd6\xee\xb7\x16%\x9f?:N\xce\xfa\xbdO\xb6\xfd\x99\r\x95g\xf7\xd4\x8e\x18\xfc2d\xdf\xc0\xa3\x0f\x06x\x17Q\xfbZ\xd8\xdd\xba{zM!s\xca\xdb\x0f\xce+\\\xe6\xb1nT\x9b\xb5M\x7f\xdc\xd3\xeb\xc5\xd4\x9f\x02\xc6\\xE\xbb\x97\xb4+=x\xef\xe1\xd5q\x7flo|\x14u\xca\xea\xc0\xac\xb6!c\xfa\xaf\xec\xc4\xd8\xf9V:rK\x126a\xc4\xdeK\x92eS\xfa\xc6\x1f\xa6\xb2\'\xbb$?|\xe5il\x1b\x84\x86~\xd8\xdf\xde\xa2r\xea\x95\x0b\xe7\xc6\x14O\x94\x9a^<z\xe6$\xb3\x12\xd3\xd2\x10\xc8b\x8fZe\xb1\xc3\x8f\xa6\xd5g\xe7D>\xfaLd\xb1\xc3\xadYcA\x16\x9b\xf8\xaf\xe4\nG\xac\xbbn\xd2\xdb\xb6n\x17K\xd0(i\x12\xf1\xb9\x16\x18X\xfc\x03\x8d\x1c"\x99\xf5\xc1<!S`p\xba\xeb\x92YK\x11S\xff+\xf6\xe9\xdb)\x7f\xd1\xfe\x8f\xd9(\x7f\xfa\xee\xae\x15\x86s\x96j\xb2\xda7t\x8foP\xe6;}x\xbd\xba \x7fq\xe0\xae\xd5\'GMs\xe9\xeb\xc6\xb6\x99\x97\xf9a\xfcF[-\xb23\xfb\xa4\xe5>\xca\x89\xc0\'G\n\xdf}\xa4Z\xbf\x9c\xc2\xfc\xdcEV\xfc2\xc9\xfb\x88\x83\xc5=G\xdb7\xd4\x85\\\xd1\xd3;{\xda\xcf\xac5[\xeaq\xd3S\x11-\xef\xf7t\x0b\x8f\x81\xf1\xcb\x0f\xcc\xc1\n\x8dN\x8e=\xfeN\xb5\xa8C\xc6\xb9\x19{\x17\x1e\xa3OAkm6x\xbc\x18s\xa8FM\n\x99~\xfe\x8fyO.g6\xce\xfa\xb0%>\xdf{\xffo\xb6[\x13\n\x0e\x1e\xc9-\x9d\xbb\xf5rI\xaf\x0b\xd1\x1f=~?=f\xfe}\x9b\xcfO\xc7\xa4\x9c\x9cD\x1f\xab\xae1\x1d\x14|\xf1\x05\xa928t\xb5\xa1\xc7\xbd8\xe3O\xe3\x7f\xaa\xbc?\xf4\xce\x947\x97\x97\x9a\xd8\xce^w7\xb7c\xf9\xe5\x13+\xad\x91c\x9f\x82\xd7\x9b\xcdw+\xb0\x0bv\xad?\xd4u\x15i\xfb\x81\xa8\x13\x93e=\x86\xe5<\xf7\x94i^\xed}j\xc6z\xd2\x94\x8d4\xc0\xc8x]\xba\xe9\x86\xa7\x9b\xe6\x859\x94\x8e4\xcfTJ\xabtu\xf2rB\xee\xd9x\xaf\xc7\x9f\x93\x0e\r?_\xb9w\xd3\xae\n\xb3%\x98\x00onK\x85\\\xb4&\x08\xe3q\x8c1\x96ni\xa1\x86ED\n8\xee\x98+^40\xeb\xe5\xea\x86a\x1c\xd7^"O\xcc=\xc1C"tv\xf7Jpwvwu\xf3t\xf6t\xeb\xed\xea,\xf6\xf4\xe0$\n]]=\xdc\x13E_\xa4\xc0`\x99\xf8^\xa4\xc1\x05\xed\xcf\x1d\xfb\xf4\xe9\xb23m\xc3\x89t\xf2\xa2\xbfN\x81\xdf\xccPr\x85\x8a\xc8\x82\x10.\x10\xc7\x10\xc5\x10\xc0x\xfc\x8e\xc2\xff8c}\x9c1O"\x05\n[\xa5\xc0\x18\x0cnVZ\xa5@\xde?*h\xca\x82\x7f\xa3B\x8d\x19\xe1\x86\x9b!\xc8g*\x19#}5\x9d)Z2B\xa2u\xb0\xbd\x1e{(\xb2\xd2>b\xd5\xa0\xcc+\xb5\xf5\x9fN\xef\xbfT\xf6\xe2}\xe7\xc1\xb5Q\x95\xd2 \x83K\x87O>\xbd\xddP8l\xd1\xa8\xb6\x9e\x8ee\x06<\xb3\x9a\xa5Y\xf9\xfb\x127]\xdf\xfb\x84\x1cc\xbf\xcb\xdb>\x93\x9b\xb6\xb5\xfe\x05i\xe8\xc2\xc2\xe9V\xa7\x18\x8b\xaa\x96Z\x05`\x1b\xd7v8\xb6\'h\xd8\x9b^\xee3V\xce\x19\xd2\xa7"\xdc\xaa\xa4\xcb\t\xd3\xd3W\xb5\xa6\x1b=\xea\xb6v\xa9\x9c\xd3u]\xce\x8cj\x07\xab\xbb\x89\xd6\xd3|\xd8\x9fc)a\xe5\xb2\xc9E\xaeO~\xd9\xe1\x129x\x04\xad\xb4\xfd\xccJk\xd1.\x95\xd1\x9d\xcb\xd9\xddMz.\xe6\xadw\x9d\xec\xb3\xd8\'\x96\x9fa?\xad\xb1\xd4\xf4\xd8\xf4{\xf4\xf6\x83\x8e\xf4\x1a\xca\x19\xe65z\xf1\x865\xf9)\x8b\x1d\xe5/\x0eo}\xbc\x9f\xd7\xf1TBx\xce\xceh\xcb\xa0\xd9K\xd6\xa6\x95\xc9\x1c\x8e\xd6;\xd8V\xd6\xa2\x1bY\xa5/\xce\xb0\x96.\xbc=z\xb9trq\xef+ih\xe3\x94K\x9f+v\x17\xf4f4z\x9b\x97/1\xdfX\x96w\xea\xb9\xb6|SLW\x7f\x8b\x9d\xc1S2\xf3\xaa\xde\x9f_>\xa0\xd35\xf3i\x0ff\xadL\xee\x9a\x9f\xdco\xe31Mx\xf7\x07t\xbbP\xd1\xa7\x9f\x16\xb4\x0fs\xdb98>\xe2\xca\xc0\xdf<g\x7ff\xdf(\x1d\xb5\xc6?\xe5x\xe6\xd9\xd2\xbd)s&\xa7NU\xfe\xfcx\xed\xc7\x957,/{5\x88\x8f\xa7\xf9\xd0\xef\x8d\x9f\\\xbae\xdf\xea=\xe3\xce.\x1e\xbc&{\xc8\xc9vA\t\xe7\xed\x9e7\xf4?\xcca\xbds\xf1\x11\xaf\xed#\x8f\x8f\x1c\xb0+`nD\x11k\xc6\x81\x89C\xde\x1eK\x9a*\xbc\xbeb\xc9\xe1\xca\x99\'\xe5A\xb7\xca\xd8\x0bkK\xdfn\xc3\xd2\x9e\x8e\xe6ox\xb4xl\xe5~\xfa\xe1\xc6~o\xb6\xaa\xfa\xd0\xb6\x0f>\xdb\xe9\xe2\xde7\x0bOL\xb5z\xa9\x19\x8dD\xfc\xda9G\xb5\xe3\xc2\xb0.\x03\xfa\x0e\xb1\xa8\xce\x7f\x96t\x98\xbf\xde\xe5\x8fn3\xbcGV=u\x0f\x98g\xbdo\x9e\xd1X\xad\xcf\xf3\xc3W\x9d\x8b\xa9\xe4\xd9\xc1\xef\x9f\xdf \x9f\xa5\xac\x82E\xc0\x10\x16\x81\xe7\xbaE\x80)\xec\x90\xecN\xe4~\xab\xaf\xef`G\x11\xe9\x94\xc9\x98\xdf}\xda\x82\x97Nb\xa4S\x07\nD#\xa7\x13\xd6\xf1\x8bJFs\xb0B\x18\xf6\xd2\xe5\xcd\xae-yS \x97C\xf2\x84\xd0\x95&JEB\xb5\x04\xe5\xa6\xab\x93\xe5J\xa9:\x0bO\xeeX\x1f\xcc\x1ds\xe3\xb8z\xb8a^\x90\xdc]9D\xd1\r\xc3\x8b\xff\xbd[\xe8\x7f\xca\xef+\x8bSK\xab\xaf\x07\xcf\xef9>\x85\xdd\xe9\xd6\xfe\xdbw\x8e\x14\x0e\xb2\x8f\xdcr\xe6\x86ExW\x93g\xe7\xd6\x9f\x0b\xdd\xa2\xc6\xd0\xb6O\x0c/E/j\xcf_\xd8\xd9o\xfe\xd6%\xc3\xb1\xee\xbf\x93R\x1e\x8e\xdb\xfft\x9a\xa1\xc9\xbb6\xd4%u\xd3N\xd9\x9et\xeb:u\xf9\xcb\xd7IVN\r\xe3\x1e\xe4[?~\x10\xbe\xba\xb8\xdc>\xea\xc4\xac\x0f\xbc\xb3\x8c\xaa\x91%U\xdb\xfc\xa8\xab\xde\xafK]\x90t\xc5\xf1\x8f\xc0\xa8myU\xf7\x1c\x03\xd9\x0e\x9b\xf3"b\x04Fw)N\x1fG\xcf\x9d\x8b\xc9\xa6\xbe\x8a\xc3\x96\x7f\x98x\xb9`\xc7C\xbb\x82\x89\xf5\xe7\xcd^\xd1wE\xa5\t~\xe1\xcd]\x19L\x1a\x18\x94\xd8\xd6\xa1G\xe2\x86\x82\xbb\x17h9\x03W\xbd\xcf]\xdf6\xc8\x9c\xa1]\x99[\x1b\x93\xd9\x88,\xb5\x8e\xa4O!\x99b\x81\xb5\xbbn\xda\x07\xee=\xec\x1c\xbd\xb2\xc4&\x93\xcb\xc98\xb5\xac\xba\xdf\xe4\x05\xc5B\xf2Nk\xe3\xd2\x86w\xcb\xb6#g\xba\x84D\x7f~oPq\x08e5\xe5\xf7M\xc0\xc8z\xcc\xa49\xe3\x18`\x14xi\x95\xcf\xbfyw\x89\xa7ok\x13*\x15\xe2/\x0f3\xa51\xf4kB{\x04\xaf!a9Kt\xb99g.\x963Kc\xdef\xb36\xdew\xb0C\xc1\xbdnf\r=o1\xa3\x16\xc5\xdd]S,Z#\xfc\xd7\xc3Sk\x9a\xb5\xa5C\xf1\xc0\xa2\xb5[BUC^\x1b\x9a\xb1%X\xa4nQ\xe0c\xb0\x0e\x15\xf9\x17q\xf3\x06|\xff}qs3\xfe\x01w<\x95\x13\x0bBt\xab\x05!\x18\x0b\xc4\x02Z-\x08\x9e\xff\xc9=1\xee\x87\xbf\x0e\xf5;\xef\x87\x81k\xd3\x82\xe9\x15\xc3)\x01\xbdo<\xfaeK\xc6\xf53Y\x83\xc2\x90R\xb6z\xcc\xb04#\xb3Mg\x0e\x8c\x9b\xb3\x9b}\xb1\xdd\xaa\x99i\t\xbbc\xc9\'\xc3Q\xb3\xc8\xc2\x1b\xd9\xbe\xb7c\xf7\x96\x0cYju\xcb\x1a\xc9\xdb\xbc7\xf3\xe5\x8c\xaa\xa7\xfd\x90g\xb7\x0f\xcca\x1aT\xce\n\xbe]\x17\xd5\xfeF\xc4\xa6\xf9w\x1f\xcc\x1a}IS~\x7f\xe1K\x9a\xcb\x14\xca\xa3y=\xbbvQ||\xdbp7\xb3\x90m\xfc\xce\xf0\xb6b\x9fE\xf8\xf2\xd9)L\xe5\xa2\xdd\xc5^?%9\x1f\x19\xd4\xe6q\xc2\xf0\x01\x1d\x96\xcc@\x07\xdc6\xb4t}\x7f\x8a3p,\xc7\xbb\x97\x92U\xf9X\xe1\xfdy\n\xd3\xac\xfa\x10S8\xbb\xee\xca\xee\x8eO\xc2gL:\xe2\xd1k\xe4\xea\x83O\xf6M`\xf9\x8d\xbb\x18\xa5\xb4{\x86\x9d\xd8\x9b)\x19>\x0c\xe9\xc84os\xfew\xf3%o\xfa\xff\x968d\x87\xb3\xcb\x83\xf7S\xf2N\r\x1a\xfcp\xb9ba\xeaf\xaf\xd0\x8bo\xb3\x0e\xfel\x91\x9d\xd0\xe3\xf9\xaae=\xdci\x19\x96\t\xc7\xbdm\xd2l\xb5u\xaccN{\xcf\xfa\xef\xb8\xf7\xfe\xe9\x84\x9dw\xd6lP{\xec\x0e?2\xc6\xbe]\xf7\xb1\xac\xfe\x82\x99c\x86\x06\xfa\x9b\xef\xdb\xb1c[XR\xe5J\xbf\xcf\x9a,;\xcd\x8a\xf6X\xe2C\xbfv#-+Wt\xb1\xab\xf2\x7f\xd4\xeb\xd1\xde\xd7\xc1\xa7\x9c.^u\xd5\x84v\xef\x19\xdcu\xd4\xd0\xc7\x83\x9f\xaf\xbbY\xb8\xfcD_\xf9\xfe\x1c\x075\xad\xed\xb3\xb1v\x07\x97i\xcb\x1d\xa2\x7f-\x1d\xed=\xadx\xac\xf0\x17Y\xb1\xd9\xba\x83?\x07\xd5\xb5\x93\x7f\x9a\xee\x9a\xba\xbd\xb1zP\xe5L\xfb\xe3\x89\xfb\x97[Om\'&{;\x97\xc4\xcd\xd9}\xd7\xee\xde\xcem\'D\xbfdF\x1b\\\xe4\xb2#7/\xdc\xb66s\xd3\x8e\xa2\xc5\xe9\x96\xd7\xe6O5K\xef\xe2\xe2\xba\x81.+\x1a6\xb3\xdb\xc1\xa2\xe7\xb9\'\xec.?\xb1\x898\xbe\xf4\x19\xbf\xe6\x1d"\x91OcM\xa8\x94V\xde\x97=^_p\x86\xd3\xe3s\x9b#\xc3\x86_\r\xeb\\|\xf5\x83\xcb\x8a\x01\xec\x98\x0e)\xc7\xcdV\x7f\xc2\xb4\x86\xd9\x98\xd6 \xa1i)h3\xf7<\xb1\x14P\xbe~\x0c\xc8\xc9\xffWR\xb1+\x86\xe9&d\x8f\xef\x99\x90-O\x04\x1cX6<]1\x0f/\xdd\xa2\xd1\x9b(r0\xbc\xf8_\x7fb\xd1\x92\xff\xbcv\x90\xf1\xb5\x83\x0ck\x07\xcc\xb9Mu\x1f\x94\xa6V\xec-We?kM\xc3\xdc\xf7\xbc\xfcu\x88\xddJ\xbf\xce=S\x1e\r\x8d\xfcy7\xcd\xd3\x92\xca\xdf3\xa9\xc2\xc8\xe6F\x9f\x94\xa3\xed\xae\xb2\xea<\x0f\x15\xd2\xb6Uz]B\xcc9~\x17\xa6\x19g\x89\xa7N\\\x18\xdf5\xb5d\x05\xff\xa7G\xc9#\xcfW/\x8b\xda\xcet\xaa(\xb9\xb6\xb1\xd7\xd6lF\xc9\x95\xc5q\'\xe2-\r\x1e%\x8e}\xe8*\xe8\xde\xce\xe5\xc1&z\xe4\xd9\x1d\x01\xbbF\\=\xcc\xa6\xa4oJ~u2\xedU\xdf\xe1\xc5\x1d^\x07\xee\xa9\xf1\x14o\x96\x89=2\xd7\x15\x89L\x9c/\xf8.\xa8\xbfs\xd3\xd0\xf8\xd2\xf0\xac\xb5\xfc\x1e\x0f\x8c\x0f\x14\x99e\x1cX\xe8\xfd\xfc\xe3\x9d^CMm\xc3\x06;\xae\xcaV\xd6\xb4\xeb\xbb\x8b?\xf2jm\xad\xff\xbc\xc9\xd7\xc6m\x1f\x97\xd7\xf9\x9aO\xe9\xcc\x11\x0f\xa7E\xe4Z\xbe,v\x89\xbb;\xb7\x9f\xf3V\xb7!Gv\xf94\xba^\xd8A\xf1.\xdd^2\xdfs\xe2\xf9\xe5\x1a\xa77\xe1\x83\xe7\xd9yt\xab\xf0\x92\x89\'E\xed\xf9\xc9dK\'\xfb\xdc\x93\xaf\xf7P\xf2f\xbd\x1bUW%88s\xe1\xd4}ev\xean\xa3,\x1c\x7f=\xe5\xe0\xe8\xd9m\x89\xd7\xc0\xdeg\xc7\x97\xce\xdfje\xbf~c\xe2S\xa1\xed\xe8[\x8e\xfc\xe5\xa3\xf2ow\x1bq\xc1.\xc4Gpxg\xec\x80\xae\x94\xbas\xd9\xc3\\.\xd9\xdfQ\x8c0\x19\x14\x98\xb1\xa3\x9etk\xdff\xb2v\xd4\xf5\xb2\xf6;\xf6w\xbe\x18\x13\xf2\xc0\xab\xd8\xe4\x91=\x7f\x9f\xc5\xee\x80\xf1\xbc\xbb\xe5\x15\xca\xec\x1a\xe5\x83\xae\xd5\x07\x03\x0b\x8f<?d\x15{}\xf2\xac\xa7a|l\xfd\xa6\xd9\xd5O\x87\xad,i\xb8\xb1-\xf1vyA\xce\xb8\xda\xcb\xb5!\x0f\xf8=\xd6\x9b9\xae[?!Is\x7fzB\xe6\xa8\xed.\xb9Wb\x7f\x1a~0\xc3\xd1\xf1EmZ\x85\xe3\x1c\xa79\xbe}"\xcaoM\t\x98v\x98\x11z\xe4\xe2Z\x7f\x17\xf5\xa2w\xb2\xfaLt\x88\x93\xd9\x88\xf8EK}"\xdcr\x7f\xdf\x96\xdf\xf1\xe6\x8a\xf0\xd7\x8b\xb7\xed\x0b,J]r\xbe\xe6r\xfe\xcc\xe6\xb5\xb3\x16\xd6\xceG\xdfX\xfeZ\x16\xcfo>\x97tj\xee`N\xa6\x1a\xd90IQ\xc4\'t\xfcI\xdc/\xd7\xd5?-\xca\xad\x9fx\x94\xce}\xc9\x9c\xb9\xfe\xbf\x99\x1b\x84\xdfz\xbc\xfe\x18\xe7\x9c\xfd4wl\xa8nq\xc3\xdfA\x8d(\n+\n\xc9\xe3\xffGo\xfa\xc0\xbc\x85Y\x0b\x93\xb5\xf9\xa1d\x14\xe66\xca\xd5\x95X\xe6F\xb6Z\xe6\x04X$\x16\xdej\x99\xf3\xfb\xbee\xeeo\xf0\xd5X\xceJ\xdcx\x94\x9aS\x80\xe5,\xc4r\xe65\x93\xc4\xa6`9\x93\xb1\x01M\xea\xc8H\x07\xb7\x7fz\xcc\x12\xcbE*\xf0L\x9a&Tf\x89\x14*v\xb2:\r\xf3m\x06 c\xee6\xae\xa85)\x94\x84\xffO-\xfc\xc3P\xa3\x88\x0fC\xe9><\x97\x05%\x95\xfec}\x92\xe6\x0f7\xb2Q\xebo=\x88%\xbd\xcc[\xbb\xa4&:\xcb\x92}\xe1\xaa:\xa9\xcb2\xd6\xe2\xb6\xb7D\xf3\x0b\xfd\x16O8\x9fe4\xb7\\2\x8a\xed\xe4S_\xa1<\x976\xb9\xf1\xc0\x80\x87\xcc\x13\xfd\x0e\x06m\\\xfdJz]t\xb0\x8b\xc7\xda\x82\x11\x92\xdc\xb9\x13f\x04F\xc6\\5\x9a?\xfe\xbce\x88\xd5\xab\xfe~3\x04U\xdb>\xa5\xdc\xf11d\xf7Xv\xdf\xbb\xf3\xda\x8b;\xad3\x16z\xdd~$>\x1e\xe0\x9d\x99m\xff\xcal\xc2\xba\xb9\xea\xc9\xb3^\x9f\xecN\x0e\xecyh\xba\xe9\xde5\x1b\r\x8c\x96\xd5&\x7fHf/*\xea9\xa0g\xca\x10\xbe\xc8\x96!\x95\r]\xb2\xf8\xee\xe4\xd7es^\x05\xf6\xba\xd9\xd0\xafj\xbf\xc7sY\xb7\xad\xf7J\x1cj\xabn\xbcjSR\xe8X\xb0$\xac\x8d7\xeb%}\xdae\xdb\nW\x8b\xdbuG\x9c\xcf\x0c[\xf1\x0b\xdf\x8by\x94y\xe8\xe8\x96\xad\xf7\xb6_\xbb\xde>\x7f\x10o\x88\xa7\xeb\x18\x07\xcbI\xa5\xaf\x1d\xeao:\xf5E\xa5K\xb6\xc7MK\x96\xc9\xd7\xefRW\xf8\x1a\xd0\xd6!=\x1d}\xb4\x03\xcc\xc2\x12Ye;\xc2\xde\xdc\x9a3\xc9J\xde~\x02o\xfd\xd8{\xbe=%\xab+F\x08\x12\xf2*\xacE\xbd\x0b\xf2\xaa\x7f\x7fU\xff\xb2C\xf1R\x87[\xa7\xd7\x16T=\x1b!\xe2\xde\x19f\xf8\xd3T\x1fZ\x06\xed\x1c\xad4\xdd\xd6\xfc\x80P\xb8\xb3\xee\x8f\xa3\x9d\xa9\x07\xaa\xb9\xc7\xda8>\xbb)qyZ\xf0\xb6x\xf8\xe2\xab\xa4\xcb\xc5\x81\xfb\xe3^\x15\xace\x84\x04\x9b\x16jl\xabH=\x8e\x94.[;\x80\x97a\xe3q\xf4\xfc\xaaU+\xb3\xb3\xbb|\x08^d\xbb\xe9c\x90\xbd\xe6\xcd\x8a\xfa\x83)\xbbB\nn?I\xcf\xb4|\xfa\xb8Oa\x96E\xc8\xe7\xcb;\xec\x93\xd3\xef\x97|h\x98\xf1\x84\xa5y,\xedW\xd2\x80\xd5RCgWW\xa7\xa7\x89\xe6y\x9f[>8<\xe2\xa0&\xb6Kqf[W\xbb\xec\xe7\\f\xe9\x80\x8f\x1bN\xad\x19Q^\x9c\xbf,v\xcc\xe0\xf0`^\x99\xdf\xf1ec\x8715\xc1)\x9f\xb2V\x96\xefOK\x1b}\\\xa023\xce\x8e<\xcd\xd1R\xb7aZ\xeaf2\x82`9\x8b\xfe\xdb\x0b\xd7\xb7\xdf\x0el\xd9\x1b)\xca9\x8c\'\x1f}\x103(\x1c\xa3\xd6\x1b/`EK\x89\xc5i\x83\xb5nm\x8f\xd9\xb7t\xa4r \xb5\x9d\xb5\x10\xbd}jf\xfb\x849\xfd\xea\x94\xb56\x05\x8f\xaaFr\xeb0q\xab.F\x9c\xc1XtQO\x8d\xe37\xbfs\x11\xfd\xe7\xafI\x17w\xd7t\xfd\xcb\x99\x1d\xdd\xfc\x9d\x17\xf4\xab\xb5\x99\xaaEH1)1\x0e\x7f$\xeeZ/\x19\xe0\xbd]lm{\xf4\xd8\xd2{\xe7\x17\x0eK\xb2\xdd\x128u\xc2\x1f=nz\xa7\x91\xd0c\xd7\xbdE\xbf\x84\xfe2R\xfd\xda3X|e\xff\xb4\x9e\xb7r\x1d\x94\xae\x8b\xb6,\x8aKY\xde\xce\x96qm\x81\xc8\xdb\xb4\xc15\xf4\xcd\x8e\xa9\xd7B\xf6\xc5|(\xdcP\xbd\xc2\xee\x8d\x8d\xf1g\xa7g\xd7\xfc\x9f\xac\xec\xdb\xfb\xf0\xa9\x9a[\xb38\xfb\x83r&\x9c\xda^\xe2ey\xdbj\xab6_ 3\xe96\xe8\x8c\xfc3\xa7S\xffQ\x99\xd9\x13b\x1e\xc4\xbd\x8a-\xde|\xa9\xc2\xb1\xb2\xf7\xe1\xe0\xfa\x83Uu\x1d\xc2\x18\xaf7]\xef\xfd\xce4\xc9\xd4\xe9\\\xd2E\x8f\x0f\x9fL\xdbW\xb7\xbd2z\xe5\xa6\x851WV\x8d\x1e\xe02\x7f\xc5\xc4\xac\x10U\xa7\xa2\x93N\xf2\xa2\xdf\xdd\xc7u5\xcf=\xb5\xf6]e\xed,d\xcb\x8bY\xbf\xcd\x1eq\xedP\xe1\x04\xa1\x15\xd3m\n\x85\x84\xbd\x92:\x06\x8e_j\xe7vr\xfeA\xbf\x87\xa2\xc7\x1do\x9f\x11\x0ck\xb4m\xbcxY\xdb\xe9E\xb1\x96\xec\x08\xb7\'][\xc6\x88\xc6\xd1\x92\xdbCU["4g\xff\xd7\x1e\xc4\xbf\xbd\xd1\xd6*&G`\x16\xadC\x92\xd5\xb2a\x88\x80\xf2\xe6\x16\x03\x8e\t\xf1\xc6\xb1\x1b\xd6\xc7\xd5\xcd\xb5\xb7\xbb\xfb\xd0?E\xe4\xa1_)\xe9G\x1aIV\xc6y\xb6\xb5\xf7\xa2/,\x90%\xdd\xea\xff\xd5#\x13\x1e++\xf7/\xd8\x16Y^\xdf\xeb\xf5\xd1\xfa\x94\xf0A\x0f\xf6\xbc\xba\x1d\x9dK\x9ba?\xaaZ\xb3vD\xd7\x193;/\x8e\xcd\xf1wXh\xb4F\xbc\x7f\x97?\xe5>\xe3\xb4\xe7\xcd\xc6\xec\x11#6\xf4\xec\x18\xb8\xe3\x95w\xa9\xb5\xad\xb0p\xc1\xc9\xe1\x83\xe2\'z\xbe\x0b\xadf\x91\xbb>\x7fu|~\xa1#uu\x0f9\xd5R\x12\xf3\xfb\xcb\xde\xfb\xa4ml\xb0p\x9f\x9cq\xa1\xc37\x98lz\xb0}\xe6\xd6M\x93\xaf\\J)Y\xbe\xef\x04-p\xf1\x02\xd6\x9b\x13#\xc7\xf8z\xee6\xb6\xdc6p\xce\x01s\xaf\x90\x9e\x8fC&\x92R6,X\xc7I\xf4\xb1&\xbf\';O\xf7\xca\xb7h\xbf\xa3TR\xffkU\x9a\x01\xbb\xcb\xa9\xf8\xbe\xae\xe7\xd8p\x9bg@\xdbOv\xabX.\xdb\x99y>\xf5\xed\xd9\xb6\xfdSg\xfe\x96\x1e\xb0\xb6\xce3\xfcZ\x9e\xd1\xf2@\xf3\xb9\xaf~[\xea\xd8{\x94\xef\xb5\xd4\xc1\t\xfdr\xf86K.-\xdaxs\x9b\xe8\xcd\xdbO\xc6U\xc7j\x96\xb0\x12\xb7\xa1i\x1c\xf1D%\x89\xf4?=_\xe3\xcd\nendstream\nendobj\n33 0 obj\n[ 226 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 507 507 0 0 0 0 0 0 0 0 0 0 0 0 0 579 0 0 615 488 459 631 0 0 0 0 420 855 0 0 517 0 0 459 487 ]\nendobj\n34 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/BBox [ 0 0 480 160 ]\n/Resources <<\n/XObject <<\n/wspe_X1 35 0 R\n>>\n>>\n/PieceInfo <<\n/ADBE_CompoundType <<\n/Private /Watermark\n/DocSettings 44 0 R\n>>\n/Private <<\n/Type /TrialWatermark\n/Version 7\n/ProductType 20\n/Brand (WS)\n>>\n>>\n/OC <<\n/Type /OCMD\n/OCGs <<\n/Name (Watermark)\n/Type /OCG\n/Usage <<\n/Export <<\n/ExportState /ON\n>>\n/PageElement <<\n/Subtype /FG\n>>\n/Print <<\n/PrintState /ON\n>>\n/View <<\n/ViewState /ON\n>>\n>>\n>>\n>>\n/Group <<\n/K false\n/S /Transparency\n/Type /Group\n>>\n/Filter /FlateDecode\n/Length 39\n>>\nstream\nx\x9c3T0\x00BC0\x99\x9c\xabP\x08\x84\x86\xa8B\xfa\xe5\xc5\x05\xa9\xf1\x11\x86\n.\xf9\n\x81\\\\\x81\x00\n\x8b\x0bF\nendstream\nendobj\n35 0 obj\n<<\n/Filter /FlateDecode\n/Type /XObject\n/Subtype /Form\n/Resources <<\n/ExtGState <<\n/GS0 36 0 R\n>>\n/Properties <<\n/MC0 37 0 R\n>>\n/XObject <<\n/Fm0 40 0 R\n>>\n>>\n/Group 43 0 R\n/BBox [ 0 0 480 160 ]\n/Length 89\n>>\nstream\nH\x89\xd2\xf7wV\xd0\xf7u6PprqV\xe0*\xe42P043P0\xb10P\xd0\x051\x8aR\xb9\xc2\x15\xf2\x80\xe2\xfa\x01\xa9E\xc9\xa9\x05%\xa5\x899\nE\x99\\\xfa\xee\xc1\x06\n\xe9\xc5@\xe5!>\xfan\xb9\x06\n.\xf9\\\x81\\\xae\xbe@3\x02\xb9\x00\x02\x0c\x00D\x93\x14+\nendstream\nendobj\n36 0 obj\n<<\n/AIS false\n/BM /Normal\n/CA 0.279999\n/OP false\n/OPM 1\n/SA true\n/SMask /None\n/Type /ExtGState\n/ca 0.279999\n/op false\n>>\nendobj\n37 0 obj\n<<\n/Intent 38 0 R\n/Name (\\376\\377V\\376\\134B\\000 \\0001)\n/Type /OCG\n/Usage 39 0 R\n>>\nendobj\n38 0 obj\n[ /View /Design ]\nendobj\n39 0 obj\n<<\n/CreatorInfo <<\n/Creator (Adobe Illustrator 19\\0560)\n/Subtype /Artwork\n>>\n>>\nendobj\n40 0 obj\n<<\n/BBox [ 22.9079 136.438 455.592 13.5033 ]\n/Group 41 0 R\n/Matrix [ 1 0 0 1 0 0 ]\n/Resources <<\n/ExtGState <<\n/GS0 42 0 R\n>>\n>>\n/Subtype /Form\n/Filter /FlateDecode\n/Length 3562\n>>\nstream\nx\x9c\xe5\x9a\xdd\xae\x1dG\x11\x85\xef\xcfS\xeck\xa4=\xe9\xea\xff~\x02nA<\x01:\n?\xc2\x96 \xc0\xfb\xb3\xbeU\xfb`c\x07\xdb\xb1\r\x81D\x91r\xdc\xb3gz\xaa\xabV\xadZ\xdd5\xe5\xda\xa7\xde\xca\xb5\xeb\xb8\x15\xfd\xf7\xa7\xa7o~\xf5\xedw\xcf\xdf\xfe\xf9o\x7f\xff\xed\xab\xdbw\x7f|\xfa\xe6\x97\xbf)\xb7\xdf\xff\xf5\xe9/\xb7\xf0\rq\xeb\xf5\\{\x8cu\x8b\xd8\xd7i\xe3\xdc\x9e_?\xf1\xd3\xeb\xa7{\xb9f\x19\xb7~\x95\xb8\xbdz\x1a\xd7\x9e[\x83\xb3\x97F\xba\xb8\xc7-\xe6\xb5\x0b\xc3}\xcd\xd3n\xb1\xaeQ\xaa\x86Q\xae\xbe\xe6m\\s{x\xaeu\xf6m\xe9\x99\xada\xd5\xaf\xa5\xdd\xdaU\x16\xc3\x08]\x8f[\\s\xf1\x9eh\xd7h\xfbv\x8f~\xcd\x98yaiUw\xbd\xac\x95~\xd3\xf5\x18S\xc3u\xcd\x1e\x0cg\xe5v\x99\xa0U??\xc5\xb8B\xc3#\xdb\xcfM\x83\xd9\xf5\xac^\xd9\xda\xc2\xde:\x9a\x87\xbbln\xd6\x02f\xd7\x85\xb84\t\xf6\xd7\xe5\xd1\xe8Z\xdd\xbej\xcf\x1f\xf1\x83\xee\x96\x87f\x8e\xa7~\xd6\xaa\xea\xc9ak7\xcd9F>\xab\x17??\xe9\x1f\xad\xe6\xd3M\xe6\xd7zE\xcb\xbb+w\xd7\xeb<\xe6*\xadr{S\x18\x1e\xa6\xb5\xb8\xd5\xae\xd9\xa6\x87\xac\xb2jQex\xd8\xa7o\x1f\xd7j\xfc\xae\xe5\xf7\x83SuGl_\xd8r\x9f\xfe\xb4`)\xe3*\xa3\xdf4{k\xdd\xc3zl]\xbd\xda\xa8\xbe0\xba\xcc\x91\x91~\x9d\xa6\xe5urW\xdf\x1en\xc5\xf5\x99\x086[?\xaf\xf2\xf0\x8c\x9f\x9ez\xa9\xe3^\xf6\xcc_\xcf\xca\x18\x9c\x1aya;F;r\xba%\x0c\x11\xd0u<\x8c\xe1\xdb\xab\x16sl\xfb\xe8SH\xbc\xfc\xb3\x80 \xf7\x0bK\xa7\xe1\x189\xd0A(\xc2M\xbab\xe9\xe9su\xdc.\x8b\x96,=\xfa\xad\x19*u\x86n\x9e\xc2aSB\x9c\x05\x92\xfe\xf0\xf4\xbb_<\xfd\xfam\xf0\x97\xa6P\nv[7\x8e\xbe\xde\xc2>&\x0b\xa3q\x9d\xc2\xa3\xca\x85\x90\x03[\x15(\x81\xb4\xa6\x148+\xf0\x02\xff\x04}\xdc\xea\xba\x0e\xce\xbc\x96\xc0\xa5\xbc:\xfb(aF\xf5<K\x1e\xc2 \xfc\xd8\xb4\xb4\xddn[\xa1\xba\xb5.\x18\xb1f\xf0\xd0\xe4\x92c`\n\x0e\xba\xacq\xc7\x81d\xd2\xf0\xc8\xde\xee\x98\xa2\xc8\xf6\x95\xb1\x89\x9cgN\xc3p\tvz\x03\xc0\x96\xd3\x8aR\x1a\xb3G\x82\xac*\x99e\xcd\x10\n\xe4\xee\x08\xfdX\x84}#n\x87\x9e \x95{"\x0c kM\xc1j\x14I\xe1\t\xfct\x8fX\x86\xa6\x8b\xf0\xbd2A\xb0\x14\xe6\x8e\xb1\xd8e5\t\x0e)\xbc"\x13\xb6~\x05\xea\xcep\x12F\xe8\x90msN.W%.\xc6\xe0\xc2b\x1a\xd0{\xda6N\x8ba\xad\x17N\x05\x12\x18\x92KK\xa1\x07\x84\x9d\x01\x89OJ\x90\xbd\xb2\\\xb6t\xfd\x11\x04F\x9d,.\x9a\x1dX\xbd\xd2\xe1d\x13 \x8bP\xd3\x12Z\x82\xdf$(\xb2\x0f0\xeb\x8f`\xa7\xdf\xd6\xe2\xdes\xd5\xf0\xad]\xd0\x16\xe7l\xbf\xe2\x08\x05`\xa62(\x81\xa9z\x85\xad\x89\ngVaSv\x96\x86\x1f\x86\xbc\xffH--\xc9\x91\xc5GJ\xdczu\x96\'.\xf4\x80\xe8\x98}\xb8Q\x90\xd8\xf6HQ\xb8\x19l\xd6\xcco\xba1\xc2i7\xc9NE^L*\x83\xcb\xf7\xa2\xbc\xcd%sd\xf7Y\xd0\xf2\xbf2|\x83\x1d\x94\xed\xca!\r\xaa\x01;\x99\xac\xac\xae\x15*;\xf4\x82\xa4s\xa5\x98F\x84\xab\x92\x95\xc4N$\x13\xf8\x0f\xb6x~j\x8e?\xce\x95\xc1\xf0\x10~\xef\xdd\xf3\xa8.\x10\x92\x05\x0c\xf7\xd5\x88\x9f\xa2\xa8\x88S+\x08\x82\xa2\xa9I\xa0\x82\xe5u\xee\x12\x19\xa9\xb3\x1dx\xd2\xcf+\x9e\x8c\xcaZ\xfe#\x83\xcd\xfc\x0f\xac\x9c\x13\x8cc\x1b^\xab\xfb\x91\x0e\xac\x15\x91\xed\x02\xd0\xeaNt\xa7y\xb5\xd7\x17\x8c\x93s\xba\xc7!\xc4\x90\x9a9\xc3\xabs\xc1\xe46\xa5\x8c\xc4%\xa9\xe5\xa43n\xd4@R\x1b\xa8\x8d\xada\xdb\x86O\xd5k\xe1O\x83\xa7*\x01\x84\xe9\xb6\xf3FARi\xaf\xe2\xc8\xbf;\x99\x13\xcd\x136\xcd\xd0\x0cr\xc2\xba\x15\x1c\x85\x05\x86\xa3\x00\x97\x03\x85\x1b*J\xce!\x82\x15\xb4*\xaf\xacT\x1a\xdd\x7fL1[H\xbdS\xeaB\x80]J\xa7\xfb\xd2\x94\x04p\x8b1\xeer\x7f\x9dF\xf6\xd1*\xee\x02\xb8\xe6\x17\xec+\x15\x86\x8b\xc3)\xc1\xcb\x82\xba92\x0e\xb1\xf3\xc2\xd2\x1c\x81\x1a\x98\x1e\xeeD\xe2\xa2\xccj8\xd2\xbd2z\xe7\xef0\x84b1\xaa\'7\xc0)u\x07\xa3\xd6~\xc4"D\x14\xb2\x18X\xc04\x98\xa5\xd5\x80t]\xd4r\xb5\xd0\xd8\xd8A\x92R\xee\x957\x0b\xaa!\x85\xbb\x1d\xb1\xc3\xde\x9cz\xc1]\x13:\x04E\x04\xa6i\xfbK \xc95\xbf\xf6\x10\xe5\x81\xaaPI\xd7\xbb\x85\x00\x98\xe1\xee\xe2\x82o*\x95\x83\x0bq%\xcf\x87\xf2\xe6.\xb7\x84b\xad\x05\xa05\x18\x9e\xe4?\x05\x05\r\xa2\xc2VM\xc1\x14Y\x14L5\x94\xeb\xae\x1e\x91\x83.\x8e\xb3\xe5\x05C\xbb9P\x0c\xf74\xfdD\xcfgk\xd2\x8f\xd7\x8b*\xda\x84\x93\xb2\xaa\xf7\x0e%I\x16\x05L\xac\x914 S\xe5\xe3\rC\xdb\xb2;\xa9p\xe0\x0e\xaa\xb9\x10\xd1\xa6\xb3\xf9`\x10\xd6Q\x1b\x9b\xab\xab"\xd3\xcd\x17\xcc\xd3\xcc\xde\xa1\xf4yMt\xba\xe6 qV\xea\x8c\xaa\xc8/\x81\xde\xa4\xbd\x0e58R\xb2\x90D\x9a\xd0\xe9\x80\xe4\xc8\xf5\xf4m\xf9\xd3E(\xb2\xbc\x8bjDq$\xa5\x16\x15g&\\P#\x1ac(\xc9^\xcd#\x04\xce\xd8j\x8cV\x96;Y2\x8c\xc0\xe2\xabGXf0y\x1cJ\xc5\x91m\xa5R\xe8\xd5\xf74\xb9n+}\xecm\xfe@\xdd\xcb\xd2\xc2\xd1\xd6\x13r\xb6\xd2cl\xa7"\x19\xd5\xf9\xe7\x1bG<\xbf\xc7\xaa\xd0O\x93C\x97\xd0\xb0\x89\xecgk\x87"\xd1C\x85S\xe5\x97\x0e\xe37\xad\x19\xe8\xe8\xff\xe6\xa3e\xdeH\x05\t\x03\xe99\xb1[5\xb3L\x01S\x0b\x17qQ\xd6K\x02\xa1v\x17}\xf8F\xd0\x15WJ\x0f\xc8\x16-KU\xb45?\xf4\xfc$V\x10\xd5K8T\xdd!\x16\x15\xdb\xa0"\x8eE\x17\xa4\xa7\x11\xa6\xa6B\xdb\x96#\x98\x87\xbb\x11+\xfau&)\xe7\xacd\xb5\xf5H\x11\xa0\xf5\xfaEm)\xceT\xf2t\xa6\xcc\xf4\x8a\xb8f\x8d\xdc\x8fI\x15\xbdP\xc3\x84@\x956}\xd7\x9eR%\x05o2\x92\x9d\x98zV\x99`\x1der\x8fj\x05\xd4]\xb2+\xa8\xb0Bj\xd3Z\xe2\x04UP7eM\x163i\x94\xe5\xbd"ee\x1feba\xc9\xa4\xf8\x0b\xde\x93wWt\x81\x92\x08\xe6\xe9\xa9\x12\xe4\'\x82\xab\xfb\xa7\xff\x1c\x11_SLD5mzn\x05@\xa1\x1fv\x90\xcc\xea\xb25\xa3C\x11\xe8\xca\x92b\xc2\xa1H\xe9\xd6\xd4\x08\xcb\xa5D\xfb*%H\xa5`\xa6\x92\xd2\xc4c[;\xd4\x9a\xc3\xb2\x1e\x92\xc7\xef>.\x1aJ\xc1\x06ON\xdcS\xe7~X{Rh\xaaf\x13\x8be\x07\x15cfL\xff\xb4\x824\xa9)j4\x86\xa7\x80e\xb3\xdfw\xf56\xa2\x17c\xae\x8d\x96I\x1d\x94H\xd5\x18\x11\x90b\xb2ss\xb1\x8e\xd5\xa0\xef\x85\xf2\xd7\xa3\xc4\xe2\x84\xeb\xa4\xe6\xabBms\x91y\xf5\xf4\xa2c \xbb\x99c\xb6Z\x16\x94\x13D\xf9\xd5\xab\xfb\xdf\xd5e\xa0\x98\xbb\x94\xfd\xd3\x05\xbbe\xda\x9fj*o\xd4,!\xbdYw\xe3P\x97,d\x89\xf3\xc5\xdc\xd2\xa7\xc1U\xd9\x17\xca\xcd\xc7\xa8DJ?\xb3\x07\x1d)\x10\x91\x17\x00py\xe0-\x05;.K\xc7\xee\xea:\xd6\xca\xd2o\xad\xf4\x90\xcc\xd0D%4\xa0,\x93\xb5\xb4\xc8J1\xd9\xdb\xee\x9e;D\xa8\xb96\x8b!\xaa\xefG\xc5\x9bb\xa2)\x94\xce[\xfe\xa0\xf8|T\xbc\xad\xcf\x15o=\xa5\xdb\xf8\x98t\xeb\x1f\x90n\xe7\xc7\x90n\xeb\'+\xdd\xea\xd7\x92n\xed?/\xdd\xe6\xd7\x95n\xf1%\xca\xad\xbd\xad\xdc\xd6\xe7\x08\xb7D\xf2\x07\x94[\xff\xbfPn\xef\x08\xb7\xf55\x84[{G\xb8\xb5\xb7\x85[\xfb\xa0n\xdb?T\xb7\xbd/\xdb\xf6\x97\xc9\xb6\xbaT\xf9C\xeb\xd3\xa6\xb8\xa1S\xde\xf0\xe9\xf2\x91\xe1(^\xa9d\x9b"!\xef\x0c\x85u\x84\x8f<?L\xd4\x1d\x07rF@\x92\xae\xf5\xa9D\xdd>\x89\xa8\xbfw\x93\xfdEL\xfd\xa3l\xb2\x7f\xbaL\xfd\xd56\xd9\xff\x05\xa6\xfe\xacM\xf6\xff*Q\x7fl\x87\xfd\xf3\xe5\xe9w7\xd8\xed\x07l\xb0\xff=Q\xefO\xde`\x7f!S\xc7\x92\xd1G\x13O\x00\xf4Nc\xaa\x81(\x01\xb1\x99P\x85\xe1\xe1NCqo\x88\x03\xf2\xe10\xccQ\xe5<2\x00\x81\xdfq\xd6\x86\xb6\x9c\xb0\x80)\x92\x03Jx\xc1\xb4B\x86\x99\xd9\x9bZZV=L~\xcd[\x1a\xa5\x16\xcf\x1d\xf7f\xe2\xb1\x99\xc5\xb5\xcc5\x977?\x0f\x17\xd6\xdc\xd0\xda%p\xa7A\xbb\t\x14\x15\xc4-\x96\xe2\x9dZ}\x90q2\x04\x1b\xae\xea\xb3m\x92\xc4g\x04aNo\x8fM\xf0`\xdb\x0bH\xc1\n\xdb;\xb6\xe9\xdb\xdb\xb1W\xec;\x03I\xc5vf\xee\xcc\\\x90\x03\xb8k\xf5>\xec\xd8u\xd0S\xf3\x98r\x93\x1cR\xe8\x17(I\xd7\xf4\x04\xb3y\xdf\t\x07\xf3\xb8K%;\xeb23\xf1\xba\xbc\xc4\xc9\xbe{q\xc3\xfa\xcf\x9d\x88\xea\xe1\xf2\xfe\x9e\xf6\x9aO\r\xd9\x15M\xf7\xeaf\xf8w\xe2J\x92\xc5\xc8\xa7\xfbL<q \xc1\xec\xf4d\xe4\x89\xcc\xcby8\xba\x98\'\t\xa1\x95\x8c\xd9\x99\xc9&\x87\x9d\xb7f\n23\\.\xbbus\x19\xee\xa4\x88W\xcct\xec\xc8\x138\xf7DN\xe6b\x98\xdc\x82\x06\xc9k\xf6\x81Q\x81Q\x1f\x06\x0b\x9bD\xda\xa0\xc3E3{K\xe2\x84G\xd3j\xbaG&[\x1d\x7f\x12\x8cZ1\x9dY\x013s\x103\x93\x90\x8a\xf9\x80c\tV\xafh\x89@{M\xa0\xc1\xd3r\xd9\xf0\xad;\xfb\x843\x1b\xac\xc7\xcb\xd5(\x86[\x01t\xc4t\xefI\xe8p`\xb2\xfcln\xc6)\x1e\x1czx3\xbe\xbd\xea\xe5]+<\xc2;e\x17A\xa5cFG\xd0\x92=(W\xd0FMR\xa6\xa0\xdf\xe9Ad\xf3\x07t\xb0\xf9E:\x99T\x8aeR\x9e\x1bL\xfa\xb6\xcb\x9d\xaf\xe9\x8c|\x10}A\xe1\xb8]\xe7\xad:\xa5\xb4\xe5!\xd7\x19(\x15\xf6\xfaY\xc3\xd7c\x07\x0e\xd4\xf4\xc0\xb6S\xdc\xccT\xe2\xe6\t\x049\xa7\x8a\x99])QP\n\x05d\x98I\xcf\x14X\xabO\x13\xdaq\xd8F{\xd4\xc7\x16.\xba{\xd8\x95\xd1\xb3\xd1\x16n\xf5\xee\xe5\xdf8b\xcbs\x85\xe6_GO&\xf0 H\xed\xee\xf6\xafO\x05\\]\xdc3\x94E\xb4F)P\x05\x8e\xa1K\x15\xb9\xa5\xce\x92\xe0C\x85%\xf6P\xb2\x9a,\xea\xb1\x88\xa0\r\x1dn\xdd\x8d\xcb\xec\xc3Z\x8e\xdb\xec\xf0\xad\x06@xw\x9fC\xbc \xf3}r\xa4\x17\xe8\xb6\x12v\xf4wTl\xb7\x8aE\xb4r&3o\xa3>Zo\xdd8\xea\nk\xe4\x10y\xd4\xe9C\xd2\xadW\xa5\xf1s\xd8\xac\xad\xe7\x08\xf35\xb4\x87\xb5\xa2\x90c\xdb96\x1a\xddr\xc8<\x10\x8cf{\xf4\xd3\x97\xd0<\x1e\x85W\xc4-\'\x0f\xea\xc5\xf1a\x8fo\xad\x16\x9d\xf4"U\xa9\xc6?\xbbcA\xc1\x15%\x0c\xcb\x93\x93\xca{\xb5<\xa3\x83\x06;\xb20R\x11n\xacv\x9f\xce\x9d\xfb.\xe3\xcd\x90\xad\xfa\xb8\xa6\x0b\xfe\xd5GZT\x990J8\xf6\x94\xf3!KC\x89\xd3\xb0\xc6\xc1Y\xf5a\xd8Y~\x00\xa5\xd58+\xf2\xd4\xdd9\xa9I!\x0fDj\xf1\xc1fY\xce\x8dR,\x87\xb6\x00\xec^\xf6I\t4\xb6\xf3\xcf\x07\xb9\x18\xe9\x83\xcd\x14]\xa1JD\x16\xbb|\xd2\xa3oV\xd8@\x83\x03\xcfiaM+Y\x17\xcft\xe9\x88d1(\xffd\xad\xb6\xdb\xf9\xa0B\xa3\xb3\x8c\xc1e1\xef*\x8a\x86f\x1f g\t\xae\x127Yl\xb6%\xc5q\xce\x00R\xc3\xb3\xf8\xb3\x8b\x19\xde\xcf \tk\xb6\xa3\xb7\x80$\xbf\x14;\x8d\n3\xad\x8dpn\xd54`\xa8\x91l\xe1C\xe4\x95\xa2z\xd2\xd0\xee\xee\x8e\x8eL^\xaf\x7f\xb7\x87U\x08\xfc\x9a\xeb\xe1\xd5\'Y\x83B*\xcd\xb7f\x1e\xea\xadL0wO\x05\x82\xdc\xe9\x80HF\xd5Ez\xe6\x01`\xc4\xe3<\xf0d\xe7\xbd\x15\xb7\xc6\xa1\t\x8e\xcf\xc3\xce\x83\x8e\xf6Ku9\x96\xd3\x15P\xbaR\xcf\xf68\x1dt\xa5\xf6\xf1d\xf1\x19\xaf\x99u\xe7"9\xf5#4\xe8\x14\xc0i\xa5\x05\x1b\x02\xa7S_\n\xf8\xc1q;?\xec\xd8y\xdaL3\x99Sk\xad\x89\x82\xed3I\x08\x8bcZh\xee\xb8;\xcfI\xac\x1c\xd6R\xb3)>\xbd\xf8-\xb9\xd3\xe2\xf88\\R\x90\xbc\x9a\xd0\xe7\xc3\x96 Mk\x11\xcc\xc3\\\x0cjD@\xbdY.\xd2\t\'\xcd\xbbUrL\xef+{~O\xe3b\xd4t\x93\xc6n~sF\xed{\xcf1\x83\xa1\xd5{\xf7"\x92\xc2T\x07x\xb6\x9a\x9c\xe6\xf0\xa8\xeae|\xfe\xe2L\x1b\xfe\xe6CBB)/\xfb\x8e7\xb1E\xdc\xd6\xe9S\x03\x98\xcegD\xc1~\xdb[\'\xb0\xdb-\xeeP\xbd"&y\xa0\xf9\xc4\xd2\xc7\xf8\xfb\xe1,U\x04M\xd58\x1ag_\xb7\xbb\x1b\x10\xc7\xc7\xe3oA\xf5\xfd-\xbe\xb3\xd9\x94\xdd\xcd\xcbo\xc8Q\x8c"\xdc\t\x8b\xdd*\xa0\xa3\xc8\xfd\t\x0b\x85[p\xbe\xc3-\x9a\xf1\xce\xbb]\xfaQ\x92\x88\xfc\x8a\xcc\xf1\x01\xb3\x18\x96\xe3a6@\xdeh\xab8[\x8alk!\xfa9\xc1\'E\x8bCa\t,+1\x14\x10\x8d\x82W\xccL\x94\xef\xcel\x14\xd8=\xbf&\xba\xe3\xc8\xb1|\xa1\xfa\xa4\xe1.R\xc3\xcf\\\x99.\xa9|\xd5\xe4\x0f\xaa\xf8\x18f\xcd\xfc\xaei\xf95|;\x13sY\xb9u\x1fW\xf0\x81\x94w(\x14\xae\x92\xd3l{\xfb\xceg\x00~\x13\xa0\x82\xaeE\x84\xdb\xdaj\xb1\x01bc\xaf{v\x852\x8e\x85\xef=\x85\xe8~\x119\xa4\xbe\x06\xd3J!\x0e\x05\xe3X \xbew,2\xc5@{9\x19\x17\xdf\x8a\xbd\x89\x05\xed#D\xd2p\xfbI\xd6\x08\x12\xd5-\x985\x1e]\xb3\xe1/b\xd0\x059V\xb45\xe6D=\x8fgf\xcd\xa6\xcf\xb1\xd2\x11\xd5\xbb\x05\x96;\xaf\xec\x93\xb4\x9eV19\xb4\x0f\xc3\xef\xe1&\x9d\xd0\xa6\x07\xd9\\x>\x14\xd3m\x1do\xa6\xac\x93i\xe5t\xbe\xd2\x887\xc7=\xff\x00\xbcYy\x9d\nendstream\nendobj\n41 0 obj\n<<\n/I false\n/K false\n/S /Transparency\n/Type /Group\n>>\nendobj\n42 0 obj\n<<\n/AIS false\n/BM /Normal\n/CA 1\n/OP false\n/OPM 1\n/SA true\n/SMask /None\n/Type /ExtGState\n/ca 1\n/op false\n>>\nendobj\n43 0 obj\n<<\n/CS /DeviceCMYK\n/I false\n/K false\n/S /Transparency\n>>\nendobj\n44 0 obj\n<<\n/Filter /FlateDecode\n/Length 315\n>>\nstream\nx\x9ce\x91Ok\xc30\x0c\xc5\xbf\x8a\xf1\xb9\x7fw\x18=$)[\xa10\x18\xac\xb4\x1d;\x0e\xcd\xd6R\xd3\xc4\x0e\xb2\xd2\xb5\xfb\xf4\xb3\xd2\xb4\x1d\xf4\x92 \xbd\xf7{\xb6\xa5l~\xac+u@\x8a.x\x95+=\x1dM\xb4Bo\x82u\xbe\x94\xc6\xfbv9\x9ci5/\xb2\x0f`\xa4\x1ah\xbfA\xe6\xa4\xc6\x0b\x97\xebY\xa2\x8al\x13Z2\xb8t\x15*>5\x98k\xad<\xd4\xe9\xbfh\x89\xd0\xf3K\r%\xeaq\x91=\x07\xb2H\t`\n{T\x16\xe2n\x05\x9c\xd2\xbd0?\xce\xf2.\xd7Sq\x8e\xafV\x03)\xf6\x00U\x9b\xf2&\xa3\x99\x88\xeb\xc0\xc0r\xefK[\x9ao\r\x18\xc7\xa7K\xafKy\r\xe6l\x0c\x9eC\xd37\x17\xa1\n\xa4H0Uv\xdf\xaf>\xe2\xa9r\xa5\xaf\xd3\x85U\xeb\x1d\xe7\xfaQ\xab] \xf7{=F\x1e\xce\xb7\xaa\x13A \x89\xee\xc4k%qM\x83@\xe0\r\xaaowD\xdb\x90\xf3\xdc\x81\xc1GC\x88g,\xf8^\xe8\xa0U\x1a\xd5\x1a|\x89i\x196\xd7C1X\xdb\x19\xf1\xd0\x13\x91\x81\xf8\xac5\xc9\x1eS\xe6`:x\x10|\x9b\x96\x10osQ\xc7\xcf\xc8(/\x9f\xa4\xe2\xf4\xaf\x90\x19\xdf-\xb6\xf8\x03\x0fm\xaa\x06\nendstream\nendobj\n45 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/BBox [ 0 0 190 30 ]\n/Resources <<\n/XObject <<\n/wspe_X1 46 0 R\n>>\n>>\n/PieceInfo <<\n/ADBE_CompoundType <<\n/Private /Watermark\n/DocSettings 52 0 R\n>>\n/Private <<\n/Type /TrialWatermark\n/Version 7\n/ProductType 20\n/Brand (WS)\n>>\n>>\n/OC <<\n/Type /OCMD\n/OCGs <<\n/Name (Watermark)\n/Type /OCG\n/Usage <<\n/Export <<\n/ExportState /ON\n>>\n/PageElement <<\n/Subtype /FG\n>>\n/Print <<\n/PrintState /ON\n>>\n/View <<\n/ViewState /ON\n>>\n>>\n>>\n>>\n/Group <<\n/K false\n/S /Transparency\n/Type /Group\n>>\n/Filter /FlateDecode\n/Length 39\n>>\nstream\nx\x9c3T0\x00BC0\x99\x9c\xabP\x08\x84\x86\xa8B\xfa\xe5\xc5\x05\xa9\xf1\x11\x86\n.\xf9\n\x81\\\\\x81\x00\n\x8b\x0bF\nendstream\nendobj\n46 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/Resources <<\n/ColorSpace <<\n/DefaultRGB 47 0 R\n>>\n/ExtGState <<\n/GS1 <<\n/op true\n>>\n>>\n/ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ]\n/XObject <<\n/Im0 49 0 R\n/Im1 51 0 R\n>>\n>>\n/Group <<\n/I true\n/K true\n/S /Transparency\n/Type /Group\n>>\n/BBox [ 0 0 190 30 ]\n/Filter /FlateDecode\n/Length 5568\n>>\nstream\nx\x9cu[;\xb2e\xb7\r\\\xc1\xec\xe1\xc6\xae\xb2\xcc\xff\'w\xe2P\x91\x170\x89\x837vi\xff\x89\x1bh\x90\x04\xcfy#\xd9%\xa9\x87\xe4!A\xfc\x1a\xc4\xfd\xeb\xc7_?\xe2\x0c\x1f\xf9;\xf3\x1f?\x7f\x01\x0b\x7f\x04\xfd+\x7f"\xffm\xd4\xcf/\xa0S\xff\xea\x0e\xfdr\xe8\xdf\xc3\x05\xaf%~\x03\xfb5\xfe\xf3\xe3\xdf\x7f\xfb\xf1\xdf\x1f\xff\xf8\xd7\xaf\xf0\xf9\xe7\xff~\xfc\xc9-\xcc2c\x8c\x9f\xf0Gi=\xe4Yt\x0b1\xcc8\xdb\x00\x9ac\xcf\xb9D]4\x06\x80\xad=\xd00fJ\x8a\x96ZG\x1b\x89h\x1f\xa9\x86\xf2[\xf4Z\xa1\xa7\x98\xfb\xfc-\xda0\xa5O;\xd8h\xb5\xe5\xfcDg\x0e\xb1yT\xb0\xdeG\t\x82\x95\xd4R\x13,B\x14\xad\xc9\xf7\x01\xcc^\xc7\xe7\xa7\x9e\x0b\xe7\x1er\xda\x16c\xc6\x06ud-\xa3\xca\xa9\xea\xe8\xbd\xd5yc\xd8C\xcdk\xf6FcJ\xbd\xe7\x8f\x97T\xc1\x81SI\x9f\xef$\xfd\x13W"x\x0b#\xca\x88\x86Y)S\t0:\xa4\x99\xb8\'\x1cy\xe8\n\xa1\xe7N\xacU\x19\xa9\xf2H\xa1f\x87\xfd\xbc\xe4\xbc\xd0\xc7\x9d\x8c\x19e\x96I\x14\x02\x8dOt\x86Yku\xa8\xeeI\xf6"\xd8,u\x04b-\xe6\xac\xa7\x87\x1c"\x14T\xbf?G\xac\xa1\xabLZ\xaa3\xea\xc8\x19k\x119V\xc8\xb8s\xf7\x07\xab%\x87\xdel\xf6F{\xcbqPz\x03\xdf\x91/\xd6\x99`M\xc4\x9e\x92\xa3Dc\xc2IU\xe6\x05\xb7T\xc3\xa0N\'hj\x97=\x95\xd0B\xd1\x15pa\xa1u\xd5\xf3\x91{\xcdz\xf3\xb8\xaeQ\x15k\xa3\xc1xx\xcbP\xa0\x90e6\x96\xcc3v\x1d9[\x9a:\x12\xe2\x88UW\x840\x9aj\xdd\xc2t6\x149\xf4\xc7\xc8\x92p\xd0\xa4+\xc6\x02\xc5T\x0c\xd2R]\xcaP\xd0\x91(\x0f\x87\xa61\x0b\xce\xa0\xd6X\n\x96\xa8\x8af,0\xb9&\xfeG\xbb\x9d\x01j\xa9X\xc0\xdeisb\x1d\xd5v\x84\x03\xcf\xach\t\x91\xfa\x9d\x1b\x0c_\xf7\x1eS/\x99X.\xa5v\x87Q\x1a\xbd\xe1\xff\xf7\xc8\x94E\xebu?\xf8\xa4J0\x02(\\\xb1\xb4\xd2\x87Y\x0ct\xa2\xeb\xde \xe19z\xd4\x91\xa5\xce\xacw\x16B\xec#\xdc\x18\xb6\xd8R\xb4\xd9\x1b\x85\n\xb6^td\x8b\xb5%\xda`\x1e\xea5\xf0\xed\x04\xcdU}k\xa1\x9an\xe1\xc6K\xd4/\xd6:\xbbHX\xef\xb6E\xb5\xab\xda\xb1\x10W\x14\x01\x86\xe80J\xad\r\xca\xdc\x8d,\xa1SBULA-<\x16\xdc\x9fz\x82\x8a?\xad#\xaf{\x842\xaa^\xa7\x10\xb3\xdaO\x84\xb7\xe2\xdd\x15l\xb7\xd3K\x1d\xac\nh\x1axP\xd3\xea\xafou\xfd\x8b6\x90a#j\xbf\xf8\xd6\x94[\xffE=\xcc\xd4|(q\xa3_\x8a\x19\xd6\xdc\xd5\x823\xf4Q\xfd`\x14\xab\x8b\xd5a\x94\x1d\\E\xa8\xf7\xc8\x84CwJ\x19Ko\x0b\xaa\xaa\xcf\xf86\x94\xbb.\xc9g\xe8\x80z\x8a\x9e\xc5\xae\x04\x8b\xd8d\xa7\x97I\xa6\x85\xd8oR\x8d*\xf8\x9aX\x08O\x0f\x97\xa0\x12[\xe8\xd7\x8d\x8e9s\x19v\x1f!\xe9\x8e\xc2Hf\xe7/i\xd0S\xc0%dJoE\x9e_\x17\n\x91w\xf1^_7:\xe1\xdc\xd5+A\xf8\x1d\x1eD\xf5\xae4\x9e\t\xff\x9d{\xe5\xe9\x11\xfb\xf4[\x1f\xc5\xe1@T;*\x9c@P\x9f\x98\xe0\xe3a\xc6\x94h\x19\x1a\x99\x12\xd4.\xd6\xe00=\xffly\xd6{d\x9c\x10h\xe1}@\xdb&\xb1\x08\x83R\x1d\xc3\xbf\x8a\x9f\xe4\xec\x00\x99ez\xe96\xd5R"$\x0e\xdf\xaf\xb2\xc3\xdfz\x87\x0e\xabM\xfd\xa1\xce\xde\xe8\x95\r\x0c\xf8\x9d\xfa\x8c\xda\x07\xf5\xb2s\xe8\x96\x1d4L\xa2\xe8%\xbb8$\x84\xd6Kv@\xfb\x1cC\xbd\xda\x91\\\xec\xf8k\xe4[\x1e\xbd\xcc\xac\x9e\xf9\x92\\\x8f\xd1\xe2\xf3\x19\t3.\x99+BET\xfbcCXn*al\x03&\xc1\xd9\xf0_\x18\xac\x92\xcb\x88A\xaaap\xf0\xb3\x9a\x07j\xf4\xe1\x0e+#\x97e\xb3\x1b\xbddT\xe5\x98\xf5\xb7(D\x1f\xc43)*\x11\x86\x9e\xedB\xb3Eg\xec\x7fT\xc8\x8ehI%\xf7\x17Za\xa0z.\x08/\xb6\xce\xb3\xceJ}\x00h\x96\xdc&\x14\xaf\x98\x1fs\xd2\x83>\x13\xc5\xe9U\x0bd\xd3u\xce\xdb\x0b\xe2\xae\x03\xbd\xad\xf7\x97\x03\xd6@[8#\x11Tg\xe4\xb7\xe185~BgqJ\xdd#\x92\x9eZ\xcd_\xe2\xd6\x11\\\x1cJ]B\xf2\x91y\x1e\x84\x1c\xcd\x8c\xa0\xea\xb1V\xe6\x11\xa9Y\xdc\x9b9\x0f\x93gH\x92\xd5\xd1\x12p:\x8d\x0f\x90\xe7\x08\x91#\x11\x92g\xb8v\t\x07\x1d\x10a\x1f\xe7\x81\r\xc3U\x96\xc7\xc8\x81\x8b\xd3\xfd4H_\xa3b\x8a\xc8)U\xa3\x91\xc7@u\xf9m\xe4\xb3\xa9\x0cZ6\xbc\xa5\xca\x12\xf1:\xc3"\x19\xb9D\x05/\x0c\xa3\x93\xe4~\x9c\xbdP\xaf5o\x0fF\xff\x0fq\x01\xd6\xd1PF\xb8sz6H\'h\x16\x85\x9dDf1\xd8\x92$\xbd\x1f\x1f\xcb\xe1\xc0\x91I\x8c\xcf\x1d\xf5\x11Y!\xfb;?\x80Y\xf7\xb6r\xf7\xc9\xfc*e\xc46\xf5\xc5\xaa\x86v\x9b\xb8+$\x08\x9a3\xe41\xab\xda\\J\xa2S\xfam\xf8q\xf3\x9f\t\x8a\xae>\x11\xc1\xaaJ>\xad\xb3\xb1\xf5\xa8\xd1/#\xf8\x07\xd5\x1a\x84\xf2\xd2\x86F\x0f\\\x06sT\x87\xc9\x19f\xb5\xd9\x1b\x1d\x19\xa7\xe5\xb7\x1bBs\xa1\xffA\xb4S\x7f\x9e$\xac\xd1/\xf4*1\x8c;\x87\xf6\xa4d\x9a\xc4\xbc\x17\xb1\x0c\xa9\xcd\x9d3\xe0{p\x9aO\x1b\x10\xf9NZ\xe5\x19Y\x91\x01w[\x11<MO\x83\x1b\xb3\x18\x85\xacF2\x01\x9d]%\xe9\xd7\x1dI\xa0\xa6\xcc\x1b\xbc\x8e\xea\x11\xf6\x1d\xe8\x93\x1c\xe6\xcf}P\x88\x9e\x1cHV\xa4]d\xf1]\x9a\xa5\xbc\xb5\xc5\xe2#D\xd3M;\x8b\xb2 \xd5"$\x0c0=\xdd)b\xbdz\'\xfc\x03!\xc3G-j\xd1\x8c\xde\xf3\x9a\x16\xd5A\x8fzFB\xb3W\x16\x113\xd9\x0e\xb4\xa8\x15\xf3\xc7U\xc8\x9c\xcd\x86?\xd38\x08\xc3\x1afC\xf0\x02H\xe64\xe6`F\x9d7\xe6\xe5qP\xe8K\x9c\xd4V\x98\x9d\xca\x15\xab\xc5\xb5\x1f$z\xea\xcd #\t\x8f6\x1b\xf67T3+\x12\xd8L=\x00!\xd58\x84<\xb9\x98f!\xfd\xe9\x9aw,\xcc2\x00\xc9\x81\xd5\x97\xfa\xb1K\x96\xb2f\xd2\xbb:R\xc7\xd7s/\xc94\x01\xe9\x1ds{x\xd0\x14x\x97\x05\xc2\xb1\xf3(#\xbd0\x7f\xf2\x83v$\xc0\x99\xb3\xd7\x8a\xea\xa44F\xbeo\xdc4a\xc0]N\xcf\xdcU\x13\xe0\xb6\x8d\x15y\x9f\x04\x0fl\xb7\xe9bV\xea\xa2+\xf9\x85NLT_\'iFeV\x0b\xb7\xd0\xc8\x00\xe1\xdc2\xa3rB0\x18\x1a7@S\x06\xb9Z\x825\xc7l\x1c\xaaJ\xf4\xd2\xb3"\x00\x07\x8e4\x94k\xe6\xc6\xca\x01\x82We\xf6\x9d\x86\x86D\xf55-eZ\xd2\x10\x93+\xb4\x99\xe3\xbd\x06rV\xcd\xb5`\xe4#\xab\x7fJ\x92I\xaa\xae\x8a\x89wz\x10,]\x14[\xa7\x94\xd9\xe2\xf8*u\xd9\x9f\xfd%S\xfa\xee,I=w\xe0\xf8+\xd08\x95_\x1d\xfe\x9a\x85n\xaa\x16\x1f\xfe\x9a\x11\t\x87\xfaa\xcf_\xb3p*r\xc8\xcd_\xc5\x8f2_:\xac\x14q\x01\xbe99Lg\xc3/2\xba\xbb\x91\x92\xefGZ\xc3\xe2\xaf\x19\x9b`%\xc5\xf3W\x87:\xfe\x8a\x1c\x02V\xa0\xa7\xdf\xfcU\xd6,\x85\xfa\xb4\xf8k\xd6\x031\xfb<\xfc\x15;j\xe4\xfe\x87\xbf"\t.\xf4\xd3\'>\xe1<p\x9f\xd3a\x94\xc6\x98H:\xef\x91\x88\xaf\x91\xf6\xb5\xf9kF\xc8)\\\xd1\xf1\xd7\x8c\xb8\xd1\xa3I\xd8\xf8k\x0epj\x8dZ\xb3\xf8\xab\xc3\x1c\x7fu\xe8\xe6\xafY(\xe4\xa0\xaf[\xfc\x15\xdf\xae\x8c\xec\x9e\xbf\xe2\xc6{d\xae\xb2\xf9\xabD\xde8=W\xa5L\'\xeb%.\x16A\xfe\xe2^\xef\x91P\x03\xe3\x7f\x9b\xbf\xe2\x1a&\xabO\x9e\xbf\xe2\x1e\x871\xab\xcd_\xa1K\xa9\x98\x0fY\xfc\xd5a\x8e\xbf:\xd4\xf1\xd7\xb7\xae\x9b\rd\tC\xfds\xf3W\xec\x1fA\x97,h\xf1W\xf8Q\xdc\x17c\xf6b\xa5r\xfa\x94\x8b\xc3(\xbb\t\xeb\xec\xf7H\x08!\x07[\xd1\xf8\xab(\\MO\xfe\n\xc97\xd6\xf4\x0e\x7f\xcdJ_o\xfe\n,Q{<\x7f\x85\x94\x075\xc9\xf3W\x87n\xfe\x9au\x9b*\xfb\xcd_\xdf\xd2\xa0W\x06\xfd\x15\x15|xe\xd8\x12\x84\x92\x1f^9\x8b\xa6\xd2\xb3\xe3\x9c\xe2\xad\x0cE^\xa5\x92B,\xe8\x1aU\xb2\xdc#\xe3v\x83\xd7\xd6\xea\x1e0\x98\x163\xf9\xae\xbeLO\x85\x1c(h\xde\x80\x8bF,\xe0l\xe4U\x9a\x9f\xb5\x10\x07\xb9\x9e`U\xd7\x81\xe7\x9a\x92\xbdqv\x95\xe3\xc8\xec!\xa4IO?\xe1=\x13\xab)\xf0\xb9\x93+B5\x82\xe5\x16a\xdb08ey\xc5\x9e,\x84\x9c:\xec\xd1\x06%\xe7\xf7]\xd5XR8\xf2\xca\x0b\xed\xc8c-~\x96&\xdaK\x14\x9c\x85\xde\x17D\xcdtG\x13^F\xa9\xd9\xcdc\xc0\xcbFJQ\xa2\xcd\x8e\xfdy\x80\xa1hv\x9f\xa5\x8aC\x1f\x07\xd1\xb3\xee\x04\x9d\xce\xcc\x02q*\xd8\x89\xe67\xd8\xd1\xf6v\xd0\xd6\xc8Z\xb6\xdf)\xd4\x88\x950\x8fbu\x88]wZ\xe4&\x0cE~\x90\'\xbf\x85\xecSwX\x10;\x83\xdd\x19\x98\xba\xe5EP\x07eWg\xff\x8aV\x8b\n\xb8\x13\xfa\xfa\x82|4E\xceA\xfem\xb3%\xcd\xd6?E\xba\xc1\x1a\xb7~q\x92\x05^\xfb\x94\xd2G}\x9e\xe9\xad\xd1\xf4\x07\xc8\xeb\xc2\xb6\xd8\xa3\xe9\xa0\x8f\xc5"}\xd2l\xf0\x8bh%C\xbc\xd1ny\'\xfc\x184GeQ\xa1e\xd4\xa1\xd4\x1a+\xffE\xd2\xefF\x1f\x1a\xc3\xaa\x03\xe08\x9dR\x13\xef\xc0\x1aD\x81\xcb\xeb\xf5fN\x90\xb9$U\x8fx#\x99Xf\x96xFB\xad;\xf3\x118o\xd6\xc8\xa1\xcfX\x9d{\x84\xbd\x9b\xdf*\x92\xf8w\xcb\x1b\x1b\xb3\xbc"\xe4\xd6j\xa8\xb0<\x9e\xe6`\x03\xbbH\xd9f/\xb4\xe0`d\xf0\x12\x8ff\xe1[DN|I( \xd9\x99\xf5\xadV\xdbb\x9d\x90%$\xa4r\xb1W\x8b\xaf\x1b\xb5\xf7\x8d\x1b\x85\x04"\xb95\xc2\xda\xaa4 zO\xabjv|\x95l\x1f\x7f\xd6\xa3}\xa9AM\xe8\x89\xe5\xda\xb4\xaaW\x91\xabZ\x0c\\\x1e\x1b7\x91V\r\xf3\xf8v\xb1\x16\xe3\xd1g\xa4d\xd6\xdd|{\xa5V\x15\xc9T4\xe7\x82\x11\xf4\xb9\xeeG*\x05\x8c\x8b\x05\x89\\\xb7Sn)\xe1\xcf\xca\xba\xf3$$^\xfd\x13xC\x9a\xe6\'2Y#\xb2\xd6}kp\x1e\x16E\x9a\x144\xcb\xa51\x88\xbf\xb1\x9b\xbeEai\x0e3i \xdf\x1c\x8f\x91\x88\xf8\xac\x1f\x83l\x91\xfb\x14y\xfea\xa4\x86\xc1\t\x8b\xd5\xd9\r\xfam1\x11<\x86\x1a\x83\xbd\x19C\x83\xb5&\xf5\xb1\x07+C\xeai\xf6\xed\x8dz\x1f\xfa\xb6@\xb3\xcc\n\x86\xc4\xdb\xb2,\x87\x96\x99\xcd\x0fB\xb6U2\x08Jt\xf4\xc6z-\x14\xba&\xce\xc2\xedtb\xe0?\xcc\xa7\x8b\xd4\'\xf4|\xa9\xec\xbc\xbe\x88\xc3\xa2\xbf\x94\x17\x84\x98\xae\xfbDP\xcb\xe40\x07\xcb\x92\xcb\xcfu\x1f\x1b\xedR\x0e"WF\xe2UnN\x81\x1b\x96\x97,\xf5\x1e\x88\xd5\xd9< \xcc\x88\xbc\x13\x0c\xb9&\x8dK\xe2\xe3x\x1f\x19\xc6\xcc7)\xe8!R\x8c\xe10\xf3\x1e\x89y\x82\x1b\xb9u\x1b\x0e\xa3\xb0zql\x00\x11+\x0b\xb3\xe6l89\xc6\x99\xcdR\x8e\xd4\xa1Y\x99\x99\x87\xbb\t)\xc7\x8d\xba,\xf8q?vo\xa0\xe1\xeb\x9c\x88\xca\xf8\x96\xde\xdb\x90\x82\x81\xfa\x10)>\xf1^\xc6\xa8\x89\xbb:\xbbGl\x9a\x8c\xce\xfe\x9c\xf2pg\x9e\xea\x8cL0\x00r\x07\xb9\x7fV\x81!\xccj\xccCw\xc7\xd9\xaa\n\x1ff\xdb\xe6\x95\x90\xb1\xd9\xab\x12\x16\xeeV\x7fW\xa7\xc2=\xd6U\xd9s(&\x88\xf7\xf9"\nFcZ\x0b\rV\xfd@N?\xf8\xf2\x06\xd33\x8d\x9b\x9ab)\x06Og\xac\x19\xe7ArJ\x86\x96\xadN\x8c\x93\xb7<o\x96\x81\xecM\xdc\xfe\xe5\xf5?\xf4\x8e!\xe4\xc7X\xb0X\xbbc\xd8\xa6\xdd\xcc\xc1@LV\xb6~P\xa8Tk\xc6c\x0b2\x8d\xc2\x1a\xe4\xf7(\x88A\xdc\xe8^\xc1\xf2}EG\xe8\xac\xa5!s\x9eiE^(YS\xab\xf8\x1e\xf5\xcc\x15Rm|\xcf\xfc\r\xeawvV\xf8\x16EJ\xd7\xa4\xce\xf0@\xbbDf\xbe?\xe3l\x9do\xa2\xc8C\xe8S^\xba\xcb|\x18\x999,\xc4s\x8c_D\xa1\xc1\xac\x82-\xe6\x8c\x10\x1e\xcc\x9e7s\x86\xa3\x81\xc2\xd3\xfa\x0es\xd6\xba\x1b\xb9\xeff\xce\xf0\xa0\x8d\xaf\x88\x87\x0f#\x9eH\xa3\x81\xc3t6\x82\xc5\xac\xcf\x91S\xda\x18t\xc5\xc5\x9c\xb1t\xb2\n\x9cc\xce\x0eu\xcc\x19\x16\x11\xed\xddy3g\xac\x19\xc9c\x0es\x96\x82R\xb5\xd7\xe0\xc3\x9ca0yuq,\xe6\x0cO\x1cf\xbb\xf3\x13\x9c\x07>\xef\xd6i\xffV\xe3F\x82\xcf\xcca\xd5\x03c\xce5\x88\xeb,f\xcb+&V\x18C[o\xeb\xc6\x9c+\xf6@\x8fs\x98\xb3\xc3\x1csv\xe8f\xce\xf2\xa6V\xec\x15i1g|;\xb5\xc9\xba\xe3a\xceUZ*X\xd1\xdf\xcc\x19w\xdbX\xd59|X|\xfa\xe8\xcf\xca?$$\xd9\xfa=R\xba=\xa89\x9b9W\xa9V\x15f\x12\x879\x0b\xb7\xb457s\xae\xc2\xb1\x87yHc\xce\x0es\xcc\xd9\xa1\x8e9\xbfu\x9d~]J\xfc\xac\x9f{\xe6\\%\xe3\xe5\xcb\xdaf\xce5\xc5\x99\xda\x9d]\xc9\xe9\xed\x8d\xdaeW\xe0\xc0r\x89\x8f\x91R\xfc\xe5I\x16s\x16\x0b\xca\xc3\xaca3gH\x1e\x19\x1d\xefu1g\xe5\xb6\xab\xeb\xc4\x983\xfe\x14\x9e\xcbsdJ\x1e>\x9e\x9e\xd71g\x87n\xe6,\x80\xe5v\x9b9\xbf\xa5a\x9e\xa2!\xce\xb1o%Ks\x06\xa3\x1f\xf2\xb7\\\xb9\x82i\x8e`y\x1a\xf7F\xe2\x10-\xff\x92G\x8a\xe00\xdd\xa9DZ{\xa7\xdc#\xe1 \x0bu\x11\x16\xdc)\xb9\x8a8H=\x8fI\x1e\xc3lv\x02\x9d\xd2\xac\x0c.{X\xde\x19\xadV\x8f\xb4\xa2\xb3\xb7\xc8a\x98\xber\xb6\x83\xfa\x9cM\x8a\xbea\x8e\xdf\xa2\xde{\x83\xd5\xc0\xe0\xcb\x1b\x05Y\xb2\x97s\xcd\x97\xbf\xeck\xec\xff\xb8\xd1T:\xbdQ\xee\xc1|\xaa<\xd2\xf1vp,\xc6\xda\xaa\xb9-\xcf2\xca\xf6\xb30\x96V\xadF\x1a\xc9h\xe0\xdcE\xd2\xb7\xd5a\xf2\xec\xfeMQg\xcb\xab_\x0e\x8f\x91\xf2 \xca\x91\xa1\x99\xf4\x9a\x14\x91\xb9\xf6\x98\xab\xe3\xe8\xad\r\xb4\xa5&e\xf3\xec\xa5\xfa\xebB\xfd\x1b\xb7C\xf7\x1b7\x0c\r\x9fc]o\xf9M\x84\xb5B\xcfx\xf7\x07\xb4\x04\x05\xb5\xd7\x92\xf5\xca\x8d\xe4\x1e\x97\xe2_\xb4\xa5\xa3\x0b\x04\xc5\xde\x89\xce\xab\n\x1cP\xa9\x8fWn\xa4;=\xaeWn\xeb\x0fh\x92\x03\xdb\x8eN\x7f\x00\xc2v\xe4K\xec\xe9\x0f\x10\xd1\xb3\xbaq\xfa\x03\x1c\xe6\xfa\x03\x0e\xea\xb5\x0c\xc7\xcd\xa1>+1\x07\xbddw\xd0-\xbb\x8a\x7f\xcb\xb4\xa6-\xbb*\xef\x14\xb4\x1c\xd7\x1f\x00\xda\x89\x1c8_\x92\x13S\xdc]-&\x0f\xa9q\xcc\x94\x1e\x92\xabc\xd8\x1b\x96\x1b9\x84M\xd1\xbeW\x7f\x00\xd4\xb3\xaf\xf7\xc2\xd3\x1fP\x91\xe1%Z\xfa\xee\x0f@\x9c\x8f\xadX\x9c\xb2\xfe\x00\x87\xb9\xfe\x80\x83^\xf6\xd9\xab\xbd\xcd~\x8f^\xf69\xa0 \xede\xcb }\xd1^\xe3N\'\x00P\xd8]z\xa1I\x9eX\xd4BW\x7f\x80\x98e\x9c\xd6\x97g\xfd\x01u\x88\x96L\x8bvNz\x91\xdd:\xa7?\x00\x9c\xab0Os\xb68\x85\xd8x\x8c77#+\x95g$\xf8a\xb4.\xa3\xdd\x1f\x80\xff\x0e\xac\x8b\xf8\xfe\x00\xa9)Z\xecw\xfd\x01\xd0\xc6\xca\x9a\xe5\xe9\x0f\x80\xd6\xa7h\xd9\xf1\xea\x0f\x80u\x08\x7f\xa3\x97\xd9\xfd\x01\r\xfbao\xda\xe9\x0f\xc0\xbe\x11)\xef\xf3\xc0C\x83:\xce\xc7y`\xc3\xd5^\xbe\xce\xc8$2\xa2\xefY\xfd\x01\x88\xdb\xab\x1f\xc7\xf5\x074\xa1 |\x15\xde\xfd\x01\r\xe9MZ\x9dm\xd6\x1fp0\xdf\x1fp\xd0\xcb\xde^\x1e\xcc<\x1b8N\xbfzz\xd4\xb3\tl\xb9\xee\xa9\x9c\x01\xad\xac\xf2\xde\xa8\xd4 X\x9d^\xf54\xa9\xa1\xd9\x0b\xe7\xae\xa7!hC\x12\xecS<\xf54d\x81\xcd\xdeHw=\xadU\x91\xdf\xcd\x96\x10\x90\xf3\x9do\xeal\xd05\xfa\x017RJY\xd92`\xab\xa7\xb5\xa2\xef\xbc\x9f\xbb\x9e\x06\x1a\x81\x0c\xcf\xdeg\xad\x9e\xd6`\xe5\x9d\xa7\xd9\xf54\x87\xb9z\xdaAO=\r\xc9Q4v\xb7\xebi\xe04\x83\xfd\xc7\xbe\x9e&\xb2\xecV{9\xf54\x87\xbaz\xdaAO=\xadi\x11\x8d\xfe{\xd5\xd3\xe4&\xcc\xf3\xb8z\x1a\xf2o\xf8Hz\xffUO\x03k\x89\xc6Av\x1e\x87\x9b\x90\xf60\x87\xf1~\x84\xe7\xf6\xc7\xc8(\x05}\xc5V=\xadI\xbf\xc0\xb4\xfcj\xd7\xd3\xb0!)\xa2P\xbfw=\xedH\xe9\xd4\xd3\x9aT\xc4\x98_\xecz\x1a\xbeS\x87\xd9\xe0\xa9\xa7\xb5\xaaM|\x8a\xaez\xda\xd1\x98S%k\xe2\xbcW\xce\xb0\xebi"\x8d\xba2\xfd5\x12\xdaN+;\xf54$\x02P\xb7g=\r\tI\xea\xf4\x91\xbb\x9e\xd6\xa0\xf4\xa1\x1a\x1b\xb4z\xda\xc1|=\xed\xa0\xc7\x065\xe2\xbflp\xd9f3\xe6\xe5+jM\x88\xae\xd5\xceNE\xad\xc1IF\xd6\xb2vE\xad!\x93$\xb7:\x155X0\xacB\xebd\xae\xa2\x06W\x18\x86\xfa\xabSQ;7z*j\x07\xf3\x155\x87\xee\x8aZ\x93\xee\x01\xf6\x08\xed\x8a\x9a\xb4\x00\xdb\xeb\x86\xab\xa8I?u(\xd6sb\x155\xec<\xf2\x1eN\xfd\xa8U\xad\x1a:\xcc\xfcG\n\x8fJ\x93h7c\xd1\xa9\xa8\x1d+\xf0\x155X\x91\xf4\xd8||E\xedH\xfdT\xd4\xdcM\xb8\x8a\xda\xfb~xo]z\xdd,k8\x9c\xa2\xe3\x90\xd5^\x18\x17\xa7\x80\xdc\x84\x14}<S\x90\xf7\xb5f\xdc\xe3p\n\xa4\x0f\xa1\xe7r\x8dD\x82\x96\xd9U}8\x85\x08\xbd\x93\xa58N\xd1\xc0\\X\xa78\x9c\x02\n\x8eH\xcdJ\xd4\xe2\x14\x0es\x9c\xe2\xa0WD\x91\\p\xbe\xe2\xccF}\x1e\xd2\xa4.V\x9e}\x0fX7\xa7Uc\xd8\xecA\xbef}t\x17\x8a\xff0\xbe\xbc8E\x83\xf3\xe7K\xc5\xe1\x14M\xab\x7fd\x1c\x87S\xb4\xd9g3\xef\xb28\x05x[J\xedf\xf2\x90=\x86\xfan\xae\x9f\xbc9XTy\x8cD\xb2`}_\x8bSt(bd=\xc1q\x8a\xb76\x98\x96 D\x94\xe0\xf3b\xd5\x12\x18R\x98OY\xf7\x84\x0c\x85Ur\xc7\xfc\xa5\xe5x\xb0^\x8c\x0c_\xea?7z\xad m\xe3\xaf\xf7\xd0\x83B,Cb\xc7\xbd\xc2\xf7(\x12W\xd1\x88\'\n2\xc2\xde\x16y c]\x15v\xd6\x18g\x80\xe5I\rt/\x82n\xb6\xa1\\\x13\xbaJ\xef\t\x9bg\x95\xa4\'\xb80\xf6\x07\xc0h\x8b\xe6\xbfR\xea\x0c\xac\xe4\x8e(\xb5q\xae\x99\xe5\x89\xf4\x99\x1f\x8bOL\xe9\xc9j\xbb\xe4\x8b\xf4\x86B^,\xde\xbeo\x867\x86L\x0f\x9a\xf9|e\xef\x12\xfb\x99\xebM\xb9v\xbb\x05$\x8f\xc6\xf2o\x14\x86\xc0J\x11\xeeK\xb340\xa6X\xad\xa3\xbbX\xe7\xad\xc3\x02"Qd\xaet\xd0\xeb\x0e{\x96\xa4\xf8\xb7\xa8\x7fU\x85E\x9b\x86z\x149h`\xfe\x02\xd7\xa2o;\x86\xc2)\x8eo\xd0\xc4J\xb8\x08C#\x05\xb0d\xb5y\\;3\x0cY\x93=\x16`\x99uUA\x11eF\xb7\x17\xce\x8c\x9c\x95#A\xbc\x1a\xdf\xd9a{\xea\xffu\x1cc\x9c\xab\x7f\x1d\xf4\xda}\x94\xb7\xc5\xe7\xab\xf2A\xbdT\xde7h7\x8bl\x95\xbf*\xf2]\xb2\xa3J\x07\x05_\x85W\x97\xec\x80\xa7I\xc9w\xc4\n\x06\xa3M\xd1a\xba[\x84\xcdQ\xeeZ*\xa8c\xb2.\xc1\xdd%\x0b\x17\x86tMg\xef.\xd9\x8f\xe2\x18\xa2\xd5\xb2\xd3\';@\x9e\xa8U\xa7O\x16\xb4\x01,\x947r\xfadE\xa4\x81}Q\xbbO\x16)\xe5d\x7f\xf3\xe9\x93u\x98\xeb\x12t\xe8\xee\x93\x1d\xa9#\rcdY}\xb2\xf0k\x9d\xf7\xe9\xfbd\xa5ua\xee\x8ek\xf6\xc9Jwr}TX\x07\xb2\xf2V\x9f\xbdIC\x1b\xedo\xee$7\xd1\xba\xadh9\x84\xdcY\xb4\xbc\xf6\xf4\xc9\x82\x9c\xc2\xb4\x98\x17\xaf>\xd9\x81\xd0<\x06=\xd7\xea\x93u\x98?\xf7Aw\x9f\xac\xac\xd8y\xe3\xbbO\xf6\xad/?M\x8f\xe4\x82\xc8\xd2N\x9f\xec\x90\x18\xcf\xfc}\xf7\xc9\x0e\xf9\x15O\xbb\x7f\xb704\x83y\xfenA\xa2\x98E\xf43R\xfav\xbau\xdeZ\x9f\xec\xc8BwY\x978}\xb2\xb8\x0bX\x02\xabQ\xabOv \x9f\xb5w\xcf\xdd\'\xeb0/\x8f\x83\xee>YY\xb1\x16cCq\xed\xa7\xc2e\xf3\xfd\xf4\xf4\xc9\xca.\xad\xd3b\xf7\xc9JA\xa1Xf\xb7z_\xa1\x07\xa1\xd9[\xe3\xea\x93\xa5\x84\x1a\xb3\xc53rK\xf2t\xc9\x1e\x99\xfb.Yh\x0c\x8853\xd5\xd5%;Dy\x9a\x9d\xc6\xbad\x1d\xe6\xcf}\xd0\xdd%{V<]\xb2\xef\xfb\xa6\x1e \xa6N\xe6\xe0>R\xc8{L\x8b/\x9f4\xe5\xc7\x8dd\x82\xc8g,\xda\x0e\xa1K\xack\x83\xfa\x91\xdfI\xecH\xd1\xdeMA\xf2U\xf2Sj\xe9\xacp\x97\xb1u\x06\xf4\x9a/]\x0b\xe5\x9a\xe0\xe9\xc5t!\x17[s\xfd\xae\xa4\x08\x9b\xe5I\x85\xc5\xf0\xcd\xb6\x89\xef\xb15\x87X\xfdk\xf7b\xff\xe5Y\xa3B@\x8c\xf5U\x8d\x1aH`Y\xd9\xbeQ\xf8\x1a\xeaw(\x99\x15\x9b!\x81\x92/\xfcR\x8a\xa7\xc5\xc2\x1b\xda\xee\x13<\x9d\xb1\xdb!\xdd\xac\xd6\xad&=\x9a*\x13\xa9\xec\xb2\xa6\xd0\xc6\xf2T\xc8\x10\xa2\xf5WCG\x8cKJr\x138\xdbP\xdd\x91\xfcZEW\xca\xf2;7\xcdi\xa488\xd9\xe9\xd8\xa1x\xd4Fq\x7f\xec\xd2\xd1\x9f\xc6Z\x94\x92\xfeb\xfe\xbaV\xfa)\x07\xbf.\xbc\xc1\xba\xc6\x8c\xdd\x02\x03\x8d{\x9d\x07\x99\xba\xf5\xd4{\x19\xe1\xbebz\xcaS"l\xa3\xb7\xb2\x15\x88B\xf8\xc6_\xba\xe5 \x92\x8cR\x0e\xe7=\x151_~\xda\xc2\xb3\x8fn\x0cw\xca\xefH\x18\xcb\r\xe5\x9a\xc3~\xdb\xbc\xd8\x93b\xab\xa3V\n\xd1\xbag)IT\xd6c\xb0\xe1b5\x1e\xf9\t1\x7f\xe5\x90\xe5e_\xb3\xc0)?\xc3\xb5\xde\x9ej\xdd\x813\n\x13o\xee\x94:\x1b\xe1\xb6\xcc\xf9<\xfb\xcb\xc2\xf4\x87\xed\xfc]{\xe4\xef\xda\xf1\xbf?\x7f|\xfe\x0f-WS\x8d\nendstream\nendobj\n47 0 obj\n[ /ICCBased 48 0 R ]\nendobj\n48 0 obj\n<<\n/Filter /FlateDecode\n/N 3\n/Length 2574\n>>\nstream\nH\x89\x9c\x96yTSw\x16\xc7\x7fo\xc9\x9e\x90\x95\xb0\xc3c\r[\x80\xb0\x06\x905la\x91\x1d\x04Q\x08I\x08\x01\x12BH\xd8\x05AD\x05\x14ED\x84\xaa\x952\xd6mtFOE\x9d.\xaec\xad\x0e\xd6}\xea\xd2\x03\xf50\xea\xe88\xb4\x16\xd7\x8e\x9d\x178G\x9dNg\xa6\xd3\xef\x1f\xef\xf79\xf7w\xef\xef\xdd\xdf\xbd\xf7\x9d\xf3\x00\xa0\'\xa5\xaa\xb5\xd50\x0b\x00\x8d\xd6\xa0\xcfJ\x8c\xc5\x16\x15\x14b\xa4\t\x00\x03\n \x02\x11\x002y\xad.-;!\x07\xe0\x92\xc6K\xb0Z\xdc\t\xfc\x8b\x9e^\x07\x90i\xbd"L\xca\xc00\xf0\xff\x89-\xd7\xe9\r\x00@\x198\x07(\x94\xb5r\x9c;q\xae\xaa7\xe8L\xf6\x19\x9cy\xa5\x95&\x86Q\x13\xeb\xf1\x04q\xb64\xb1j\x9e\xbd\xe7|\xe69\xda\xc4\n\x8dV\x81\xb3)g\x9dB\xa30\xf1i\x9cW\xd7\x19\x958#\xa98w\xd5\xa9\x95\xf58_\xc5\xd9\xa5\xca\xa8Q\xe3\xfc\xdc\x14\xabQ\xcaj\x01@\xe9&\xbbA)/\xc7\xd9\x0fg\xba>\'K\x82\xf3\x02\x00\xc8t\xd5;\\\xfa\x0e\x1b\x94\r\x06\xd3\xa5$\xd5\xbaF\xbdZUn\xc0\xdc\xe5\x1e\x98(4T\x8c%)\xeb\xab\x94\x06\x830C&\xaf\x94\xe9\x15\x98\xa4Z\xa3\x93i\x1b\x01\x98\xbf\xf3\x9c8\xa6\xdabx\x91\x83E\xa1\xc1\xc1B\x7f\x1f\xd1;\x85\xfa\xaf\x9b\xbfP\xa6\xde\xce\xd3\x93\xcc\xb9\x9eA\xfc\x0bom?\xe7W=\n\x80x\x16\xaf\xcd\xfa\xb7\xb6\xd2-\x00\x8c\xaf\x04\xc0\xf2\xe6[\x9b\xcb\xfb\x000\xf1\xbe\x1d\xbe\xf8\xce}\xf8\xa6y)7\x18ta\xbe\xbe\xf5\xf5\xf5>j\xa5\xdc\xc7T\xd07\xfa\x9f\x0e\xbf@\xef\xbc\xcf\xc7t\xdc\x9b\xf2`q\xca2\x99\xb1\xca\x80\x99\xea&\xaf\xae\xaa6\xea\xb1Z\x9dL\xae\xc4\x84?\x1d\xe2_\x1d\xf8\xf3yxg)\xcb\x94z\xa5\x16\x8f\xc8\xc3\xa7L\xadU\xe1\xed\xd6*\xd4\x06u\xb5\x16Sk\xffS\x13\x7fe\xd8O4?\xd7\xb8\xb8c\xaf\x01\xaf\xd8\x07\xb0.\xf2\x00\xf2\xb7\x0b\x00\xe5\xd2\x00R\xb4\r\xdf\x81\xde\xf4-\x95\x92\x072\xf05\xdf\xe1\xde\xfc\xdc\xcf\t\xfa\xf7S\xe1>\xd3\xa3V\xad\x9a\x8b\x93d\xe5`r\xa3\xben~\xcf\xf4Y\x02\x02\xa0\x02&\xe0\x01+`\x0f\x9c\x81;\x10\x02\x7f\x10\x02\xc2A4\x88\x07\xc9 \x1d\xe4\x80\x02\xb0\x14\xc8A9\xd0\x00=\xa8\x07-\xa0\x1dt\x81\x1e\xb0\x1el\x02\xc3`;\x18\x03\xbb\xc1~p\x10\x8c\x83\x8f\xc1\t\xf0Gp\x1e|\t\xae\x81[`\x12L\x83\x87`\x06<\x05\xaf \x08"A\x0c\x88\x0bYA\x0e\x90+\xe4\x05\xf9Cb(\x12\x8a\x87R\xa1,\xa8\x00*\x81T\x90\x162B-\xd0\n\xa8\x07\xea\x87\x86\xa1\x1d\xd0n\xe8\xf7\xd0Q\xe8\x04t\x0e\xba\x04}\x05MA\x0f\xa0\xef\xa0\x970\x02\xd3a\x1el\x07\xbb\xc1\xbe\xb0\x18\x8e\x81S\xe0\x1cx\t\xac\x82k\xe0&\xb8\x13^\x07\x0f\xc1\xa3\xf0>\xf80|\x02>\x0f_\x83\'\xe1\x87\xf0,\x02\x10\x1a\xc2G\x1c\x11!"F$H:R\x88\x94!z\xa4\x15\xe9F\x06\x91Qd?r\x0c9\x8b\\A&\x91G\xc8\x0b\x94\x88rQ\x0c\x15\xa2\xe1h\x12\x9a\x8b\xca\xd1\x1a\xb4\x15\xedE\x87\xd1]\xe8a\xf44z\x05\x9dBg\xd0\xd7\x04\x06\xc1\x96\xe0E\x08#H\t\x8b\x08*B=\xa1\x8b0H\xd8I\xf8\x88p\x86p\x8d0MxJ$\x12\xf9D\x011\x84\x98D, V\x10\x9b\x89\xbd\xc4\xad\xc4\x03\xc4\xe3\xc4K\xc4\xbb\xc4Y\x12\x89dE\xf2"E\x90\xd2I2\x92\x81\xd4E\xdaB\xdaG\xfa\x8ct\x994MzN\xa6\x91\x1d\xc8\xfe\xe4\x04r!YK\xee \x0f\x92\xf7\x90?%_&\xdf#\xbf\xa2\xb0(\xae\x940J:EAi\xa4\xf4Q\xc6(\xc7(\x17)\xd3\x94WT6U@\x8d\xa0\xe6P+\xa8\xed\xd4!\xea~\xea\x19\xeam\xea\x13\x1a\x8d\xe6D\x0b\xa5e\xd2\xd4\xb4\xe5\xb4!\xda\xefh\x9f\xd3\xa6h/\xe8\x1c\xba\']B/\xa2\x1b\xe9\xeb\xe8\x1f\xd2\x8f\xd3\xbf\xa2?a0\x18n\x8chF!\xc3\xc0X\xc7\xd8\xcd8\xc5\xf8\x9a\xf1\xdc\x8ck\xe6c&5S\x98\xb5\x99\x8d\x98\x1d6\xbbl\xf6\x98Ia\xba2c\x98K\x99M\xccA\xe6!\xe6E\xe6#\x16\x85\xe5\xc6\x92\xb0d\xacV\xd6\x08\xeb(\xeb\x06k\x96\xcde\x8b\xd8\xe9l\r\xbb\x97\xbd\x87}\x8e}\x9fC\xe2\xb8q\xe29\nN\'\xe7\x03\xce)\xce].\xc2u\xe6J\xb8r\xee\n\xee\x18\xf7\x0cw\x9aG\xe4\txR^\x05\xaf\x87\xf7[\xde\x04o\xc6\x9cc\x1eh\x9eg\xde`>b\xfe\x89\xf9$\x1f\xe1\xbb\xf1\xa5\xfc*~\x1f\xff \xff:\xff\xa5\x85\x9dE\x8c\x85\xd2b\x8d\xc5~\x8b\xcb\x16\xcf,m,\xa3-\x95\x96\xdd\x96\x07,\xafY\xbe\xb4\xc2\xac\xe2\xad*\xad6X\x8d[\xdd\xb1F\xad=\xad3\xad\xeb\xad\xb7Y\x9f\xb1~d\xc3\xb3\t\xb7\x91\xdbt\xdb\x1c\xb4\xb9i\x0b\xdbz\xdaf\xd96\xdb~`{\xc1v\xd6\xce\xde.\xd1Ng\xb7\xc5\xee\x94\xdd#{\xbe}\xb4}\x85\xfd\x80\xfd\xa7\xf6\x0f\x1c\xb8\x0e\x91\x0ej\x87\x01\x87\xcf\x1c\xfe\x8a\x99c1X\x156\x84\x9d\xc6f\x1cm\x1d\x93\x1c\x8d\x8e;\x1c\'\x1c_9\t\x9cr\x9d:\x9c\x0e8\xddq\xa6:\x8b\x9d\xcb\x9c\x07\x9cO:\xcf\xb88\xb8\xa4\xb9\xb4\xb8\xecu\xb9\xe9Jq\x15\xbb\x96\xbbnv=\xeb\xfa\xccM\xe0\x96\xef\xb6\xcam\xdc\xed\xbe\xc0R \x154\t\xf6\nn\xbb3\xdc\xa3\xdck\xdcG\xdd\xafz\x10=\xc4\x1e\x95\x1e[=\xbe\xf4\x84=\x83<\xcb=G</z\xc1^\xc1^j\xaf\xad^\x97\xbc\t\xde\xa1\xdeZ\xefQ\xef\x1bB\xba0FX\'\xdc+\x9c\xf2\xe1\xfb\xa4\xfat\xf8\x8c\xfb<\xf6u\xf1-\xf4\xdd\xe0{\xd6\xf7\xb5_\x90_\x95\xdf\x98\xdf-\x11G\x94,\xea\x10\x1d\x13}\xe7\xef\xe9/\xf7\x1f\xf1\xbf\x1a\xc0\x08H\x08h\x0b8\x12\xf0m\xa0W\xa02p[\xe0\x9f\x83\xb8AiA\xab\x82N\x06\xfd#8$X\x1f\xbc?\xf8A\x88KHI\xc8{!7\xc4<q\x86\xb8W\xfcy(!46\xb4-\xf4\xe3\xd0\x17a\xc1a\x86\xb0\x83a\x7f\x0f\x17\x86W\x86\xef\t\xbf\xbf@\xb0@\xb9`l\xc1\xdd\x08\xa7\x08Y\xc4\x8e\x88\xc9H,\xb2$\xf2\xfd\xc8\xc9(\xc7(Y\xd4h\xd47\xd1\xce\xd1\x8a\xe8\x9d\xd1\xf7b<b*b\xf6\xc5<\x8e\xf5\x8b\xd5\xc7~\x14\xfbL\x12&Y&9\x1e\x87\xc4%\xc6u\xc7M\xc4s\xe2s\xe3\x87\xe3\xbfNpJP%\xecM\x98I\x0cJlN<\x9eDHJI\xda\x90tCj\'\x95KwKg\x92C\x92\x97%\x9fN\xa1\xa7d\xa7\x0c\xa7|\x93\xea\x99\xaaO=\x96\x06\xa7%\xa7mL\xbb\xbd\xd0u\xa1v\xe1x:H\x97\xa6oL\xbf\x93!\xc8\xa8\xc9\xf8C&13#s$\xf3/Y\xa2\xac\x96\xac\xb3\xd9\xdc\xec\xe2\xec=\xd9Osbs\xfarn\xe5\xba\xe7\x1asO\xe61\xf3\x8a\xf2v\xe7=\xcb\x8f\xcb\xef\xcf\x9f\\\xe4\xbbh\xd9\xa2\xf3\x05\xd6\x05\xea\x82#\x85\xa4\xc2\xbc\xc2\x9d\x85\xb3\x8b\xe3\x17oZ<]\x14T\xd4Ut}\x89`I\xc3\x92sK\xad\x97V-\xfd\xa4\x98Y,+>TB(\xc9/\xd9S\xf2\x83,]6*\x9b-\x95\x96\xbeW:#\x97\xc87\xcb\x1f*\xa2\x15\x03\x8a\x07\xca\x08e\xbf\xf2^YDY\x7f\xd9}U\x84j\xa3\xeaAyT\xf9`\xf9#\xb5D=\xac\xfe\xb6"\xa9b{\xc5\xb3\xca\xf4\xca\x0f+\x7f\xac\xca\xaf:\xa0!kJ4G\xb5\x1cm\xa5\xf6t\xb5}uC\xf5%\x9d\x97\xaeK7Y\x13V\xb3\xa9fF\x9f\xa2\xdfY\x0b\xd5.\xa9=b\xe0\xe1?S\x17\x8c\xee\xc6\x95\xc6\xa9\xba\xc8\xba\x91\xba\xe7\xf5y\xf5\x87\x1a\xd8\r\xda\x86\x0b\x8d\x9e\x8dk\x1a\xef5%4\xfd\xa6\x19m\x967\x9flqlio\x99Z\x16\xb3lG+\xd4Z\xdaz\xb2\xcd\xb9\xad\xb3mzy\xe2\xf2]\xed\xd4\xf6\xca\xf6?u\xf8u\xf4w|\xbf"\x7f\xc5\xb1N\xbb\xce\xe5\x9dwW&\xae\xdc\xdbe\xd6\xa5\xef\xba\xb1*|\xd5\xf6\xd5\xe8j\xf5\xea\x895\x01k\xb6\xacy\xdd\xad\xe8\xfe\xa2\xc7\xafg\xb0\xe7\x87^y\xef\x17kEk\x87\xd6\xfe\xb8\xael\xddD_p\xdf\xb6\xf5\xc4\xf5\xda\xf5\xd77Dm\xd8\xd5\xcf\xeeo\xea\xbf\xbb1m\xe3\xe1\x01l\xa0{\xe0\xfbM\xc5\x9b\xce\r\x06\x0en\xdfL\xddl\xdc<9\x94\xfaO\x00\xa4\x01[\xfe\x98\xb8\x99$\x99\x90\x99\xfc\x9ah\x9a\xd5\x9bB\x9b\xaf\x9c\x1c\x9c\x89\x9c\xf7\x9dd\x9d\xd2\x9e@\x9e\xae\x9f\x1d\x9f\x8b\x9f\xfa\xa0i\xa0\xd8\xa1G\xa1\xb6\xa2&\xa2\x96\xa3\x06\xa3v\xa3\xe6\xa4V\xa4\xc7\xa58\xa5\xa9\xa6\x1a\xa6\x8b\xa6\xfd\xa7n\xa7\xe0\xa8R\xa8\xc4\xa97\xa9\xa9\xaa\x1c\xaa\x8f\xab\x02\xabu\xab\xe9\xac\\\xac\xd0\xadD\xad\xb8\xae-\xae\xa1\xaf\x16\xaf\x8b\xb0\x00\xb0u\xb0\xea\xb1`\xb1\xd6\xb2K\xb2\xc2\xb38\xb3\xae\xb4%\xb4\x9c\xb5\x13\xb5\x8a\xb6\x01\xb6y\xb6\xf0\xb7h\xb7\xe0\xb8Y\xb8\xd1\xb9J\xb9\xc2\xba;\xba\xb5\xbb.\xbb\xa7\xbc!\xbc\x9b\xbd\x15\xbd\x8f\xbe\n\xbe\x84\xbe\xff\xbfz\xbf\xf5\xc0p\xc0\xec\xc1g\xc1\xe3\xc2_\xc2\xdb\xc3X\xc3\xd4\xc4Q\xc4\xce\xc5K\xc5\xc8\xc6F\xc6\xc3\xc7A\xc7\xbf\xc8=\xc8\xbc\xc9:\xc9\xb9\xca8\xca\xb7\xcb6\xcb\xb6\xcc5\xcc\xb5\xcd5\xcd\xb5\xce6\xce\xb6\xcf7\xcf\xb8\xd09\xd0\xba\xd1<\xd1\xbe\xd2?\xd2\xc1\xd3D\xd3\xc6\xd4I\xd4\xcb\xd5N\xd5\xd1\xd6U\xd6\xd8\xd7\\\xd7\xe0\xd8d\xd8\xe8\xd9l\xd9\xf1\xdav\xda\xfb\xdb\x80\xdc\x05\xdc\x8a\xdd\x10\xdd\x96\xde\x1c\xde\xa2\xdf)\xdf\xaf\xe06\xe0\xbd\xe1D\xe1\xcc\xe2S\xe2\xdb\xe3c\xe3\xeb\xe4s\xe4\xfc\xe5\x84\xe6\r\xe6\x96\xe7\x1f\xe7\xa9\xe82\xe8\xbc\xe9F\xe9\xd0\xea[\xea\xe5\xebp\xeb\xfb\xec\x86\xed\x11\xed\x9c\xee(\xee\xb4\xef@\xef\xcc\xf0X\xf0\xe5\xf1r\xf1\xff\xf2\x8c\xf3\x19\xf3\xa7\xf44\xf4\xc2\xf5P\xf5\xde\xf6m\xf6\xfb\xf7\x8a\xf8\x19\xf8\xa8\xf98\xf9\xc7\xfaW\xfa\xe7\xfbw\xfc\x07\xfc\x98\xfd)\xfd\xba\xfeK\xfe\xdc\xffm\xff\xff\x02\x0c\x00\xf7\x84\xf3\xfb\nendstream\nendobj\n49 0 obj\n<<\n/BitsPerComponent 8\n/ColorSpace /DeviceRGB\n/DecodeParms <<\n/Blend 1\n/ColorTransform 1\n/Colors 3\n/Columns 190\n/HSamples [ 1 1 1 1 ]\n/QFactor 0\n/Rows 30\n/VSamples [ 1 1 1 1 ]\n>>\n/Filter /DCTDecode\n/Height 30\n/ImageName /Adobe#20Photoshop#20CC#2020143710856222987.jpg\n/Intent /Perceptual\n/Name /Adobe#20Photoshop#20CC#2020143710856222987.jpg\n/SMask 50 0 R\n/Subtype /Image\n/Type /XObject\n/Width 190\n/Length 860\n>>\nstream\n\xff\xd8\xff\xee\x00\x0eAdobe\x00d\x00\x00\x00\x00\x01\xff\xdb\x00\xc5\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\xff\xdd\x00\x04\x00\x18\xff\xc0\x00\x11\x08\x00\x1e\x00\xbe\x03\x00\x11\x00\x01\x11\x01\x02\x11\x02\xff\xc4\x01\xa2\x00\x01\x00\x01\x01\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x01\x02\x03\x04\x05\x06\x07\t\n\x0b\x01\x01\x00\x02\x00\x06\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\t\n\x01\x02\x03\x04\x05\x06\x07\x08\x0b\x10\x00\x00\x00\x01\x00\x00NS\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a!"#$%&\'()*123456789:ABCDEFGHIJQRSTUVWXYZabcdefghijqrstuvwxyz\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\x11\x00\x00\x01\x00\x00\x00>c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a!"#$%&\'()*123456789:ABCDEFGHIJQRSTUVWXYZabcdefghijqrstuvwxyz\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xff\xda\x00\x0c\x03\x00\x00\x01\x11\x02\x11\x00?\x00\x97\x01\x11\xa2\xca \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x7f\xff\xd0\x97\x01\x11\xa2\xca \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x7f\xff\xd1\x97\x01\x11\xa2\xca \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x7f\xff\xd2\x97\x01\x11\xa2\xca \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x7f\xff\xd9\nendstream\nendobj\n50 0 obj\n<<\n/BitsPerComponent 8\n/ColorSpace /DeviceGray\n/DecodeParms <<\n/BitsPerComponent 8\n/Colors 1\n/Columns 190\n/Predictor 2\n>>\n/Filter /FlateDecode\n/Height 30\n/Matte [ 1 1 1 ]\n/Name /X\n/Subtype /Image\n/Type /XObject\n/Width 190\n/Length 61\n>>\nstream\nH\x89\xec\xce1\r\x000\x0c\xc0\xb0\xf1\xe7\xdb\x7f zX\x95b\x04\x9ew\xd9\xe8\xc0J{\xa7\xbd\xd3\xdei\xef\xb4w\xda;\xed\x9d\xf6N{\xa7\xbd\xd3\xdei\xef\xb4w\xda;_\x80\x01\x00sP\x1c\xb7\nendstream\nendobj\n51 0 obj\n<<\n/BitsPerComponent 8\n/ColorSpace /DeviceRGB\n/DecodeParms <<\n/Blend 1\n/ColorTransform 1\n/Colors 3\n/Columns 190\n/HSamples [ 1 1 1 1 ]\n/QFactor 0\n/Rows 30\n/VSamples [ 1 1 1 1 ]\n>>\n/Filter /DCTDecode\n/Height 30\n/Intent /Perceptual\n/Name /X\n/Subtype /Image\n/Type /XObject\n/Width 190\n/Length 848\n>>\nstream\n\xff\xd8\xff\xee\x00\x0eAdobe\x00d\x00\x00\x00\x00\x01\xff\xdb\x00\xc5\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\xff\xdd\x00\x04\x00\x18\xff\xc0\x00\x11\x08\x00\x1e\x00\xbe\x03\x00\x11\x00\x01\x11\x01\x02\x11\x02\xff\xc4\x01\xa2\x00\x01\x00\x01\x01\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\x01\x02\x03\x04\x05\x06\x07\x08\t\x0b\x01\x01\x00\x00\x04\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x10\x00\x00\x00\x01\x00\x00NS\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a!"#$%&\'()*123456789:ABCDEFGHIJQRSTUVWXYZabcdefghijqrstuvwxyz\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\x11\x00\x00\x01\x00\x00\x00>c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a!"#$%&\'()*123456789:ABCDEFGHIJQRSTUVWXYZabcdefghijqrstuvwxyz\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xff\xda\x00\x0c\x03\x00\x00\x01\x11\x02\x11\x00?\x00\x9f\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\xff\xd0\x9f\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\xff\xd1\x9f\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\xff\xd2\x9f\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\xff\xd9\nendstream\nendobj\n52 0 obj\n<<\n/Filter /FlateDecode\n/Length 317\n>>\nstream\nx\x9ceQKk\xc30\x0c\xfe+\xc6\xe7\xbe\x0b\xa3\x87$e+\x14\x06\x83\x95\xb6c\xc7\xa1\xc5Zj\x9a\xd8AV\xbav\xbf~r\x92v\x83^l\xf4\xbd,K\xc9\xf2\\\x95\xea\x84\x14\xacw*Uz:\x9ah\x85.\xf7\xc6\xba"\x02o\xfb\xf5p\xa1\xd52K\xde\x81\x91*\xa0\xe3\x0e\x99\x85\rW_\xaa\x17\xe2\xca\x92\x9do(\xc7\xb5-Q\xf1\xa5\xc6Tk\xe5\xa0\x92{\xd5\x10\xa1\xe3\xe7\n\n\xd4\xe3,y\xf2d\x90\xc4\xc0\xe4\x8f\xa8\x0c\x84\xc3\x06X\xd2]\xf4|[\xc3\x87TO\xa3r|\x93\xe6 \xb1\'(\x1b\xc9\x9b\x8c\xe6\x91\xdcz\x06\x8e}_\xe1\x08\xbe\xd6\x90[\xbe\\\xb16\xe5\xc5\xe7\x9d\xd0;\xf6u\x0f\xae|\xe9IQ\xb4\xa9\xa2=?\xfb\x88\xc7\xd2\x16\xae\x92\x86U\xe3,\xa7\xfaA\xab\x83\'\xfbs{&~\x9c\xfbj8_\xf44D[\xaag\x1d\xddW]`]#\x10\xb8\x1c\xd5\x97=\xa3\xa9\xc9:n\x83\xbc\x0b9!\xba\xd8\x93\x14=\xd1\xf6\xb7\x91am\xc1\x15(\xeb0\xf2N\x14\x18\xd3\n\xf1\xd4;\x02\x03q\xc7\xd5"\x0f\x929\x98\x0ef\xd1\xbe\x975\x84\xbf\xc9\xa8\xf3G`\x8c\x7f\x9fHq\xf9W\xc4)\xdf\xad6\xfb\x05.\xca\xaai\nendstream\nendobj\n53 0 obj\n<<\n/Type /Pages\n/Count 1\n/Kids [ 13 0 R ]\n>>\nendobj\n54 0 obj\n<<\n/Type /Annot\n/Subtype /Widget\n/Rect [ 107.5 688 319.5 765 ]\n/AP <<\n/N 55 0 R\n>>\n/DA (\\057Helv 0 Tf 0 g)\n/F 4\n/FT /Sig\n/H /N\n/MK <<\n/BC [ 0 0 0 ]\n>>\n/P 56 0 R\n/TM (form\\1370\\1370)\n/T (signature)\n/Q 0\n>>\nendobj\n55 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/BBox [ 0 0 212 77 ]\n/Filter /FlateDecode\n/Length 55\n>>\nstream\nx\x9c3Pp\xe72T(\xe724P\xf0\xe5\xd23U\x00"#CC\x05s3\x85\xa2T\xaeb\xaeB\xa0\xa4!P\xc4@\xc1\xdc\x14$\x12\xae\x90\xc7\x15\xc8\x05\x00\x10\x02\nx\nendstream\nendobj\n56 0 obj\n<<\n/Type /Page\n/Contents 57 0 R\n/MediaBox [ 0 0 595 842 ]\n/Annots [ 54 0 R ]\n/Resources <<\n/XObject <<\n/TLToROQahC 58 0 R\n>>\n>>\n/Parent 59 0 R\n>>\nendobj\n57 0 obj\n<<\n/Filter /FlateDecode\n/Length 36\n>>\nstream\nx\x9c+\xe42T0\x00B\x08\x99\x9c\xcb\xa5\x1f\xe2\x13\x92\x1f\xe4\x1f\x98\x98\xe1\xac\xe0\x92\xcf\x15\xc8\x05\x00\x81\x9c\x08\x00\nendstream\nendobj\n58 0 obj\n<<\n/Type /XObject\n/Subtype /Form\n/BBox [ 0 0 595 842 ]\n/Length 1\n>>\nstream\n\n\nendstream\nendobj\n59 0 obj\n<<\n/Type /Pages\n/Count 1\n/Kids [ 56 0 R ]\n>>\nendobj\nxref\n0 60\n0000000000 65535 f \n0000000015 00000 n \n0000000054 00000 n \n0000000113 00000 n \n0000000178 00000 n \n0000000368 00000 n \n0000000449 00000 n \n0000000470 00000 n \n0000000839 00000 n \n0000000866 00000 n \n0000000917 00000 n \n0000001188 00000 n \n0000001459 00000 n \n0000001730 00000 n \n0000002115 00000 n \n0000002162 00000 n \n0000002332 00000 n \n0000002584 00000 n \n0000002851 00000 n \n0000003218 00000 n \n0000003304 00000 n \n0000003553 00000 n \n0000003916 00000 n \n0000004288 00000 n \n0000004320 00000 n \n0000004493 00000 n \n0000004535 00000 n \n0000004563 00000 n \n0000005042 00000 n \n0000005099 00000 n \n0000005156 00000 n \n0000005337 00000 n \n0000005592 00000 n \n0000033784 00000 n \n0000033936 00000 n \n0000034552 00000 n \n0000034882 00000 n \n0000035019 00000 n \n0000035118 00000 n \n0000035152 00000 n \n0000035248 00000 n \n0000039025 00000 n \n0000039095 00000 n \n0000039218 00000 n \n0000039291 00000 n \n0000039679 00000 n \n0000040294 00000 n \n0000046224 00000 n \n0000046261 00000 n \n0000048914 00000 n \n0000050221 00000 n \n0000050552 00000 n \n0000051729 00000 n \n0000052119 00000 n \n0000052180 00000 n \n0000052401 00000 n \n0000052579 00000 n \n0000052741 00000 n \n0000052849 00000 n \n0000052952 00000 n \ntrailer\n<<\n/Size 60\n/Root 3 0 R\n/Info 1 0 R\n>>\nstartxref\n53013\n%%EOF\n'

### PyPDFForm/widgets/checkbox.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines the `CheckBoxField` and `CheckBoxWidget` classes, which are
used to represent and manipulate checkbox form fields within PDF documents.

The `CheckBoxField` class is a dataclass that encapsulates the properties of a
checkbox field, such as its size, style, and colors.

The `CheckBoxWidget` class extends the base `Widget` class to provide specific
functionality for interacting with checkbox form fields in PDFs.
"""

from dataclasses import dataclass
from typing import Optional, Tuple

from .base import Field, Widget


class CheckBoxWidget(Widget):
    """
    Represents a checkbox widget in a PDF form.

    Inherits from the base Widget class and adds specific parameters for
    checkbox styling, such as button style, tick color, background color,
    border color, and border width.

    Attributes:
        USER_PARAMS (list): A list of tuples, where each tuple contains the
            user-facing parameter name and the corresponding AcroForm parameter name.
        COLOR_PARAMS (list): A list of user-facing parameter names that represent colors.
        ALLOWED_HOOK_PARAMS (list): A list of allowed hook parameters.
        ACRO_FORM_FUNC (str): The name of the AcroForm function to use for
            creating the checkbox.
    """

    USER_PARAMS = [
        ("required", "required"),
        ("tooltip", "tooltip"),
        ("button_style", "buttonStyle"),
        ("tick_color", "textColor"),
        ("bg_color", "fillColor"),
        ("border_color", "borderColor"),
        ("border_width", "borderWidth"),
    ]
    COLOR_PARAMS = ["tick_color", "bg_color", "border_color"]
    ALLOWED_HOOK_PARAMS = ["size"]
    ACRO_FORM_FUNC = "checkbox"


@dataclass
class CheckBoxField(Field):
    """
    Represents a checkbox field in a PDF document.

    This dataclass extends the `Field` base class and defines the specific
    attributes that can be configured for a checkbox field.

    Attributes:
        _field_type (str): The type of the field, fixed as "checkbox".
        size (Optional[float]): The size of the checkbox.
        button_style (Optional[str]): The visual style of the checkbox button
            (e.g., "check", "circle", "cross").
        tick_color (Optional[Tuple[float, ...]]): The color of the checkmark or tick.
        bg_color (Optional[Tuple[float, ...]]): The background color of the checkbox.
        border_color (Optional[Tuple[float, ...]]): The color of the checkbox's border.
        border_width (Optional[float]): The width of the checkbox's border.
    """

    _field_type: str = "checkbox"

    size: Optional[float] = None
    button_style: Optional[str] = None
    tick_color: Optional[Tuple[float, ...]] = None
    bg_color: Optional[Tuple[float, ...]] = None
    border_color: Optional[Tuple[float, ...]] = None
    border_width: Optional[float] = None

### PyPDFForm/widgets/dropdown.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines the `DropdownField` and `DropdownWidget` classes, which are
used to represent and manipulate dropdown form fields within PDF documents.

The `DropdownField` class is a dataclass that encapsulates the properties of a
dropdown field, such as its options, dimensions, and styling.

The `DropdownWidget` class extends the base `TextWidget` class to provide
specific functionality for interacting with dropdown form fields in PDFs.
"""

from dataclasses import dataclass
from typing import List, Optional, Tuple, Union

from .base import Field
from .text import TextWidget


class DropdownWidget(TextWidget):
    """
    Represents a dropdown widget in a PDF form.

    Inherits from the base TextWidget class and adds specific parameters for
    dropdown styling, such as options.

    Attributes:
        NONE_DEFAULTS (list): A list of parameters that default to None.
        ACRO_FORM_FUNC (str): The name of the AcroForm function to use for
            creating the dropdown.
    """

    NONE_DEFAULTS = []
    ACRO_FORM_FUNC = "_textfield"

    def __init__(
        self,
        name: str,
        page_number: int,
        x: float,
        y: float,
        **kwargs,
    ) -> None:
        """
        Initializes a DropdownWidget object.

        Args:
            name (str): Name of the widget.
            page_number (int): Page number of the widget.
            x (float): X coordinate of the widget.
            y (float): Y coordinate of the widget.
            **kwargs: Additional keyword arguments.
        """
        self.USER_PARAMS = super().USER_PARAMS[:-1] + [
            ("options", "options"),
        ]
        super().__init__(name, page_number, x, y, **kwargs)
        self.acro_form_params["wkind"] = "choice"
        self.acro_form_params["value"] = self.acro_form_params["options"][0]


@dataclass
class DropdownField(Field):
    """
    Represents a dropdown field in a PDF document.

    This dataclass extends the `Field` base class and defines the specific
    attributes that can be configured for a dropdown selection field.

    Attributes:
        _field_type (str): The type of the field, fixed as "dropdown".
        options (Optional[List[Union[str, Tuple[str, str]]]]): A list of options
            available in the dropdown. Each option can be a string (display value)
            or a tuple of strings (display value, export value).
        width (Optional[float]): The width of the dropdown field.
        height (Optional[float]): The height of the dropdown field.
        font (Optional[str]): The font to use for the dropdown text.
        font_size (Optional[float]): The font size for the dropdown text.
        font_color (Optional[Tuple[float, ...]]): The color of the font as an RGB or RGBA tuple.
        bg_color (Optional[Tuple[float, ...]]): The background color of the dropdown field.
        border_color (Optional[Tuple[float, ...]]): The color of the dropdown's border.
        border_width (Optional[float]): The width of the dropdown's border.
    """

    _field_type: str = "dropdown"

    options: Optional[List[Union[str, Tuple[str, str]]]] = None
    width: Optional[float] = None
    height: Optional[float] = None
    # pylint: disable=R0801
    font: Optional[str] = None
    font_size: Optional[float] = None
    font_color: Optional[Tuple[float, ...]] = None
    bg_color: Optional[Tuple[float, ...]] = None
    border_color: Optional[Tuple[float, ...]] = None
    border_width: Optional[float] = None

### PyPDFForm/widgets/image.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines the `ImageField` and `ImageWidget` classes, which are used
to represent and manipulate image form fields within PDF documents.

The `ImageField` class is a dataclass that encapsulates the properties of an
image field, inheriting from `SignatureField` for its dimensional attributes.

The `ImageWidget` class extends the base `SignatureWidget` class to provide
specific functionality for interacting with image form fields in PDFs,
leveraging the existing infrastructure for positioning and rendering.
"""

from dataclasses import dataclass

from .signature import SignatureField, SignatureWidget


class ImageWidget(SignatureWidget):
    """
    Represents an image widget in a PDF form.

    This class inherits from the SignatureWidget and is specifically designed
    for handling image fields in PDF forms. It reuses the signature widget's
    infrastructure for positioning and rendering, but instead of capturing
    a signature, it inserts a provided image.

    Attributes:
        BEDROCK_WIDGET_TO_COPY (str): The name of the bedrock widget to copy,
            set to "image".
    """

    BEDROCK_WIDGET_TO_COPY = "image"


@dataclass
class ImageField(SignatureField):
    """
    Represents an image field in a PDF document.

    This dataclass extends the `SignatureField` base class and defines the
    specific attributes for an image input field. It inherits `width` and
    `height` from `SignatureField` as images also have dimensions.

    Attributes:
        _field_type (str): The type of the field, fixed as "image".
    """

    _field_type: str = "image"

### PyPDFForm/widgets/radio.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines the `RadioGroup` and `RadioWidget` classes, which are used
to represent and manipulate radio button groups within PDF documents.

The `RadioGroup` class is a dataclass that encapsulates the properties of a
radio button group, such as its coordinates and shape.

The `RadioWidget` class extends the base `CheckBoxWidget` class to provide
specific functionality for interacting with radio button form fields in PDFs.
"""

from dataclasses import dataclass
from typing import List, Optional

from reportlab.pdfgen.canvas import Canvas

from .checkbox import CheckBoxField, CheckBoxWidget


class RadioWidget(CheckBoxWidget):
    """
    Represents a radio button widget in a PDF form.

    This class inherits from the CheckBoxWidget and is designed for handling
    radio button fields in PDF forms. Radio buttons allow the user to select
    only one option from a predefined set of choices.

    Attributes:
        ACRO_FORM_FUNC (str): The name of the AcroForm function to use for
            creating the radio button, set to "radio".
    """

    ACRO_FORM_FUNC = "radio"

    def __init__(
        self,
        name: str,
        page_number: int,
        x: List[float],
        y: List[float],
        **kwargs,
    ) -> None:
        """
        Initializes a RadioWidget object.

        Args:
            name (str): Name of the widget.
            page_number (int): Page number of the widget.
            x (List[float]): List of X coordinates for each radio button.
            y (List[float]): List of Y coordinates for each radio button.
            **kwargs: Additional keyword arguments.
        """
        self.USER_PARAMS.append(("shape", "shape"))
        super().__init__(name, page_number, x, y, **kwargs)

    def canvas_operations(self, canvas: Canvas) -> None:
        """
        Performs canvas operations for the radio button widget.

        This method iterates through the X and Y coordinates of each radio button
        and draws it on the PDF canvas. It also sets the value of the radio button
        based on its index in the list of coordinates.

        Args:
            canvas (Canvas): Canvas object to operate on.
        """
        for i, x in enumerate(self.acro_form_params["x"]):
            y = self.acro_form_params["y"][i]
            new_acro_form_params = self.acro_form_params.copy()
            new_acro_form_params["x"] = x
            new_acro_form_params["y"] = y
            new_acro_form_params["value"] = str(i)
            getattr(canvas.acroForm, self.ACRO_FORM_FUNC)(**new_acro_form_params)


@dataclass
class RadioGroup(CheckBoxField):
    """
    Represents a group of radio buttons in a PDF document.

    This dataclass extends the `CheckBoxField` base class and defines the specific
    attributes that can be configured for a radio button group. Unlike a single
    checkbox, a radio group allows for multiple positions (x, y coordinates)
    where individual radio buttons can be placed, but only one can be selected.

    Attributes:
        _field_type (str): The type of the field, fixed as "radio".
        x (List[float]): A list of x-coordinates for each radio button in the group.
        y (List[float]): A list of y-coordinates for each radio button in the group.
        shape (Optional[str]): The shape of the radio button. Valid values are
            "circle" or "square". Defaults to None, which typically means a default circle shape.
    """

    _field_type: str = "radio"

    x: List[float]
    y: List[float]
    shape: Optional[str] = None

### PyPDFForm/widgets/signature.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines the `SignatureField` and `SignatureWidget` classes, which are
used to represent and manipulate signature form fields within PDF documents.

The `SignatureField` class is a dataclass that encapsulates the properties of a
signature field, such as its dimensions.

The `SignatureWidget` class provides specific functionality for interacting with
signature form fields in PDFs, including handling their creation, rendering, and
integration into the document.
"""

from dataclasses import dataclass
from io import BytesIO
from typing import List, Optional

from pypdf import PdfReader, PdfWriter
from pypdf.generic import (ArrayObject, FloatObject, NameObject,
                           TextStringObject)

from ..constants import Annots, Rect, T
from ..template import get_widget_key
from ..utils import stream_to_io
from .base import Field
from .bedrock import BEDROCK_PDF


class SignatureWidget:
    """
    Represents a signature widget in a PDF form.

    This class is responsible for handling the creation, rendering, and
    integration of signature fields in a PDF document. It inherits from
    the base Widget class and provides specific functionality for handling
    signatures.

    Attributes:
        OPTIONAL_PARAMS (list): A list of tuples, where each tuple contains the
            parameter name and its default value.
        ALLOWED_HOOK_PARAMS (list): A list of parameter names that can be
            used as hooks to trigger dynamic modifications.
        BEDROCK_WIDGET_TO_COPY (str): The name of the bedrock widget to copy.
    """

    OPTIONAL_PARAMS = [
        ("width", 160),
        ("height", 90),
    ]
    ALLOWED_HOOK_PARAMS = ["required", "tooltip"]
    BEDROCK_WIDGET_TO_COPY = "signature"

    def __init__(
        self,
        name: str,
        page_number: int,
        x: float,
        y: float,
        **kwargs,
    ) -> None:
        """
        Initializes a SignatureWidget object.

        Args:
            name (str): The name of the signature widget.
            page_number (int): The page number of the signature widget.
            x (float): The x coordinate of the signature widget.
            y (float): The y coordinate of the signature widget.
            **kwargs: Additional keyword arguments.
        """
        super().__init__()
        self.hook_params = []

        self.page_number = page_number
        self.name = name
        self.x = x
        self.y = y
        self.optional_params = {
            each[0]: kwargs.get(each[0], each[1]) for each in self.OPTIONAL_PARAMS
        }
        for each in self.ALLOWED_HOOK_PARAMS:
            if each in kwargs:
                self.hook_params.append((each, kwargs.get(each)))

    def watermarks(self, stream: bytes) -> List[bytes]:
        """
        Generates watermarks for the signature widget.

        This method takes a PDF stream as input, reads a "bedrock" PDF, and
        creates a new PDF with the signature widget added as a watermark on the
        specified page. The signature's name and rectangle are then added to the
        new PDF.

        Args:
            stream (bytes): The PDF stream.

        Returns:
            List[bytes]: A list of watermarks for the signature widget. Each
            element in the list represents a page in the PDF. If the current
            page matches the signature's page number, the corresponding element
            will contain the watermark data. Otherwise, the element will be an
            empty byte string.
        """
        input_pdf = PdfReader(stream_to_io(stream))
        page_count = len(input_pdf.pages)
        pdf = PdfReader(stream_to_io(BEDROCK_PDF))
        out = PdfWriter()
        out.append(pdf)

        for page in out.pages:
            for annot in page.get(Annots, []):
                key = get_widget_key(annot.get_object(), False)

                if key != self.BEDROCK_WIDGET_TO_COPY:
                    continue

                annot.get_object()[NameObject(T)] = TextStringObject(self.name)
                annot.get_object()[NameObject(Rect)] = ArrayObject(
                    [
                        FloatObject(self.x),
                        FloatObject(self.y),
                        FloatObject(self.x + self.optional_params.get("width")),
                        FloatObject(self.y + self.optional_params.get("height")),
                    ]
                )

        with BytesIO() as f:
            out.write(f)
            f.seek(0)
            return [
                f.read() if i == self.page_number - 1 else b""
                for i in range(page_count)
            ]


@dataclass
class SignatureField(Field):
    """
    Represents a signature field in a PDF document.

    This dataclass extends the `Field` base class and defines the specific
    attributes that can be configured for a signature input field.

    Attributes:
        _field_type (str): The type of the field, fixed as "signature".
        width (Optional[float]): The width of the signature field.
        height (Optional[float]): The height of the signature field.
    """

    _field_type: str = "signature"

    width: Optional[float] = None
    height: Optional[float] = None

### PyPDFForm/widgets/text.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""
This module defines the `TextField` and `TextWidget` classes, which are used to
represent and manipulate text fields within PDF documents.

The `TextField` class is a dataclass that encapsulates the properties of a text
field, such as its dimensions, styling, and behavior.

The `TextWidget` class extends the base `Widget` class to provide specific
functionality for interacting with text form fields in PDFs.
"""

from dataclasses import dataclass
from typing import Optional, Tuple

from .base import Field, Widget


class TextWidget(Widget):
    """
    Represents a text widget in a PDF form.

    This class inherits from the base Widget class and provides specific
    parameters for text field styling, such as width, height, font size,
    font color, background color, border color, border width, and maximum
    length.

    Attributes:
        USER_PARAMS (list): A list of tuples, where each tuple contains the
            user-facing parameter name and the corresponding AcroForm parameter name.
        COLOR_PARAMS (list): A list of user-facing parameter names that represent colors.
        ALLOWED_HOOK_PARAMS (list): A list of allowed hook parameters.
        NONE_DEFAULTS (list): A list of parameters that default to None.
        ACRO_FORM_FUNC (str): The name of the AcroForm function to use for
            creating the text field.
    """

    USER_PARAMS = [
        ("required", "required"),
        ("tooltip", "tooltip"),
        ("width", "width"),
        ("height", "height"),
        ("font_size", "fontSize"),
        ("font_color", "textColor"),
        ("bg_color", "fillColor"),
        ("border_color", "borderColor"),
        ("border_width", "borderWidth"),
        ("max_length", "maxlen"),
    ]
    COLOR_PARAMS = ["font_color", "bg_color", "border_color"]
    ALLOWED_HOOK_PARAMS = ["alignment", "multiline", "comb", "font"]
    NONE_DEFAULTS = ["max_length"]
    ACRO_FORM_FUNC = "textfield"


@dataclass
class TextField(Field):
    """
    Represents a text field in a PDF document.

    This dataclass extends the `Field` base class and defines the specific
    attributes that can be configured for a text input field.

    Attributes:
        _field_type (str): The type of the field, fixed as "text".
        width (Optional[float]): The width of the text field.
        height (Optional[float]): The height of the text field.
        max_length (Optional[int]): The maximum number of characters allowed in the text field.
        comb (Optional[bool]): If True, the text field will display characters
            individually in a row of boxes.
        font (Optional[str]): The font to use for the text field.
        font_size (Optional[float]): The font size for the text.
        font_color (Optional[Tuple[float, ...]]): The color of the font as an RGB or RGBA tuple.
        bg_color (Optional[Tuple[float, ...]]): The background color of the text field.
        border_color (Optional[Tuple[float, ...]]): The color of the text field's border.
        border_width (Optional[float]): The width of the text field's border.
        alignment (Optional[int]): The text alignment within the field (e.g., 0 for left, 1 for center, 2 for right).
        multiline (Optional[bool]): If True, the text field can display multiple lines of text.
    """

    _field_type: str = "text"

    width: Optional[float] = None
    height: Optional[float] = None
    max_length: Optional[int] = None
    comb: Optional[bool] = None
    font: Optional[str] = None
    font_size: Optional[float] = None
    font_color: Optional[Tuple[float, ...]] = None
    bg_color: Optional[Tuple[float, ...]] = None
    border_color: Optional[Tuple[float, ...]] = None
    border_width: Optional[float] = None
    alignment: Optional[int] = None
    multiline: Optional[bool] = None

### PyPDFForm/wrapper.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-
"""
A module for wrapping PDF form operations, providing a high-level interface
for filling, creating, and manipulating PDF forms.

This module simplifies common tasks such as:
- Filling PDF forms with data from a dictionary.
- Creating new form fields (widgets) on a PDF.
- Drawing text and images onto a PDF.
- Registering custom fonts for use in form fields.
- Merging multiple PDF forms.

The core class, `PdfWrapper`, encapsulates a PDF document and provides
methods for interacting with its form fields and content. It leverages
lower-level modules within the `PyPDFForm` library to handle the
underlying PDF manipulation.
"""

from __future__ import annotations

from dataclasses import asdict
from functools import cached_property
from typing import TYPE_CHECKING, BinaryIO, Dict, List, Sequence, Tuple, Union
from warnings import warn

from .adapter import fp_or_f_obj_or_stream_to_stream
from .constants import (DEFAULT_FONT, DEFAULT_FONT_COLOR, DEFAULT_FONT_SIZE,
                        DEPRECATION_NOTICE, VERSION_IDENTIFIER_PREFIX,
                        VERSION_IDENTIFIERS)
from .coordinate import generate_coordinate_grid
from .filler import fill
from .font import (get_all_available_fonts, register_font,
                   register_font_acroform)
from .hooks import trigger_widget_hooks
from .image import rotate_image
from .middleware.dropdown import Dropdown
from .middleware.signature import Signature
from .middleware.text import Text
from .template import build_widgets, update_widget_keys
from .utils import (enable_adobe_mode, generate_unique_suffix,
                    get_page_streams, merge_two_pdfs, remove_all_widgets)
from .watermark import (copy_watermark_widgets, create_watermarks_and_draw,
                        merge_watermarks_with_pdf)
from .widgets.checkbox import CheckBoxWidget
from .widgets.dropdown import DropdownWidget
from .widgets.image import ImageWidget
from .widgets.radio import RadioWidget
from .widgets.signature import SignatureWidget
from .widgets.text import TextWidget

if TYPE_CHECKING:
    from .widgets import FieldTypes


class PdfWrapper:

### PyPDFForm/wrapper.py [2/2] (lang=Python)


from .widgets.signature import SignatureWidget
from .widgets.text import TextWidget

if TYPE_CHECKING:
    from .widgets import FieldTypes


class PdfWrapper:
    """
    A class to wrap PDF form operations, providing a simplified interface
    for common tasks such as filling, creating, and manipulating PDF forms.

    The `PdfWrapper` class encapsulates a PDF document and provides methods
    for interacting with its form fields (widgets) and content. It leverages
    lower-level modules within the `PyPDFForm` library to handle the
    underlying PDF manipulation.

    Attributes:
        USER_PARAMS (list): A list of user-configurable parameters and their default values.
            These parameters can be set during initialization using keyword arguments.
            Current parameters include:
                - `use_full_widget_name` (bool): Whether to use the full widget name when filling the form.
                - `adobe_mode` (bool): Whether to enable Adobe-specific compatibility mode.

    """

    USER_PARAMS = [
        ("use_full_widget_name", False),
        ("adobe_mode", False),
    ]

    def __init__(
        self,
        template: Union[bytes, str, BinaryIO] = b"",
        **kwargs,
    ) -> None:
        """
        Constructor method for the `PdfWrapper` class.

        Initializes a new `PdfWrapper` object with the given template PDF and optional keyword arguments.

        Args:
            template (Union[bytes, str, BinaryIO]): The template PDF, provided as either:
                - bytes: The raw PDF data as a byte string.
                - str: The file path to the PDF.
                - BinaryIO: An open file-like object containing the PDF data.
                Defaults to an empty byte string (b""), which creates a blank PDF.
            **kwargs: Additional keyword arguments to configure the `PdfWrapper`.
                These arguments are used to set the user-configurable parameters defined in `USER_PARAMS`.
                For example: `use_full_widget_name=True` or `adobe_mode=False`.
        """

        super().__init__()
        self._stream = fp_or_f_obj_or_stream_to_stream(template)
        self.widgets = {}
        self._available_fonts = {}  # for setting /F1
        self._font_register_events = []  # for reregister
        self._key_update_tracker = {}  # for update key preserve old key attrs
        self._keys_to_update = []  # for bulk update keys

        # sets attrs from kwargs
        for attr, default in self.USER_PARAMS:
            setattr(self, attr, kwargs.get(attr, default))

        self._init_helper()

    def __add__(self, other: PdfWrapper) -> PdfWrapper:
        """
        Merges two PDF wrappers together, creating a new `PdfWrapper` containing the combined content.

        This method allows you to combine two PDF forms into a single form.  It handles potential
        naming conflicts between form fields by adding a unique suffix to the field names in the second form.

        Args:
            other (PdfWrapper): The other `PdfWrapper` object to merge with.

        Returns:
            PdfWrapper: A new `PdfWrapper` object containing the merged PDFs.
        """

        if not self.read():
            return other

        if not other.read():
            return self

        unique_suffix = generate_unique_suffix()
        for k in self.widgets:
            if k in other.widgets:
                other.update_widget_key(k, f"{k}-{unique_suffix}", defer=True)

        other.commit_widget_key_updates()

        # user params are based on the first object
        result = self.__class__(
            merge_two_pdfs(self.read(), other.read()),
            **{each[0]: getattr(self, each[0], each[1]) for each in self.USER_PARAMS},
        )

        # inherit fonts
        for event in self._font_register_events:
            result.register_font(event[0], event[1])

        return result

    def _init_helper(self) -> None:
        """
        Helper method to initialize widgets and available fonts.

        This method is called during initialization and after certain operations
        that modify the PDF content (e.g., filling, creating widgets, updating keys).
        It rebuilds the widget dictionary and updates the available fonts.
        """

        new_widgets = (
            build_widgets(
                self.read(),
                getattr(self, "use_full_widget_name"),
            )
            if self.read()
            else {}
        )
        # ensure old widgets don't get overwritten
        for k, v in self.widgets.items():
            if k in new_widgets:
                new_widgets[k] = v

        # update key preserve old key attrs
        for k, v in new_widgets.items():
            if k in self._key_update_tracker:
                for name, value in self.widgets[
                    self._key_update_tracker[k]
                ].__dict__.items():
                    if not name.startswith("_"):
                        setattr(v, name, value)
        self._key_update_tracker = {}

        self.widgets = new_widgets

        if self.read():
            self._available_fonts.update(**get_all_available_fonts(self.read()))

    def _reregister_font(self) -> PdfWrapper:
        """
        Reregisters fonts after PDF content modifications.

        This method is called after operations that modify the PDF content
        (e.g., drawing text, drawing images) to ensure that custom fonts
        are correctly registered and available for use.
        """

        font_register_events_len = len(self._font_register_events)
        for i in range(font_register_events_len):
            event = self._font_register_events[i]
            self.register_font(event[0], event[1], False)
        self._font_register_events = self._font_register_events[
            font_register_events_len:
        ]

        return self

    @property
    def schema(self) -> dict:
        """
        Returns the JSON schema of the PDF form, describing the structure and data types of the form fields.

        This schema can be used to generate user interfaces or validate data before filling the form.

        Returns:
            dict: A dictionary representing the JSON schema of the PDF form.
        """

        return {
            "type": "object",
            "properties": {
                key: value.schema_definition for key, value in self.widgets.items()
            },
        }

    @property
    def data(self) -> dict:
        """
        Returns a dictionary of the current data in the PDF form fields.

        The keys of the dictionary are the form field names, and the values are
        the current values of those fields. This property provides a convenient
        way to extract all filled data from the PDF.

        Returns:
            dict: A dictionary where keys are form field names (str) and values are
                  their corresponding data (Union[str, bool, int, None]).
        """

        return {key: value.value for key, value in self.widgets.items()}

    @property
    def sample_data(self) -> dict:
        """
        Returns sample data for the PDF form, providing example values for each form field.

        This sample data can be used for testing or demonstration purposes.

        Returns:
            dict: A dictionary containing sample data for the PDF form.
        """

        return {key: value.sample_value for key, value in self.widgets.items()}

    @property
    def version(self) -> Union[str, None]:
        """
        Returns the PDF version of the underlying PDF document.

        Returns:
            Union[str, None]: The PDF version as a string, or None if the version cannot be determined.
        """

        for each in VERSION_IDENTIFIERS:
            if self.read().startswith(each):
                return each.replace(VERSION_IDENTIFIER_PREFIX, b"").decode()

        return None

    @property
    def fonts(self) -> list:
        """
        Returns a list of the names of the currently registered fonts.

        Returns:
            list: A list of font names (str).
        """

        return list(self._available_fonts.keys())

    @cached_property
    def pages(self) -> Sequence[PdfWrapper]:
        """
        Returns a sequence of `PdfWrapper` objects, each representing a single page in the PDF document.

        This allows you to work with individual pages of the PDF, for example, to extract text or images from a specific page.

        Returns:
            Sequence[PdfWrapper]: A sequence of `PdfWrapper` objects, one for each page in the PDF.
        """

        result = [
            self.__class__(
                copy_watermark_widgets(each, self.read(), None, i),
                **{param: getattr(self, param) for param, _ in self.USER_PARAMS},
            )
            for i, each in enumerate(get_page_streams(remove_all_widgets(self.read())))
        ]

        # because copy_watermark_widgets and remove_all_widgets
        if self._font_register_events:
            for event in self._font_register_events:
                for page in result:
                    page.register_font(event[0], event[1])

        return result

    def read(self) -> bytes:
        """
        Reads the PDF content from the underlying stream.

        This method returns the current state of the PDF as a byte string.
        It also triggers any pending widget hooks and applies Adobe mode if enabled.

        Returns:
            bytes: The PDF content as bytes.
        """

        if any(widget.hooks_to_trigger for widget in self.widgets.values()):
            for widget in self.widgets.values():
                if (
                    isinstance(widget, (Text, Dropdown))
                    and widget.font not in self._available_fonts.values()
                    and widget.font in self._available_fonts
                ):
                    widget.font = self._available_fonts.get(
                        widget.font
                    )  # from `new_font` to `/F1`

            self._stream = trigger_widget_hooks(
                self._stream,
                self.widgets,
                getattr(self, "use_full_widget_name"),
            )

        if getattr(self, "adobe_mode") and self._stream:
            self._stream = enable_adobe_mode(self._stream)  # cached

        return self._stream

    def write(self, path: str) -> PdfWrapper:
        """
        Writes the PDF content to a file.

        Args:
            path (str): The file path to write the PDF to.

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        with open(path, "wb+") as f:
            f.write(self.read())

        return self

    def change_version(self, version: str) -> PdfWrapper:
        """
        Changes the PDF version of the underlying document.

        Args:
            version (str): The new PDF version string (e.g., "1.7").

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        self._stream = self.read().replace(
            VERSION_IDENTIFIER_PREFIX + bytes(self.version, "utf-8"),
            VERSION_IDENTIFIER_PREFIX + bytes(version, "utf-8"),
            1,
        )

        return self

    def generate_coordinate_grid(
        self, color: Tuple[float, float, float] = (1, 0, 0), margin: float = 100
    ) -> PdfWrapper:
        """
        Generates a coordinate grid on the PDF, useful for debugging layout issues.

        Args:
            color (Tuple[float, float, float]): The color of the grid lines, specified as an RGB tuple (default: red).
            margin (float): The margin around the grid, in points (default: 100).

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        stream_with_widgets = self.read()
        self._stream = copy_watermark_widgets(
            generate_coordinate_grid(
                remove_all_widgets(self.read()),
                color,
                margin,
            ),
            stream_with_widgets,
            None,
            None,
        )
        # because copy_watermark_widgets and remove_all_widgets
        self._reregister_font()

        return self

    def fill(
        self,
        data: Dict[str, Union[str, bool, int]],
        **kwargs,
    ) -> PdfWrapper:
        """
        Fills the PDF form with data from a dictionary.

        Args:
            data (Dict[str, Union[str, bool, int]]): A dictionary where keys are form field names
                and values are the data to fill the fields with.  Values can be strings, booleans, or integers.
            **kwargs: Additional keyword arguments:
                - `flatten` (bool): Whether to flatten the form after filling, making the fields read-only (default: False).

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        for key, value in data.items():
            if key in self.widgets:
                self.widgets[key].value = value

        filled_stream, image_drawn_stream = fill(
            self.read(),
            self.widgets,
            use_full_widget_name=getattr(self, "use_full_widget_name"),
            flatten=kwargs.get("flatten", False),
        )

        if image_drawn_stream is not None:
            keys_to_copy = [
                k for k, v in self.widgets.items() if not isinstance(v, Signature)
            ]  # only copy non-image fields
            filled_stream = copy_watermark_widgets(
                remove_all_widgets(image_drawn_stream),
                filled_stream,
                keys_to_copy,
                None,
            )

        self._stream = filled_stream
        if image_drawn_stream is not None:
            # because copy_watermark_widgets and remove_all_widgets
            self._reregister_font()

        return self

    def create_field(
        self,
        field: FieldTypes,
    ) -> PdfWrapper:
        """
        Creates a new form field (widget) on the PDF using a `FieldTypes` object.

        This method simplifies widget creation by taking a `FieldTypes` object,
        extracting its properties, and then delegating to the `create_widget` method.

        Args:
            field (FieldTypes): An object representing the field to create.
                This object encapsulates all necessary properties like name,
                page number, coordinates, and type of the field.

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        field_dict = asdict(field)
        widget_type = field_dict.pop("_field_type")
        name = field_dict.pop("name")
        page_number = field_dict.pop("page_number")
        x = field_dict.pop("x")
        y = field_dict.pop("y")

        field_dict["suppress_deprecation_notice"] = True
        return self.create_widget(
            widget_type,
            name,
            page_number,
            x,
            y,
            **{k: v for k, v in field_dict.items() if v is not None},
        )

    def create_widget(
        self,
        widget_type: str,
        name: str,
        page_number: int,
        x: Union[float, List[float]],
        y: Union[float, List[float]],
        **kwargs,
    ) -> PdfWrapper:
        """
        Creates a new form field (widget) on the PDF.

        Args:
            widget_type (str): The type of widget to create.  Valid values are:
                - "text": A text field.
                - "checkbox": A checkbox field.
                - "dropdown": A dropdown field.
                - "radio": A radio button field.
                - "signature": A signature field.
                - "image": An image field.
            name (str): The name of the widget.  This name will be used to identify the widget when filling the form.
            page_number (int): The page number to create the widget on (1-based).
            x (Union[float, List[float]]): The x coordinate(s) of the widget.
                If a list is provided, it specifies the x coordinates of multiple instances of the widget.
            y (Union[float, List[float]]): The y coordinate(s) of the widget.
                If a list is provided, it specifies the y coordinates of multiple instances of the widget.
            **kwargs: Additional keyword arguments specific to the widget type.

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        if not kwargs.get("suppress_deprecation_notice"):
            warn(
                DEPRECATION_NOTICE.format(
                    f"{self.__class__.__name__}.create_widget()",
                    f"{self.__class__.__name__}.create_field()",
                ),
                DeprecationWarning,  # noqa: PT030
                stacklevel=2,
            )

        _class = None
        if widget_type == "text":
            _class = TextWidget
        if widget_type == "checkbox":
            _class = CheckBoxWidget
        if widget_type == "dropdown":
            _class = DropdownWidget
        if widget_type == "radio":
            _class = RadioWidget
        if widget_type == "signature":
            _class = SignatureWidget
        if widget_type == "image":
            _class = ImageWidget
        if _class is None:
            return self

        obj = _class(name=name, page_number=page_number, x=x, y=y, **kwargs)
        watermarks = obj.watermarks(self.read())

        self._stream = copy_watermark_widgets(self.read(), watermarks, [name], None)
        hook_params = obj.hook_params

        self._init_helper()
        for k, v in hook_params:
            self.widgets[name].__setattr__(k, v)

        return self

    def update_widget_key(
        self, old_key: str, new_key: str, index: int = 0, defer: bool = False
    ) -> PdfWrapper:
        """
        Updates the key (name) of a widget, allowing you to rename form fields.

        This method allows you to change the name of a form field in the PDF.  This can be useful for
        standardizing field names or resolving naming conflicts.  The update can be performed immediately
        or deferred until `commit_widget_key_updates` is called.

        Args:
            old_key (str): The old key of the widget that you want to rename.
            new_key (str): The new key to assign to the widget.
            index (int): The index of the widget if there are multiple widgets with the same name (default: 0).
            defer (bool): Whether to defer the update. If True, the update is added to a queue and applied
                when `commit_widget_key_updates` is called. If False, the update is applied immediately (default: False).

        Returns:
            PdfWrapper: The PdfWrapper object.
        """

        if getattr(self, "use_full_widget_name"):
            raise NotImplementedError

        if defer:
            self._keys_to_update.append((old_key, new_key, index))
            return self

        self._key_update_tracker[new_key] = old_key
        self._stream = update_widget_keys(
            self.read(), self.widgets, [old_key], [new_key], [index]
        )
        self._init_helper()

        return self

    def commit_widget_key_updates(self) -> PdfWrapper:
        """
        Commits deferred widget key updates, applying all queued key renames to the PDF.

        This method applies all widget key updates that were deferred using the `defer=True` option
        in the `update_widget_key` method.  It updates the underlying PDF stream with the new key names.

        Returns:
            PdfWrapper: The PdfWrapper object.
        """

        if getattr(self, "use_full_widget_name"):
            raise NotImplementedError

        old_keys = [each[0] for each in self._keys_to_update]
        new_keys = [each[1] for each in self._keys_to_update]
        indices = [each[2] for each in self._keys_to_update]

        self._stream = update_widget_keys(
            self.read(), self.widgets, old_keys, new_keys, indices
        )

        for each in self._keys_to_update:
            self._key_update_tracker[each[1]] = each[0]
        self._init_helper()
        self._keys_to_update = []

        return self

    def draw_text(
        self,
        text: str,
        page_number: int,
        x: Union[float, int],
        y: Union[float, int],
        **kwargs,
    ) -> PdfWrapper:
        """
        Draws text on the PDF.

        Args:
            text (str): The text to draw.
            page_number (int): The page number to draw on.
            x (Union[float, int]): The x coordinate of the text.
            y (Union[float, int]): The y coordinate of the text.
            **kwargs: Additional keyword arguments:
                - `font` (str): The name of the font to use (default: DEFAULT_FONT).
                - `font_size` (float): The font size in points (default: DEFAULT_FONT_SIZE).
                - `font_color` (Tuple[float, float, float]): The font color as an RGB tuple (default: DEFAULT_FONT_COLOR).

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        new_widget = Text("new")
        new_widget.value = text
        new_widget.font = kwargs.get("font", DEFAULT_FONT)
        new_widget.font_size = kwargs.get("font_size", DEFAULT_FONT_SIZE)
        new_widget.font_color = kwargs.get("font_color", DEFAULT_FONT_COLOR)

        watermarks = create_watermarks_and_draw(
            self.read(),
            page_number,
            "text",
            [
                {
                    "widget": new_widget,
                    "x": x,
                    "y": y,
                }
            ],
        )

        stream_with_widgets = self.read()
        self._stream = merge_watermarks_with_pdf(self.read(), watermarks)
        self._stream = copy_watermark_widgets(
            remove_all_widgets(self.read()), stream_with_widgets, None, None
        )
        # because copy_watermark_widgets and remove_all_widgets
        self._reregister_font()

        return self

    def draw_image(
        self,
        image: Union[bytes, str, BinaryIO],
        page_number: int,
        x: Union[float, int],
        y: Union[float, int],
        width: Union[float, int],
        height: Union[float, int],
        rotation: Union[float, int] = 0,
    ) -> PdfWrapper:
        """
        Draws an image on the PDF.

        Args:
            image (Union[bytes, str, BinaryIO]): The image data, provided as either:
                - bytes: The raw image data as a byte string.
                - str: The file path to the image.
                - BinaryIO: An open file-like object containing the image data.
            page_number (int): The page number to draw the image on.
            x (Union[float, int]): The x coordinate of the image.
            y (Union[float, int]): The y coordinate of the image.
            width (Union[float, int]): The width of the image.
            height (Union[float, int]): The height of the image.
            rotation (Union[float, int]): The rotation of the image in degrees (default: 0).

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        image = fp_or_f_obj_or_stream_to_stream(image)
        image = rotate_image(image, rotation)
        watermarks = create_watermarks_and_draw(
            self.read(),
            page_number,
            "image",
            [{"stream": image, "x": x, "y": y, "width": width, "height": height}],
        )

        stream_with_widgets = self.read()
        self._stream = merge_watermarks_with_pdf(self.read(), watermarks)
        self._stream = copy_watermark_widgets(
            remove_all_widgets(self.read()), stream_with_widgets, None, None
        )
        # because copy_watermark_widgets and remove_all_widgets
        self._reregister_font()

        return self

    def register_font(
        self,
        font_name: str,
        ttf_file: Union[bytes, str, BinaryIO],
        first_time: bool = True,
    ) -> PdfWrapper:
        """
        Registers a custom font for use in the PDF.

        Args:
            font_name (str): The name of the font. This name will be used to reference the font when drawing text.
            ttf_file (Union[bytes, str, BinaryIO]): The TTF file data, provided as either:
                - bytes: The raw TTF file data as a byte string.
                - str: The file path to the TTF file.
                - BinaryIO: An open file-like object containing the TTF file data.
            first_time (bool): Whether this is the first time the font is being registered (default: True).
                If True and `adobe_mode` is enabled, a blank text string is drawn to ensure the font is properly embedded in the PDF.

        Returns:
            PdfWrapper: The `PdfWrapper` object, allowing for method chaining.
        """

        ttf_file = fp_or_f_obj_or_stream_to_stream(ttf_file)

        if register_font(font_name, ttf_file) if ttf_file is not None else False:
            if first_time and getattr(self, "adobe_mode"):
                self.draw_text(" ", 1, 0, 0, font=font_name)
            self._stream, new_font_name = register_font_acroform(
                self.read(), ttf_file, getattr(self, "adobe_mode")
            )
            self._available_fonts[font_name] = new_font_name
            self._font_register_events.append((font_name, ttf_file))

        return self

### README.md [1/1] (lang=Markdown)

<p align="center"><img src="https://github.com/chinapandaman/PyPDFForm/raw/master/docs/img/logo.png"></p>
<p align="center">
    <em>PDF Form Automation Simplified  Create, Merge, Style, and Fill Forms Programmatically.</em>
</p>
<p align="center">
    <a href="https://pypi.org/project/PyPDFForm/"><img src="https://img.shields.io/pypi/v/pypdfform?label=version&color=magenta"></a>
    <a href="https://chinapandaman.github.io/PyPDFForm/"><img src="https://img.shields.io/github/v/release/chinapandaman/pypdfform?label=docs&color=cyan"></a>
    <a href="https://github.com/chinapandaman/PyPDFForm/actions/workflows/python-package.yml"><img src="https://img.shields.io/badge/coverage-100%25-green"></a>
    <a href="https://github.com/chinapandaman/PyPDFForm/raw/master/LICENSE"><img src="https://img.shields.io/github/license/chinapandaman/pypdfform?label=license&color=orange"></a>
    <a href="https://www.python.org/downloads/"><img src="https://img.shields.io/pypi/pyversions/pypdfform?label=python&color=gold"></a>
    <a href="https://pepy.tech/projects/pypdfform"><img src="https://static.pepy.tech/badge/pypdfform/month"></a>
</p>

## Introduction

PyPDFForm is a free and open source pure-Python 3 library for PDF form processing. It contains the essential 
functionalities needed to interact with PDF forms:

* Inspect what data a PDF form needs to be filled with.
* Fill a PDF form by simply creating a Python dictionary.
* Create form fields on a PDF.

It also supports other common utilities such as extracting pages and merging multiple PDFs together.

## Installing

Install using [pip](https://pip.pypa.io/en/stable/):

```shell script
pip install PyPDFForm
```

## Quick Example
![Check out the GitHub repository for a live demo if you can't see it here.](https://github.com/chinapandaman/PyPDFForm/raw/master/docs/img/demo.gif)

A sample PDF form can be found [here](https://chinapandaman.github.io/PyPDFForm/pdfs/sample_template.pdf). Download it and try:

```python
from PyPDFForm import PdfWrapper

filled = PdfWrapper("sample_template.pdf", adobe_mode=True).fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
)

filled.write("output.pdf")
```

After running the above code snippet you can find `output.pdf` at the location you specified, 
and it should look like [this](https://chinapandaman.github.io/PyPDFForm/pdfs/sample_filled.pdf).

## Documentation

The official documentation can be found on [the GitHub page](https://chinapandaman.github.io/PyPDFForm/) of this repository.

## Other Resources

[Chicago Python User Group - Dec 14, 2023](https://youtu.be/8t1RdAKwr9w?si=TLgumBNXv9H8szSn)

### SECURITY.md [1/1] (lang=Markdown)

# Security Policy

## Supported Versions

PyPDFForm only fixes vulnerabilities in the latest version of the library. 
Please consider upgrading your version before reporting any potential vulnerabilities.

| Version  | Supported          |
|----------| ------------------ |
| 3.5.5   | :white_check_mark: |
| < 3.5.5 | :x:                |

## Reporting a Vulnerability

If you believe you have identified a vulnerability with PyPDFForm, do NOT open a public issue. 
To responsibly report a vulnerability, use GitHub's [security advisory system](https://docs.github.com/en/code-security/security-advisories/working-with-repository-security-advisories/creating-a-repository-security-advisory).

Be sure to include as much detail as necessary in your report. As with reporting normal issues, 
a minimal reproducible example will help address the issue faster. 
Information about why the issue is a vulnerability is also helpful.

### docs/coordinate.md [1/1] (lang=Markdown)

# PDF coordinate system

The PDF coordinate system originates at the bottom left of the page. The unit of measurement is "points," with 72 points per inch. PyPDFForm uses this coordinate system in its APIs to create fields, text, and images on a PDF.

## Generate a coordinate grid view

To enhance the user experience with the coordinate system, PyPDFForm provides a grid view that helps determine the optimal placement of elements on a PDF.

To generate a coordinate grid view for [this PDF](pdfs/sample_template.pdf), use the following code:

```python
from PyPDFForm import PdfWrapper

grid_view_pdf = PdfWrapper("sample_template.pdf").generate_coordinate_grid(
    color=(1, 0, 0),    # optional
    margin=100  # optional
)

grid_view_pdf.write("output.pdf")
```

The `generate_coordinate_grid` method accepts two optional parameters: `color` and `margin`. The `color` parameter sets the grid view color (defaulting to red), and the `margin` parameter adjusts the coordinate grid view's margin in points (defaulting to 100 points).

### docs/dev_changes.md [1/1] (lang=Markdown)

# Pull Request Requirements

When submitting a pull request, follow these guidelines for a smooth review process.

## Code changes

PyPDFForm welcomes contributions from developers of all levels and doesn't enforce strict coding rules.

Your PR should follow these conventions:

* Prefer small, incremental changes. For large changes, request a feature branch in your issue and open your PR against that branch, as they will likely need revision before merging into master.
* Ensure your changes pass all linters. PyPDFForm uses rules from [pylint](https://www.pylint.org/), [ruff](https://docs.astral.sh/ruff/), and [pyright](https://microsoft.github.io/pyright/#/). Run `linting` inside the development container to check.
* Your changes must pass all tests and have 100% coverage. You can read more about testing [here](dev_test.md).
* If you are changing the user APIs or any other parts of the code that are relevant, please update the appropriate documentation too.

## Merge process

Your PR will be reviewed before merging into the master branch. If your changes are too extensive for inline comments, you may need to reopen your PR against a new feature branch for revision.

Additionally, your PR must pass these CI checks:

* [Linting](https://github.com/chinapandaman/PyPDFForm/actions/workflows/python-linting.yml) on the source code.
* [Tests](https://github.com/chinapandaman/PyPDFForm/actions/workflows/python-package.yml) will be run on three mainstream operating systems: `ubuntu`, `windows`, and `macos`, and across all Python versions the library supports on each OS.

Once the CI is green and your code looks good, the PR will be merged into the master branch. They will be deployed on the next release.

### docs/dev_doc.md [1/1] (lang=Markdown)

# Hosting Docs Locally

Update the relevant documentation when changing user APIs or other significant code sections.

PyPDFForm uses [MkDocs](https://www.mkdocs.org/) to build its documentation. To host the documentation locally, run:

```shell
mkdocs serve
```

The documentation will be available at `http://127.0.0.1:8000/`.

Alternatively, to run the documentation in the development container:

```shell
docs
```

The documentation will be available at `http://localhost:8000/`.

### docs/dev_intro.md [1/1] (lang=Markdown)

# Developer Intro

PyPDFForm is designed for Python developers. This documentation section is intended for contributors to PyPDFForm, not its end-users.

## Setup

To get started, create a virtual environment and install the development dependencies using your preferred package manager.

The command below uses [uv](https://docs.astral.sh/uv/):

```shell
uv pip install -U -r pyproject.toml --extra dev
```

PyPDFForm also offers a development container. To build it, run the following command in the project's root directory:

```shell
docker build -t pypdfform-dev .
```

Once successfully built, you can open a shell inside the container by running:

```shell
docker run -it --rm -p 8000:8000 -v ${PWD}:/pypdfform pypdfform-dev
```

## Running tests

See [testing PyPDFForm with pytest](dev_test.md).

## Creating issues

When creating a GitHub issue, follow these guidelines:

* The issue title should have the format `PPF-<issue number>: <title of the issue>`.
* The issue description should be as descriptive as possible, preferably with the following:
    * A code snippet related to the issue.
    * A PDF form template used by the code snippet.
    * Screenshots that can help visualize the issue.

## Opening pull requests

Before opening a pull request, create an issue. When opening the pull request, follow these guidelines:

* The PR title should be the same as its respective issue, so `PPF-<issue number>: <title of the issue>`.
* The PR description should contain a brief explanation of the changes.
* Once opened, the PR should be linked to its respective issue.

### docs/dev_release.md [1/1] (lang=Markdown)

# Releasing

The PyPDFForm release process involves these initial steps:

1. A [version bump commit](https://github.com/chinapandaman/PyPDFForm/commit/71b4983d115819d413edfdfc83af57f95ad292c7) that runs [black](https://black.readthedocs.io/) and [isort](https://pycqa.github.io/isort/) on the codebase.
2. A new [GitHub release](https://github.com/chinapandaman/PyPDFForm/releases) with auto-generated changelogs.

These steps trigger the deployment CI.

## Versioning

PyPDFForm follows the conventions defined by [Semantic Versioning](https://semver.org/).

## Deploy process

A GitHub release triggers two CIs:

* [Deploy](https://github.com/chinapandaman/PyPDFForm/actions/workflows/python-publish.yml), which will create the distribution and upload it to [PyPI](https://pypi.org/project/PyPDFForm/).
* [Deploy Docs](https://github.com/chinapandaman/PyPDFForm/actions/workflows/deploy-docs.yml), which will tear down and rebuild the [GitHub page](https://chinapandaman.github.io/PyPDFForm/) where the doc site is hosted.

## When are releases done?

Release timing depends on changes pending deployment on the master branch. Generally:

* Serious bugs are usually released immediately after they are fixed.
* New features can usually wait and are released on a weekly basis.
* Trivial changes are usually bundled with other changes and can wait indefinitely.

### docs/dev_test.md [1/1] (lang=Markdown)

# Testing

PyPDFForm uses [pytest](https://pytest.org/) for testing and [coverage.py](https://coverage.readthedocs.io/)
for measuring test coverage. To run the tests, execute:

```shell
coverage run -m pytest && coverage report --fail-under=100
```

Alternatively, in the development container, run:

```shell
test
```

## Generate coverage report

To generate a test coverage report, run:

```shell
coverage run -m pytest && coverage html
```

View the coverage report by opening `htmlcov/index.html` in a browser.

Alternatively, in the development container, run:

```shell
coverage
```

And the coverage report can be found at `http://localhost:8000/htmlcov/index.html`.

## Test breakdown

Although each PyPDFForm test is unique, most follow a general paradigm.

Most tests can be summarized into three steps:

* Define an expected PDF file that the outcome of the test should look like.
* Execute a sequence of code using PyPDFForm to generate a PDF that should look like the expected PDF file.
* Compare the PDF generated by the test with the expected PDF file.

Consider this example test:

```python
def test_fill(pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "sample_filled.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(pdf_samples, "sample_template.pdf")
        ).fill(
            {
                "test": "test_1",
                "check": True,
                "test_2": "test_2",
                "check_2": False,
                "test_3": "test_3",
                "check_3": True,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected
```

The test starts by defining an expected PDF `sample_filled.pdf`:

```python
expected_path = os.path.join(pdf_samples, "sample_filled.pdf")
```

The test then fills `sample_template.pdf` with a data dictionary using `PdfWrapper`:

```python
obj = PdfWrapper(
    os.path.join(pdf_samples, "sample_template.pdf")
).fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
)
```

Include these two lines in most tests to simplify updating old tests:

```python
request.config.results["expected_path"] = expected_path
request.config.results["stream"] = obj.read()
```

Finally, the test compares the resulted stream from the test with the expected file stream:

```python
expected = f.read()

assert len(obj.read()) == len(expected)
assert obj.read() == expected
```

### docs/draw.md [1/1] (lang=Markdown)

# Draw elements

PyPDFForm enables you to draw elements on a PDF, which is useful when a field is missing from your PDF form or when you need to add text or images.

This section of the documentation uses [this PDF](pdfs/sample_template.pdf) as an example.

Understanding [the PDF coordinate system](coordinate.md) is necessary for this section.

All optional parameters will have a comment `# optional` after each of them.

## Draw text

To use a custom font, see how to register it [here](font.md).

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template.pdf").draw_text(
    text="random text",
    page_number=1,
    x=300,
    y=225,
    font="your_registered_font",    # optional
    font_size=12,   # optional
    font_color=(1, 0, 0)    # optional
)

pdf.write("output.pdf")
```

## Draw image

For the rotation parameter, a positive value rotates the image counter-clockwise, and a negative value rotates it clockwise.

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template.pdf").draw_image(
    image="sample_image.jpg",
    page_number=1,
    x=100,
    y=100,
    width=400,
    height=225,
    rotation=0  # optional
)

pdf.write("output.pdf")
```

### docs/fill.md [1/1] (lang=Markdown)

# Fill PDF forms

PyPDFForm fills a PDF form using a flat, non-nested dictionary.
The filled form is editable by default. When you call the `fill` method, you can set the optional parameter `flatten` to `True` to flatten the filled form, making it uneditable.

## Fill text field and checkbox

When filling [this PDF](pdfs/sample_template.pdf), note that text fields are filled with `string` values and checkboxes with `boolean` values:

```python
from PyPDFForm import PdfWrapper

filled = PdfWrapper(
    "sample_template.pdf",
    adobe_mode=False    # optional, set to True for Adobe Acrobat compatibility
).fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
    flatten=False   # optional, set to True to flatten the filled PDF form
)

filled.write("output.pdf")
```

## Fill radio button group

A radio button group is a collection of radio buttons sharing the same name on a PDF form.

A [PDF form](pdfs/sample_template_with_radio_button.pdf) with radio button groups can be filled using `integer` values, where the value indicates which radio button to select within each group:

```python
from PyPDFForm import PdfWrapper

filled = PdfWrapper(
    "sample_template_with_radio_button.pdf",
    adobe_mode=False    # optional, set to True for Adobe Acrobat compatibility
).fill(
    {
        "radio_1": 0,
        "radio_2": 1,
        "radio_3": 2,
    },
    flatten=False   # optional, set to True to flatten the filled PDF form
)

filled.write("output.pdf")
```

## Fill dropdown field

As with radio buttons, select a dropdown choice by specifying its `integer` value. For example, to fill [this PDF](pdfs/sample_template_with_dropdown.pdf):

```python
from PyPDFForm import PdfWrapper

filled = PdfWrapper(
    "sample_template_with_dropdown.pdf",
    adobe_mode=False    # optional, set to True for Adobe Acrobat compatibility
).fill(
    {
        "dropdown_1": 1
    },
    flatten=False   # optional, set to True to flatten the filled PDF form
)

filled.write("output.pdf")
```

You can also specify a dropdown option by its `string` value:

```python
from PyPDFForm import PdfWrapper

filled = PdfWrapper(
    "sample_template_with_dropdown.pdf",
    adobe_mode=False    # optional, set to True for Adobe Acrobat compatibility
).fill(
    {
        "dropdown_1": "bar"
    },
    flatten=False   # optional, set to True to flatten the filled PDF form
)

filled.write("output.pdf")
```

**NOTE:** If you fill a dropdown field with a `string` value that is not one of its existing options, the new value is added as the last option in the dropdown and automatically selected.

## Fill signature field

A signature field enables signing a PDF form with a handwritten signature image.

To fill a signature field, consider [this PDF](pdfs/sample_template_with_signature.pdf) and [this signature image](https://github.com/chinapandaman/PyPDFForm/raw/master/image_samples/sample_signature.png):

```python
from PyPDFForm import PdfWrapper

signed = PdfWrapper(
    "sample_template_with_signature.pdf",
    adobe_mode=False    # optional, set to True for Adobe Acrobat compatibility
).fill(
    {
        "signature": "sample_signature.png"
    },
    flatten=False   # optional, set to True to flatten the filled PDF form
)

signed.write("output.pdf")
```

**NOTE:** The signature value in your dictionary can be a file path, an open file object, or a `bytes` file stream, as described [here](install.md/#create-a-pdf-wrapper).

By default, the library preserves the aspect ratio of the signature image when filling it. You can disable this by setting the `preserve_aspect_ratio` property to `False` on the signature field:

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template_with_signature.pdf")
pdf.widgets["signature"].preserve_aspect_ratio = False
pdf.fill(
    {
        "signature": "sample_signature.png"
    },
)

pdf.write("output.pdf")
```

## Fill image field

Fill an image field similarly to a signature field, using a file path, file object, or file stream.

To fill an image field, consider [this PDF](pdfs/sample_template_with_image_field.pdf) and [this image](https://github.com/chinapandaman/PyPDFForm/raw/master/image_samples/sample_image.jpg):

```python
from PyPDFForm import PdfWrapper

filled = PdfWrapper(
    "sample_template_with_image_field.pdf",
    adobe_mode=False    # optional, set to True for Adobe Acrobat compatibility
).fill(
    {
        "image_1": "sample_image.jpg"
    },
    flatten=False   # optional, set to True to flatten the filled PDF form
)

filled.write("output.pdf")
```

Unlike the signature field, the library does not preserve the aspect ratio of a regular image by default. You can enable this by setting the `preserve_aspect_ratio` property to `True` on the image field:

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template_with_image_field.pdf")
pdf.widgets["image_1"].preserve_aspect_ratio = True
pdf.fill(
    {
        "image_1": "sample_image.jpg"
    },
)

pdf.write("output.pdf")
```

### docs/font.md [1/1] (lang=Markdown)

# Register fonts

PyPDFForm enables the use of custom fonts in certain APIs. To use a custom font, you must first register its TrueType (.ttf) file.

For example, to use a font from the [Liberation Serif](https://fonts.adobe.com/fonts/liberation-serif) family, register its TrueType file (e.g., [LiberationSerif-BoldItalic.ttf](https://github.com/chinapandaman/PyPDFForm/raw/master/font_samples/LiberationSerif-BoldItalic.ttf)) as follows:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template.pdf")
form.register_font("new_font_name", "LiberationSerif-BoldItalic.ttf")
```

In this example, `LiberationSerif-BoldItalic.ttf` is registered as `new_font_name`. You can now reference this font in the object's APIs using the name `new_font_name`.

## Get registered fonts

To see which fonts have been registered, access the `fonts` attribute of the `PdfWrapper` object:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template.pdf")
form.register_font("new_font_name", "LiberationSerif-BoldItalic.ttf")

print(form.fonts)
```

The `fonts` attribute lists the names of the registered fonts.

### docs/index.md [1/1] (lang=Markdown)

# Welcome to PyPDFForm

PyPDFForm is a free and open source pure-Python 3 library for PDF form processing. It contains the essential 
functionalities needed to interact with PDF forms:

* Inspect what data a PDF form needs to be filled with.
* Fill a PDF form by simply creating a Python dictionary.
* Create form fields on a PDF.

It also supports other common utilities such as extracting pages and merging multiple PDFs together.

## User Guide

* [Installation and setup](install.md)
* [PDF coordinate system](coordinate.md)
* [Register fonts](font.md)
* [Create form fields](prepare.md)
* [Inspect form field data](inspect.md)
* [Fill PDF forms](fill.md)
* [Change form field styles](style.md)
* [Draw elements](draw.md)
* [Other utilities](utils.md)

## Developer Guide

* [Developer Intro](dev_intro.md)
* [Pull Request Requirements](dev_changes.md)
* [Hosting Docs Locally](dev_doc.md)
* [Testing](dev_test.md)
* [Releasing](dev_release.md)

## News

* [2025-05-24: V3 Announcements](news/2025-05-24.md)
* [2025-03-29: Announcements](news/2025-03-29.md)
* [2024-01-01: API Changes](news/2024-01-01.md)

### docs/inspect.md [1/1] (lang=Markdown)

# Inspect form field data

After preparing a PDF form, use PyPDFForm to inspect its field names and determine the data required for filling it. You can choose from multiple inspection methods to suit your needs.

This section of the documentation uses [this PDF](pdfs/sample_template.pdf) as an example.

## Generate a JSON schema that describes a PDF form

You can describe the dictionary used to fill a PDF form using a JSON schema. For example:

```python
import json
from PyPDFForm import PdfWrapper

pdf_form_schema = PdfWrapper("sample_template.pdf").schema

print(json.dumps(pdf_form_schema, indent=4, sort_keys=True))
```

The above snippet will yield the following output:

```json
{
    "properties": {
        "check": {
            "type": "boolean"
        },
        "check_2": {
            "type": "boolean"
        },
        "check_3": {
            "type": "boolean"
        },
        "test": {
            "type": "string"
        },
        "test_2": {
            "type": "string"
        },
        "test_3": {
            "type": "string"
        }
    },
    "type": "object"
}
```

In this example, `sample_template.pdf` contains three text fields (`test`, `test_2`, and `test_3`) of type `string` and three checkboxes (`check`, `check_2`, and `check_3`) of type `boolean`.

You can use the PyPDFForm-generated JSON schema to validate the data used for filling a PDF form.

## Inspect PDF form data

To inspect the current filled data of a PDF form, use the `.data` attribute. For example, the following snippet inspects the current filled data for [this PDF](pdfs/sample_template_filled.pdf):

```python
from pprint import pprint
from PyPDFForm import PdfWrapper

pprint(PdfWrapper("sample_template.pdf").data)
```

The above snippet will give you this dictionary:

```sh
{'check': True,
 'check_2': True,
 'check_3': True,
 'test': 'test',
 'test_2': 'test2',
 'test_3': 'test3'}
```

## Generate sample data

PyPDFForm can also generate sample data for filling a PDF form:

```python
from pprint import pprint
from PyPDFForm import PdfWrapper

pprint(PdfWrapper("sample_template.pdf").sample_data)
```

The above snippet will give you a sample dictionary:

```sh
{'check': True,
 'check_2': True,
 'check_3': True,
 'test': 'test',
 'test_2': 'test_2',
 'test_3': 'test_3'}
```

### docs/install.md [1/1] (lang=Markdown)

# Installation and setup

PyPDFForm is available on PyPI and can be installed using pip, which is the most common and recommended tool.

## Prerequisites

PyPDFForm officially supports Python 3.10 and newer versions that are currently in their active life cycles. This typically includes the minimum supported version and the four major versions above it. For details on Python version life cycles, refer to [this page](https://devguide.python.org/versions/).

**NOTE:** While official support is limited to active Python versions, PyPDFForm generally avoids features specific to particular major Python versions. It is expected to be functional with Python 3.7+ (due to its use of [Postponed Evaluation of Annotations](https://peps.python.org/pep-0563/) for type hints, introduced in Python 3.7), though these versions are not actively tested.

## Install using pip

It is highly recommended to create a virtual environment before installation. Then, run the following command to install PyPDFForm:

```shell
pip install PyPDFForm
```

To upgrade PyPDFForm and all its dependencies, run:

```shell
pip install -U PyPDFForm
```

## Create a PDF wrapper

The main user interface of the library is the `PdfWrapper` class. It implements most PyPDFForm APIs and accepts various optional parameters, the most important of which is the PDF form template.

For example, to use [this PDF](pdfs/sample_template.pdf) as a template, instantiate the `PdfWrapper` object as follows:

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template.pdf")
```

PyPDFForm provides an adapter for different file interaction methods in Python, which allows you to pass your PDF form to `PdfWrapper` as a file path, an open file object, or a `bytes` file stream.

This means the following two snippets are equivalent to the above:

```python
from PyPDFForm import PdfWrapper

with open("sample_template.pdf", "rb+") as template:
    pdf = PdfWrapper(template)
```

```python
from PyPDFForm import PdfWrapper

with open("sample_template.pdf", "rb+") as template:
    pdf = PdfWrapper(template.read())
```

This file adaptation applies to all PyPDFForm APIs. You can replace file path parameters with file objects or streams throughout the documentation.

## Create an Adobe Acrobat compatible PDF wrapper

Adobe Acrobat has known issues displaying PDF forms with filled text fields. Specifically, the text content may only be visible when the text field is selected. This issue is not present in browsers like Chrome or PDF viewers such as Document Viewer (the default PDF application on Ubuntu).

By setting the optional parameter `adobe_mode` (default value is `False`) to `True` when instantiating the `PdfWrapper` object, you ensure that the PDF can be processed and displayed correctly by Adobe Acrobat:

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template.pdf", adobe_mode=True)
```

**NOTE:** PDF objects with `adobe_mode` enabled are optimized for viewing in Adobe Acrobat. Other PDF viewers might experience rendering issues with certain field styles, such as text font or field borders. Therefore, only enable `adobe_mode` when the generated PDFs are intended to be viewed with Adobe Acrobat.

## Use full name for PDF form fields

According to section 12.7.3.2 of the [PDF standard](https://opensource.adobe.com/dc-acrobat-sdk-docs/pdfstandards/PDF32000_2008.pdf) (page 434), PDF form fields can have fully qualified names constructed using the pattern `<parent_field_name>.<field_name>`.

PyPDFForm allows you to access fields by their full names by setting `use_full_widget_name` to `True` when instantiating `PdfWrapper`. For example, to use [this PDF](pdfs/sample_template_with_full_key.pdf):

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template_with_full_key.pdf", use_full_widget_name=True)
```

This enables accessing fields by their full names. For instance, you can access the checkbox labeled `Gain de 2 classes` using its full name `Gain de 2 classes.0` instead of its partial name `0`.

**NOTE:** When using full names, the `update_widget_key` and `commit_widget_key_updates` methods of `PdfWrapper` are disabled and raise a `NotImplementedError` because full names involve both the field and its parent.

## Write to a file

`PdfWrapper` behaves like an open file object, allowing you to write the PDF to another file object. For example, to write to a disk file:

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template.pdf")

with open("output.pdf", "wb+") as output:
    output.write(pdf.read())
```

It doesn't have to be a disk file; it can be a memory buffer as well:

```python
from io import BytesIO
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template.pdf")

with BytesIO() as output:
    output.write(pdf.read())
```

In addition to behaving like a file object, `PdfWrapper` also implements a `write` method that allows you to write the PDF to a disk file by specifying the path:

```python
from PyPDFForm import PdfWrapper

pdf = PdfWrapper("sample_template.pdf")
pdf.write("output.pdf")
```

### docs/news/2024-01-01.md [1/1] (lang=Markdown)

# 2024-01-01: API Changes

Happy new year fellow developers! We start the year 2024 with a new release of v1.4.0 and 
there are some important changes I'm making to the APIs of the library.

* The PDF object that gets instantiated is now `PyPDFForm.PdfWrapper`, changed from `PyPDFForm.PyPDFForm`.
* Form widgets are now accessed via the `PdfWrapper.widgets` attribute, changed from `PdfWrapper.elements`.
* The JSON schema of the form data is now accessed via a new attribute called `PdfWrapper.schema`, 
changed from the old method of `PdfWrapper.generate_schema()`.

All the old APIs will be persisted for half a year and then fully deprecated. Each of them 
will emit a `DeprecationWarning` when invoked, so it is advised that you make the switch before they are 
removed and start breaking your code.

Happy hacking!

### docs/news/2025-03-29.md [1/1] (lang=Markdown)

# 2025-03-29: Announcements

Hello fellow Python developers! With the release of v2.0.0, there are some important changes I'm making to the library:

* Since I started developing the library, versioning releases has been quite unorthodox, and there isn't any convention I followed. Starting with v2.0.0, PyPDFForm will version releases following the conventions defined by [Semantic Versioning](https://semver.org/).
* PyPDFForm now renders PDF form widgets! Ever since its ancestral stage, the library has only been able to render the data you filled into a PDF form. Now if you fill a PDF form using `PdfWrapper`, the result will render the whole widget instead of just the value that got filled. If you would like to disable this behavior, please refer to the docs [here](https://chinapandaman.github.io/PyPDFForm/fill/#disable-rendering-widgets).

Happy hacking!

### docs/news/2025-05-24.md [1/2] (lang=Markdown)

# 2025-05-24: V3 Announcements

This article provides important information about the upcoming v3.0.0 release.

## TL; DR

PyPDFForm v3.0.0 is scheduled for release on June 24, 2025. This major release includes changes that will break compatibility with older code. To avoid issues, pin your version to <=2.5.0 as soon as possible.

Here's a list of the changes:

* `FormWrapper` has been removed. Its features have been moved to `PdfWrapper`. The `fill` method of `PdfWrapper` will now work the same way it did in `FormWrapper`.
* The way to enable `adobe_mode` when filling has changed. Instead of passing `adobe_mode` as an argument to the `fill` method, you now pass it when creating a `PdfWrapper` object.
* Setting font properties for the entire document (e.g., `PdfWrapper("sample_template.pdf", global_font_size=20)`) is no longer supported. You must now set font properties for each individual widget.
* `register_font` is now a method of the `PdfWrapper` object, not a general class method.
* `PdfWrapper.preview` is removed.
* You can no longer change the `button_style` of existing checkboxes or radio buttons. (Setting the `button_style` when you create them is still supported.)
* Render widgets flag `render_widgets` is removed.

## Why these changes?

When I started this project about five years ago, I didn't have as much experience as I do now. I ran into some technical problems during the initial proof of concept. One problem was that filled text fields in Adobe Acrobat sometimes only appeared when the field was selected.

Because of this behavior in Adobe Acrobat, and because I wanted to support as many PDF viewers as possible, I decided to use a "watermark" approach. Instead of directly changing the form field data, this approach gathers information about each field, such as its location, font, size, and color. Then, it removes all the original form fields, creates a watermark of the PDF, draws the filled content onto the watermark, and combines the watermark with the original PDF. Even though this removes the original fields and makes the filled content look "flattened", it ensures that the filled PDFs only contain basic PDF data and can be viewed in any PDF application. The project has grown since then, adding features like custom form field styles and even the ability to create form fields. As of version 2.5.0, the `PdfWrapper` still uses this watermark method as its core.

About a year ago, with the help of the community, I was finally able to solve the text field issue in Adobe Acrobat that had been present since the beginning of the project. This made it possible to directly modify the form field data when filling a PDF, which has several benefits: the form fields can remain editable after filling, there's no need for complicated calculations to determine coordinates and resolutions, and merging watermarks with the original PDF is no longer necessary, which greatly improves performance. However, the project had already developed significantly, and some features that relied on the watermark approach, such as changing font properties, couldn't be easily adapted to the new method, at least not initially. Therefore, instead of completely abandoning the watermark approach, I decided to create a new, simpler set of APIs that would support this new way of filling forms. This resulted in the `FormWrapper`.

The `FormWrapper` turned out to be a good addition, attracting even more users because it could truly "fill" a PDF form as if it were done by hand. Since then, `PdfWrapper` and `FormWrapper` have existed side-by-side. However, recent developments have made it necessary to introduce even more significant and fundamental changes to the project. First, I've noticed that many users, even when using features from `PdfWrapper` like creating or renaming widgets, prefer to use `FormWrapper` for the final step of filling the PDF. In these situations, I've had to advise them to first perform the necessary actions with `PdfWrapper`, extract the stream from the `PdfWrapper` object, and then use that as input for `FormWrapper` to complete the filling process. This workflow doesn't seem very intuitive. Second, I've developed some extremely complex calculations to determine how form field data should be drawn when using the watermark method. However, I've reached a point where I can't figure out how to support landscape PDFs due to orientation issues. This makes abandoning the watermark approach even more desirable. Finally, my recent research has revealed clearer ways to implement features that were previously only achievable through the watermark method by directly manipulating form field data.

Considering everything mentioned above, I believe it's time to introduce the next major version of PyPDFForm: v3.0.0.

## What are the changes?

In short, the goal of v3.0.0 can be summed up to:

* Merge `FormWrapper` into `PdfWrapper`.
* Reimplement most, if not all, `PdfWrapper` features, especially the `fill` method, by directly manipulating form field data.
* Preserve as much backward compatibility as possible.

Let's talk more about backward compatibility. With changes as significant as those in this release, it's impossible to maintain complete backward compatibility. For instance, even if you use the `fill` method in the same way as before, the filled PDF forms will now be editable because the watermark method is no longer used.

So, when I say I've tried to preserve as much backward compatibility as possible, I mean I've minimized the number of API changes. The appearance of your generated PDFs will be slightly different compared to the watermark approach, but you'll still be able to use most of PyPDFForm's APIs in the same way as before the release.

However, some unavoidable changes will break backward compatibility. This is why this release is a major version update, as defined by Semantic Versioning. I'll do my best to explain these changes and the reasons behind them in the list below:

* As mentioned earlier, `FormWrapper` has been merged into `PdfWrapper` and completely removed. `FormWrapper` only provided basic PDF form filling features. After the merge, the `fill` method of `PdfWrapper` will function identically to how it did in `FormWrapper`.
* The `adobe_mode` parameter has been moved from the `fill` method to the `PdfWrapper` object's constructor. This change is necessary because most `PdfWrapper` features now directly manipulate form field data and need to support Adobe Acrobat. Therefore, the setting applies to the entire object rather than just the filling method.
* Previously, font properties could be set globally for each object using parameters like `global_font`, `global_font_size`, and `global_font_color` when creating the object. This is no longer possible. Font properties must now be set for each individual widget. Setting font properties globally made sense when they all needed to be applied to the same watermarks. Now that the project directly manipulates form fields, it's more logical to set them at the widget level.
* `register_font` is now a method that belongs to each `PdfWrapper` object, rather than a general class method. This change should have been made earlier, and it's becoming more obvious with this release, as each registered font should only be used for a single PDF form.
* The `preview` feature has been removed. It was initially an experimental feature and has proven to create messy, unreadable previews for PDFs with many fields. There are better ways to inspect a PDF form, such as using `schema` and `sample_data`.
* Modifying the `button_style` of existing checkboxes or radio buttons by directly manipulating form field data is difficult, as it involves complex stream creation that I'm currently unable to implement. Therefore, this feature has been removed for now but may be added back in the future. Note that this change doesn't affect the ability to set the `button_style` when creating checkboxes or radio buttons.
* `render_widgets` has been removed. This feature was originally added to maintain backward compatibility when the watermark approach first began supporting the rendering of widget borders and backgrounds. Since the watermark approach is no longer used, this feature is unnecessary.


### docs/news/2025-05-24.md [2/2] (lang=Markdown)

## What do you need to do?

First, I strongly recommend that you pin your PyPDFForm dependency version to <=2.5.0 as soon as possible, unless you're certain that these changes won't cause any problems for you.

After pinning your version, you have a couple of options:

* If any of the backward-incompatible changes affect your code, update your code accordingly, using the information provided above.
* If you prefer the old watermark approach, you can keep your version pinned to <=2.5.0 indefinitely, as those older versions will remain available.

Otherwise, once the release is made, you should have no problem upgrading to v3.0.0 and any future patches after the release.

## When will this happen?

This announcement was written and should be published on May 24, 2025. After publication, the community will have one month to review this information and make any necessary adjustments.

Therefore, unless there's significant opposition from the community, PyPDFForm v3.0.0 will be released on June 24, 2025.

### docs/prepare.md [1/2] (lang=Markdown)

# Create form fields

The most common tool for creating PDF form fields is Adobe Acrobat, and a tutorial is available [here](https://helpx.adobe.com/acrobat/using/creating-distributing-pdf-forms.html). Alternative free tools like [DocFly](https://www.docfly.com/) offer similar functionality.

PyPDFForm also allows creating PDF form fields on existing PDFs through coding.

This section of the documentation will primarily use [this PDF](https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf) as an example.

Understanding [the PDF coordinate system](coordinate.md) is necessary for this section.

All optional parameters will have a comment `# optional` after each of them.

## Create a text field

A text field can be created by downloading the PDF and running the following snippet:

```python
from PyPDFForm import Fields, PdfWrapper

new_form = PdfWrapper("dummy.pdf").create_field(
    Fields.TextField(
        name="new_text_field",
        page_number=1,
        x=57.5,
        y=700.9,
        required=False,  # optional
        tooltip="this is a text field",  # optional
        width=120.3,  # optional
        height=40.7,  # optional
        max_length=5,  # optional, number of characters
        comb=True,  # optional, when set to True, max_length must also be set
        font="your_registered_font",  # optional
        font_size=15,  # optional
        font_color=(1, 0, 0),  # optional
        bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)
        border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)
        border_width=5,  # optional
        alignment=0,  # optional, 0=left, 1=center, 2=right
        multiline=True,  # optional
    )
)

new_form.write("output.pdf")
```

To use a custom font, see how to register it [here](font.md).

**NOTE:** For the `comb` option, refer to the documentation [here](style.md/#enable-text-field-character-spacing-combs).

## Create a checkbox

A checkbox can be created using the same method with some changes to the parameters:

```python
from PyPDFForm import Fields, PdfWrapper

new_form = PdfWrapper("dummy.pdf").create_field(
    Fields.CheckBoxField(
        name="new_checkbox",
        page_number=1,
        x=57,
        y=700,
        required=False,  # optional
        tooltip="this is a checkbox",  # optional
        size=30,  # optional
        button_style="check",  # optional
        tick_color=(0, 1, 0),  # optional
        bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)
        border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)
        border_width=5,  # optional
    )
)

new_form.write("output.pdf")
```

The `button_style` parameter currently supports three options: `check`, `circle`, and `cross`.

**NOTE:** To remove the border of a checkbox, set the alpha channel of the `border_color` to 0, for example: `border_color=(1, 0, 0, 0)`. Setting `border_width` to 0 may still render a border with a width of 1 due to a PDF specification quirk.

## Create a radio button group

Unlike other field types, radio buttons must be created as a group. Therefore, for the coordinate parameters `x` and `y`, you must specify a list of coordinates for each radio button within the group, and the list must contain more than one coordinate.

Otherwise, radio button creation shares almost the same parameters as a checkbox:

```python
from PyPDFForm import Fields, PdfWrapper

new_form = PdfWrapper("dummy.pdf").create_field(
    Fields.RadioGroup(
        name="new_radio_group",
        page_number=1,
        x=[50, 100, 150],
        y=[50, 100, 150],
        required=False,  # optional
        tooltip="this is a radio group",  # optional
        size=30,  # optional
        button_style="check",  # optional
        shape="square",  # optional, circle or square
        tick_color=(0, 1, 0),  # optional
        bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)
        border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)
        border_width=5,  # optional
    )
)

new_form.write("output.pdf")
```

**NOTE:** To remove the border of a group of radio buttons, set the alpha channel of the `border_color` to 0, for example: `border_color=(1, 0, 0, 0)`. Setting `border_width` to 0 may still render a border with a width of 1 due to a PDF specification quirk.

## Create a dropdown field

A dropdown field shares a similar set of parameters as a text field. The only significant difference is that a list of `options` needs to be specified:

```python
from PyPDFForm import Fields, PdfWrapper

new_form = PdfWrapper("dummy.pdf").create_field(
    Fields.DropdownField(
        name="new_dropdown",
        page_number=1,
        x=57,
        y=700,
        options=[
            "foo",
            "bar",
            "foobar",
        ],
        required=False,  # optional
        tooltip="this is a dropdown",  # optional
        width=120,  # optional
        height=40,  # optional
        font="your_registered_font",  # optional
        font_size=15,  # optional
        font_color=(1, 0, 0),  # optional
        bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)
        border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)
        border_width=5,  # optional
    )
)

new_form.write("output.pdf")
```

To use a custom font, see how to register it [here](font.md).

If you want different export values from the displayed options, you can specify a list of tuples for the `options` parameter, where the first value of each tuple is the displayed option and the second value is the export value:

```python
from PyPDFForm import Fields, PdfWrapper

new_form = PdfWrapper("dummy.pdf").create_field(
    Fields.DropdownField(
        name="new_dropdown",
        page_number=1,
        x=57,
        y=700,
        options=[
            ("option_1", "option_1_export_value"),
            ("option_2", "option_2_export_value"),
            ("option_3", "option_3_export_value"),
        ],
    )
)

new_form.write("output.pdf")
```

## Create a signature field

A signature field is only interactive in tools that support it. Otherwise, it is displayed as a rectangle, and clicking it will not trigger any action:

```python
from PyPDFForm import Fields, PdfWrapper

new_form = PdfWrapper("dummy.pdf").create_field(
    Fields.SignatureField(
        name="new_signature",
        page_number=1,
        x=100,
        y=100,
        required=False,  # optional
        tooltip="this is a signature",  # optional
        width=410,  # optional
        height=100,  # optional
    )
)

new_form.write("output.pdf")
```

### docs/prepare.md [2/2] (lang=Markdown)


## Create an image field

Similar to a signature field, an image field is also only interactive in tools that support it:

```python
from PyPDFForm import Fields, PdfWrapper

new_form = PdfWrapper("dummy.pdf").create_field(
    Fields.ImageField(
        name="new_image",
        page_number=1,
        x=100,
        y=100,
        required=False,  # optional
        tooltip="this is an image",  # optional
        width=192,  # optional
        height=108,  # optional
    )
)

new_form.write("output.pdf")
```

## Modify the key of a field

PyPDFForm allows you to modify the keys of existing fields. For example, to change the key of the first text field, `test`, to `test_text` using [this PDF](pdfs/sample_template.pdf), use the following code:

```python
from PyPDFForm import PdfWrapper

new_form = PdfWrapper("sample_template.pdf").update_widget_key(
    "test", "test_text"
)

new_form.write("output.pdf")
```

If multiple fields share the same key, use the `index` parameter to specify which one to update. For instance, to change the key of the second row's text field with the key `Description[0]` to `Description[1]` using [this PDF](pdfs/733.pdf), use the following code:

```python
from PyPDFForm import PdfWrapper

new_form = PdfWrapper("733.pdf").update_widget_key(
    "Description[0]", "Description[1]", index=1
)

new_form.write("output.pdf")
```

For bulk updates, improve performance by setting `defer=True` when updating each key, then call `commit_widget_key_updates()` at the end to commit all changes.

To change the key of each row's text field with the key `Description[0]` to `Description[i]`, where `i` is the index of each row, using [this PDF](pdfs/733.pdf), use the following code:

```python
from PyPDFForm import PdfWrapper

new_form = PdfWrapper("733.pdf")

for i in range(1, 10):
    new_form.update_widget_key(
        "Description[0]", f"Description[{i}]", index=1, defer=True
    )

new_form.commit_widget_key_updates().write("output.pdf")
```

### docs/style.md [1/2] (lang=Markdown)

# Change form field styles

PyPDFForm enables you to modify some field styles through code, allowing you to change field appearances without altering the PDF form template.

This section of the documentation will primarily use [this PDF](pdfs/sample_template.pdf) as an example.

## Change text field font

Before changing a text field's font, you must first [register](font.md) the desired font.

After registration, you can apply the registered font to any text field:

```python
from PyPDFForm import PdfWrapper, Text

form = PdfWrapper("sample_template.pdf")

# change globally by iterating each text field
for field in form.widgets.values():
    if isinstance(field, Text):
        field.font = "your_registered_font"

# or change at each field's widget level
form.widgets["test"].font = "your_registered_font"

form.fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
)

form.write("output.pdf")
```

## Change text field font size

You can change the font size using a `float` value in PyPDFForm:

```python
from PyPDFForm import PdfWrapper, Text

form = PdfWrapper("sample_template.pdf")

# change globally by iterating each text field
for field in form.widgets.values():
    if isinstance(field, Text):
        field.font_size = 20

# or change at each field's widget level
form.widgets["test"].font_size = 30.5

form.fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
)

form.write("output.pdf")
```

## Change text field font color

You can change the font color using an RGB `tuple`:

```python
from PyPDFForm import PdfWrapper, Text

form = PdfWrapper("sample_template.pdf")

# change globally by iterating each text field
for field in form.widgets.values():
    if isinstance(field, Text):
        field.font_color = (1, 0, 0)

# or change at each field's widget level
form.widgets["test"].font_color = (0.2, 0, 0.5)

form.fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
)

form.write("output.pdf")
```

## Change text field alignment

You can change the alignment of the text filled into a text field by setting its `alignment` property to an integer value: `0` for left, `1` for center, and `2` for right.

```python
from PyPDFForm import PdfWrapper, Text

form = PdfWrapper("sample_template.pdf")

# change globally by iterating each text field
for field in form.widgets.values():
    if isinstance(field, Text):
        field.alignment = 1 # center

# or change at each field's widget level
form.widgets["test"].alignment = 2  # right

form.fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
)

form.write("output.pdf")
```

## Change text field max length

You can change the maximum number of characters allowed in a text field:

```python
from PyPDFForm import PdfWrapper, Text

form = PdfWrapper("sample_template.pdf")

# change globally by iterating each text field
for field in form.widgets.values():
    if isinstance(field, Text):
        field.max_length = 4

# or change at each field's widget level
form.widgets["test"].max_length = 2

form.fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
)

form.write("output.pdf")
```

## Enable text field character spacing (combs)

To enable character spacing in a text field, set its `.comb` property to `True`. This will evenly space out the characters of the text filled into the field. Note that this property only takes effect when the text field also has a `max_length` set.

```python
from PyPDFForm import PdfWrapper, Text

form = PdfWrapper("sample_template.pdf")

# change globally by iterating each text field
for field in form.widgets.values():
    if isinstance(field, Text):
        field.max_length = 4
        field.comb = True

# or change at each field's widget level
form.widgets["test"].max_length = 2
form.widgets["test"].comb = True

form.fill(
    {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    },
)

form.write("output.pdf")
```

## Enable multiline text field

To enable multiline input for a text field, set its `.multiline` property to `True`. This effectively transforms it into a paragraph field:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template.pdf")

form.widgets["test"].multiline = True

form.fill(
    {
        "test": "test_1\ntest_1",
        "check": True,
        "test_2": "test_2\ntest_2",
        "check_2": False,
        "test_3": "test_3\ntest_3",
        "check_3": True,
    },
)

form.write("output.pdf")
```

## Change checkbox/radio button size

You can change the size of a checkbox or a group of radio buttons using a `float` value:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template.pdf")

form.widgets["check"].size = 50
form.widgets["check_2"].size = 40
form.widgets["check_3"].size = 60

form.fill(
    {
        "check": True,
        "check_2": True,
        "check_3": True,
    },
)

form.write("output.pdf")
```

## Change dropdown field choices

To modify the options available in a dropdown field, assign a new list of strings to the `.choices` attribute of the corresponding field. For instance, the following code snippet updates the `dropdown_1` field in [this PDF form](pdfs/sample_template_with_dropdown.pdf) with a new set of choices:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template_with_dropdown.pdf")

form.widgets["dropdown_1"].choices = ["", "apple", "banana", "cherry", "dates"]

form.write("output.pdf")
```

If you want different export values from the displayed options, you can specify a list of tuples for the `.choices` attribute, where the first value of each tuple is the displayed option and the second value is the export value:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template_with_dropdown.pdf")

form.widgets["dropdown_1"].choices = [
    ("", "blank_export_value"),
    ("apple", "apple_export_value"),
    ("banana", "banana_export_value"),
    ("cherry", "cherry_export_value"),
    ("dates", "dates_export_value"),
]

form.write("output.pdf")
```

### docs/style.md [2/2] (lang=Markdown)


## Change dropdown field font

Before changing a dropdown field's font, you must first [register](font.md) the desired font.

After registration, you can apply the registered font to any dropdown field:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template_with_dropdown.pdf")

form.widgets["dropdown_1"].font = "your_registered_font"

form.write("output.pdf")
```

## Change dropdown field font size

You can change a dropdown field's font size using a `float` value in PyPDFForm:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template_with_dropdown.pdf")

form.widgets["dropdown_1"].font_size = 30

form.write("output.pdf")
```

## Change dropdown field font color

You can change a dropdown field's font color using an RGB `tuple`:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template_with_dropdown.pdf")

form.widgets["dropdown_1"].font_color = (1, 0, 0)

form.write("output.pdf")
```

## Change field editability

The `readonly` property of each form field controls its editability. Setting `readonly` to `True` flattens the field, making it uneditable, while setting it to `False` unflattens it, making it editable. For example, the following code snippet shows how you can make different form fields editable in [this PDF form](pdfs/sample_template_with_dropdown.pdf) after they have been flattened:

```python
from PyPDFForm import PdfWrapper

form = PdfWrapper("sample_template_with_dropdown.pdf")

form.fill(
    {
        "test_1": "test_1",
        "test_2": "test_2",
        "test_3": "test_3",
        "check_1": True,
        "check_2": True,
        "check_3": True,
        "radio_1": 1,
        "dropdown_1": 0,
    },
    flatten=True,
)
form.widgets["test_2"].readonly = False  # text
form.widgets["check_3"].readonly = False  # checkbox
form.widgets["radio_1"].readonly = False  # radio button group
form.widgets["dropdown_1"].readonly = False  # dropdown

form.write("output.pdf")
```

### docs/utils.md [1/1] (lang=Markdown)

# Other utilities

PyPDFForm offers additional utilities similar to other PDF libraries.

This section of the documentation uses [this PDF](pdfs/sample_template.pdf) as an example.

## Extract pages

The `PdfWrapper` object has a `.pages` attribute, which is a list of `PdfWrapper` objects representing individual pages:

```python
from PyPDFForm import PdfWrapper

first_page = PdfWrapper("sample_template.pdf").pages[0]
first_page.fill(
    {
        "test": "test_1",
        "check": True,
    },
)

first_page.write("output.pdf")
```

## Merge multiple PDFs

You can merge multiple PDF files by adding their `PdfWrapper` objects. For example, to merge [this PDF](https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf) and [this PDF](pdfs/sample_template.pdf):

```python
from PyPDFForm import PdfWrapper

pdf_one = PdfWrapper("dummy.pdf")
pdf_two = PdfWrapper("sample_template.pdf")
merged = pdf_one + pdf_two

merged.write("output.pdf")
```

To reorganize pages:

```python
from PyPDFForm import PdfWrapper

pdf_one = PdfWrapper("dummy.pdf")
pdf_two = PdfWrapper("sample_template.pdf")
merged = pdf_two.pages[0] + pdf_one + pdf_two.pages[1] + pdf_two.pages[2]

merged.write("output.pdf")
```

## Change PDF version

PyPDFForm allows you to modify the PDF version up to 2.0:

```python
from PyPDFForm import PdfWrapper

new_version = PdfWrapper("sample_template.pdf").change_version("2.0")
new_version.write("output.pdf")
```

### font_samples/SIL Open Font License.txt [1/1] (lang=Text)

Digitized data copyright (c) 2010 Google Corporation
	with Reserved Font Arimo, Tinos and Cousine.
Copyright (c) 2012 Red Hat, Inc.
	with Reserved Font Name Liberation.

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL

-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.

The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the copyright statement(s).

"Original Version" refers to the collection of Font Software components as distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.

"Author" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.

5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.

### pyproject.toml [1/1] (lang=Toml)

[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project]
name = "PyPDFForm"
dynamic = ["version"]
description = "The Python library for PDF forms."
readme = "README.md"
authors = [
    {name = "Jinge Li"}
]
license = "MIT"
license-files = ["LICENSE"]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Developers",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3 :: Only",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Programming Language :: Python :: 3.14",
    "Operating System :: OS Independent",
    "Topic :: Software Development :: Libraries :: Python Modules",
]
requires-python = ">=3.10"
dependencies = [
    "cryptography",
    "fonttools",
    "pillow",
    "pypdf",
    "reportlab",
]

[project.urls]
Homepage = "https://github.com/chinapandaman/PyPDFForm"
Documentation = "https://chinapandaman.github.io/PyPDFForm/"

[project.optional-dependencies]
dev = [
    "black",
    "coverage",
    "isort",
    "jsonschema",
    "mkdocs",
    "pudb",
    "pylint",
    "pyright",
    "pytest",
    "requests",
    "ruff",
]

[tool.coverage.run]
omit = [
    "venv/*",
    "tests/*",
]

[tool.pylint."MESSAGES CONTROL"]
disable = [
    "C0103",
    "R0913",
    "R0902",
    "R0903",
    "R0914",
    "C0209",
    "C0123",
    "R0917",
    "C2801",
    "C0301",
    "W0511",
]

[tool.ruff.lint]
select = [
    "A",
    "ASYNC",
    "B",
    "BLE",
    "C4",
    "DTZ",
    "E",
    "EM",
    "F",
    "FLY",
    "G",
    "ISC",
    "ICN",
    "INT",
    "LOG",
    "N",
    "PIE",
    "PT",
    "PERF",
    "Q",
    "R",
    "RSE",
    "SLF",
    "SLOT",
    "SIM",
    "T10",
    "TRY",
    "TCH",
    "YTT",
    "W",
]
ignore = ["B009", "E501", "N999", "Q000", "TC006", "N816"]

[tool.pyright]
typeCheckingMode = "basic"
reportArgumentType = "none"
reportAttributeAccessIssue = "none"
reportIndexIssue = "none"
reportOperatorIssue = "none"
reportGeneralTypeIssues = "none"
reportOptionalMemberAccess = "error"
reportPossiblyUnboundVariable = "error"
reportUnusedImport = "error"
reportIncompatibleMethodOverride = "error"
reportMissingSuperCall = "error"
reportPrivateUsage = "error"
reportSelfClsParameterName = "error"
reportReturnType = "error"
reportAssignmentType = "error"
reportOptionalSubscript = "error"

[tool.setuptools.dynamic]
version = {attr = "PyPDFForm.__version__"}

[tool.setuptools.packages.find]
include = ["PyPDFForm*"]

[tool.pytest.ini_options]
markers = [
    "posix_only",
]

### scripts/bump_version.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""Bumps a version."""

import os
import re
import sys

if __name__ == "__main__":
    to_bump = sys.argv[1]

    v = ""
    with open("PyPDFForm/__init__.py", encoding="utf8") as f:
        version = re.search(r'__version__ = "(.*?)"', f.read())
        if version:
            v = version.group(1)

    major, minor, patch = v.split(".")

    if to_bump == "patch":
        patch = str(int(patch) + 1)
    elif to_bump == "minor":
        patch = "0"
        minor = str(int(minor) + 1)
    elif to_bump == "major":
        patch = "0"
        minor = "0"
        major = str(int(major) + 1)

    new_version = f"{major}.{minor}.{patch}"

    files_to_update = ["PyPDFForm/__init__.py", "mkdocs.yml", "SECURITY.md"]

    for each in files_to_update:
        with open(each, encoding="utf8") as f:
            content = f.read().replace(v, new_version)

        os.remove(each)
        with open(each, mode="w", encoding="utf8") as f:
            f.write(content)

### scripts/close_staled_issues.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""Closes GitHub issues older than 90 days."""

import json
import os
from datetime import UTC, datetime, timedelta

import requests
from dateutil.parser import parse

if __name__ == "__main__":
    token = os.environ.get("GITHUB_TOKEN")
    headers = {
        "Accept": "application/vnd.github+json",
        "Authorization": f"Bearer {token}",
    }

    issues = json.loads(
        requests.get(
            "https://api.github.com/repos/chinapandaman/PyPDFForm/issues",
            headers=headers,
        ).content
    )

    to_close = []
    for each in issues:
        labels = [label["name"] for label in each["labels"]]
        comments = json.loads(
            requests.get(each["comments_url"], headers=headers).content
        )
        if (
            comments
            and (
                datetime.now(tz=UTC)
                - parse(comments[-1]["updated_at"]).replace(tzinfo=UTC)
                > timedelta(days=90)
            )
            and "help wanted" not in labels
        ):
            to_close.append(each["url"])

    for each in to_close:
        requests.post(
            f"{each}/comments",
            headers=headers,
            json={"body": "Closing due to inactivity."},
        )
        requests.patch(each, headers=headers, json={"state": "closed"})

### scripts/create_pdf_diff.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""Creates a diff of a PDF between changes."""

import os
import sys

if __name__ == "__main__":
    path = sys.argv[1]

    with open(os.path.abspath(path), "rb+") as f:
        file_name = "_".join(path.split("/"))

        with open(
            os.path.join(os.path.dirname(__file__), "..", "temp", file_name), "wb+"
        ) as o:
            o.write(f.read())

### scripts/create_release.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""Creates a GitHub release."""

import os
import re
import sys

import requests

if __name__ == "__main__":
    with open("PyPDFForm/__init__.py", encoding="utf8") as f:
        version = re.search(r'__version__ = "(.*?)"', f.read())
        if version:
            version = version.group(1)

    latest_version = sys.argv[1].replace("(", "").replace(")", "")
    print(f"Latest deployed version: {latest_version}.")
    if latest_version == f"v{version}":
        sys.exit(f"{latest_version} is already deployed.")

    print(f"Bumping to: v{version}")
    token = os.environ.get("GITHUB_TOKEN")

    url = "https://api.github.com/repos/chinapandaman/PyPDFForm/releases"
    headers = {
        "Accept": "application/vnd.github+json",
        "Authorization": f"Bearer {token}",
    }
    body = {
        "tag_name": f"v{version}",
        "name": f"v{version}",
        "generate_release_notes": True,
    }

    response = requests.post(
        url=url,
        headers=headers,
        json=body,
    )

    if response.status_code == 201:
        print(f"Successfully deployed v{version}.")
    else:
        print(f"Failed deploying v{version}. Status code: {response.status_code}.")

### scripts/diff_widget.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""Serializing and compare the same widget across two PDF forms."""

import sys
from difflib import HtmlDiff
from io import StringIO
from pprint import pprint

from pypdf.generic import ArrayObject, DictionaryObject

from PyPDFForm.template import get_widget_key, get_widgets_by_page


def serializing_widget(widget, level):
    if hasattr(widget, "get_object"):
        widget = widget.get_object()

    level += 1
    if level == int(sys.argv[4]):
        return widget

    if isinstance(widget, (DictionaryObject, dict)):
        for k, v in widget.items():
            widget[k] = serializing_widget(v, level)
    elif isinstance(widget, ArrayObject):
        widget = ArrayObject([serializing_widget(each, level) for each in widget])

    return widget


def serializing_widget_from_file(filename, key, buff):
    with open(filename, "rb+") as f:
        widgets = get_widgets_by_page(f.read())

        for w in widgets.values():
            for widget in w:
                if get_widget_key(widget, False) == key:
                    pprint(serializing_widget(widget, 0), stream=buff)
                    buff.writelines("\n" * 3 + "=" * 100 + "\n" * 3)


if __name__ == "__main__":
    f1 = StringIO()
    f2 = StringIO()

    serializing_widget_from_file(sys.argv[1], sys.argv[3], f1)
    serializing_widget_from_file(sys.argv[2], sys.argv[3], f2)

    f1.seek(0)
    f2.seek(0)

    diff = HtmlDiff().make_file(f1.readlines(), f2.readlines())

    with open("temp/diff.html", "w") as f:
        f.write(diff)

### scripts/open_pdf_diff.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-
"""Opens a diff of a PDF between changes."""

import os
import sys
import webbrowser

if __name__ == "__main__":
    project_root = "PyPDFForm"
    if os.environ.get("PYPDFFORM_ENV") == "container":
        project_root = project_root.lower()
    before_path = sys.argv[1]
    file_name = "_".join(before_path.split("/"))
    after_path = os.path.join(os.path.dirname(__file__), "..", "temp", file_name)

    if (
        os.environ.get("CODESPACES") == "true"
        or os.environ.get("PYPDFFORM_ENV") == "container"
    ):
        base_url = "https://{}-8000.app.github.dev/".format(
            os.environ.get("CODESPACE_NAME")
        )
        if os.environ.get("PYPDFFORM_ENV") == "container":
            base_url = "http://localhost:8000/"
        print("Before:", base_url + before_path.split(f"{project_root}/")[1])
        print("After:", base_url + after_path.split(f"{project_root}/./scripts/../")[1])
    else:
        webbrowser.get("/usr/bin/google-chrome %s").open(before_path)
        webbrowser.get("/usr/bin/google-chrome %s").open(after_path)

        print("Checking", before_path)

### tests/conftest.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest


def pytest_configure(config):
    config.results = {}


def pytest_addoption(parser):
    parser.addoption("--regenerate", action="store", default="0")


@pytest.fixture(autouse=True)
def _generate_new_pdf_samples(request):
    request.config.results = {}
    yield
    if request.config.getoption("--regenerate") == "1" and request.config.results:
        with open(request.config.results["expected_path"], "wb+") as f:
            f.write(request.config.results["stream"])


@pytest.fixture
def pdf_samples():
    return os.path.join(os.path.dirname(__file__), "..", "pdf_samples")


@pytest.fixture
def static_pdfs():
    return os.path.join(os.path.dirname(__file__), "..", "docs", "pdfs")


@pytest.fixture
def template_stream(pdf_samples):
    with open(os.path.join(pdf_samples, "sample_template.pdf"), "rb+") as f:
        return f.read()


@pytest.fixture
def template_with_radiobutton_stream(pdf_samples):
    with open(
        os.path.join(pdf_samples, "sample_template_with_radio_button.pdf"), "rb+"
    ) as f:
        return f.read()


@pytest.fixture
def image_samples():
    return os.path.join(os.path.dirname(__file__), "..", "image_samples")


@pytest.fixture
def font_samples():
    return os.path.join(os.path.dirname(__file__), "..", "font_samples")


@pytest.fixture
def sample_font_stream(font_samples):
    with open(os.path.join(font_samples, "LiberationSerif-BoldItalic.ttf"), "rb+") as f:
        return f.read()


@pytest.fixture
def data_dict():
    return {
        "test": "test_1",
        "check": True,
        "test_2": "test_2",
        "check_2": False,
        "test_3": "test_3",
        "check_3": True,
    }


@pytest.fixture
def sejda_template(pdf_samples):
    with open(os.path.join(pdf_samples, "sample_template_sejda.pdf"), "rb+") as f:
        return f.read()


@pytest.fixture
def sejda_template_complex(pdf_samples):
    with open(
        os.path.join(pdf_samples, "paragraph", "sample_template_sejda_complex.pdf"),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_font_colors(pdf_samples):
    with open(
        os.path.join(pdf_samples, "sample_template_with_font_colors.pdf"), "rb+"
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_complex_fonts(pdf_samples):
    with open(
        os.path.join(pdf_samples, "sample_template_with_complex_fonts.pdf"), "rb+"
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_paragraph_complex(pdf_samples):
    with open(
        os.path.join(pdf_samples, "paragraph", "sample_template_paragraph_complex.pdf"),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_paragraph_max_length(pdf_samples):
    with open(
        os.path.join(
            pdf_samples, "paragraph", "sample_template_with_paragraph_max_length.pdf"
        ),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_max_length_text_field(pdf_samples):
    with open(
        os.path.join(pdf_samples, "sample_template_with_max_length_text_field.pdf"),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_comb_text_field(pdf_samples):
    with open(
        os.path.join(pdf_samples, "sample_template_with_comb_text_field.pdf"), "rb+"
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_comb_text_field_right_aligned(pdf_samples):
    with open(
        os.path.join(
            pdf_samples, "sample_template_with_comb_text_field_right_aligned.pdf"
        ),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_right_aligned_text_field(pdf_samples):
    with open(
        os.path.join(pdf_samples, "sample_template_with_right_aligned_text_field.pdf"),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_paragraph(pdf_samples):
    with open(
        os.path.join(pdf_samples, "paragraph", "sample_template_with_paragraph.pdf"),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_paragraph_auto_font(pdf_samples):
    with open(
        os.path.join(
            pdf_samples, "paragraph", "sample_template_with_paragraph_auto_font.pdf"
        ),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_dropdown(pdf_samples):
    with open(
        os.path.join(pdf_samples, "dropdown", "sample_template_with_dropdown.pdf"),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_image_field(pdf_samples):
    with open(
        os.path.join(pdf_samples, "sample_template_with_image_field.pdf"), "rb+"
    ) as f:
        return f.read()


@pytest.fixture
def sample_template_with_full_key(pdf_samples):
    with open(
        os.path.join(pdf_samples, "sample_template_with_full_key.pdf"), "rb+"
    ) as f:
        return f.read()


@pytest.fixture
def dropdown_alignment(pdf_samples):
    with open(
        os.path.join(pdf_samples, "dropdown", "dropdown_alignment.pdf"),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def dropdown_alignment_sejda(pdf_samples):
    with open(
        os.path.join(pdf_samples, "dropdown", "dropdown_alignment_sejda.pdf"),
        "rb+",
    ) as f:
        return f.read()


@pytest.fixture
def sejda_data():
    return {
        "date": "01-01",
        "year": "21",
        "buyer_name": "John Doe",
        "buyer_address": "1 N Main St, Chicago, IL 60000",
        "seller_name": "Jack Smith",
        "seller_address": "2 S Main St, Chicago, IL 60000",
        "make": "AK",
        "model": "47",
        "caliber": "7.62-x39mm",
        "serial_number": "111111",
        "purchase_option": 0,
        "date_of_this_bill": True,
        "at_future_date": True,
        "other": True,
        "other_reason": "NO REASONS",
        "payment_amount": "400",
        "future_date": "01-01",
        "future_year": "22",
        "exchange_for": "Food",
        "buyer_name_printed": "John Doe",
        "seller_name_printed": "Jack Smith",
        "buyer_signed_date": "2021-01-01",
        "seller_signed_date": "2021-01-01",
        "buyer_dl_number": "D000-4609-0001",
        "seller_dl_number": "S530-4209-0001",
        "buyer_dl_state": "IL",
        "seller_dl_state": "IL",
    }


@pytest.fixture
def max_length_expected_directory():
    return os.path.join(
        os.path.dirname(__file__),
        "..",
        "pdf_samples",
        "max_length_text_field_related",
    )

### tests/doc_examples/test_coordinate.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_coordinate_grid_view(pdf_samples, static_pdfs, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_coordinate_grid_view.pdf")

    grid_view_pdf = PdfWrapper(
        os.path.join(static_pdfs, "sample_template.pdf")
    ).generate_coordinate_grid(
        color=(1, 0, 0), margin=100  # optional
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = grid_view_pdf.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(grid_view_pdf.read()) == len(expected)
        assert grid_view_pdf.read() == expected

### tests/doc_examples/test_draw.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_draw_text(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_draw_text.pdf")

    pdf = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf")).draw_text(
        text="random text",
        page_number=1,
        x=300,
        y=225,
        font="Helvetica",  # optional
        font_size=12,  # optional
        font_color=(1, 0, 0),  # optional
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = pdf.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(pdf.read()) == len(expected)
        assert pdf.read() == expected


def test_draw_image(static_pdfs, image_samples, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_draw_image.pdf")

    pdf = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf")).draw_image(
        image=os.path.join(image_samples, "sample_image.jpg"),
        page_number=1,
        x=100,
        y=100,
        width=400,
        height=225,
        rotation=0,  # optional
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = pdf.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(pdf.read()) == len(expected)
        assert pdf.read() == expected

### tests/doc_examples/test_fill.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import PdfWrapper


def test_fill_text_check(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_fill_text_check.pdf")

    filled = PdfWrapper(
        os.path.join(static_pdfs, "sample_template.pdf"),
        adobe_mode=False,  # optional, set to True for Adobe Acrobat compatibility
    ).fill(
        {
            "test": "test_1",
            "check": True,
            "test_2": "test_2",
            "check_2": False,
            "test_3": "test_3",
            "check_3": True,
        },
        flatten=False,  # optional, set to True to flatten the filled PDF form
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = filled.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(filled.read()) == len(expected)
        assert filled.read() == expected


def test_fill_radio(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_fill_radio.pdf")

    filled = PdfWrapper(
        os.path.join(static_pdfs, "sample_template_with_radio_button.pdf"),
        adobe_mode=False,  # optional, set to True for Adobe Acrobat compatibility
    ).fill(
        {
            "radio_1": 0,
            "radio_2": 1,
            "radio_3": 2,
        },
        flatten=False,  # optional, set to True to flatten the filled PDF form
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = filled.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(filled.read()) == len(expected)
        assert filled.read() == expected


def test_fill_dropdown(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_fill_dropdown.pdf")

    filled = PdfWrapper(
        os.path.join(static_pdfs, "sample_template_with_dropdown.pdf"),
        adobe_mode=False,  # optional, set to True for Adobe Acrobat compatibility
    ).fill(
        {"dropdown_1": 1},
        flatten=False,  # optional, set to True to flatten the filled PDF form
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = filled.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(filled.read()) == len(expected)
        assert filled.read() == expected


def test_fill_dropdown_via_str(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_fill_dropdown.pdf")

    filled = PdfWrapper(
        os.path.join(static_pdfs, "sample_template_with_dropdown.pdf"),
        adobe_mode=False,  # optional, set to True for Adobe Acrobat compatibility
    ).fill(
        {"dropdown_1": "bar"},
        flatten=False,  # optional, set to True to flatten the filled PDF form
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = filled.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(filled.read()) == len(expected)
        assert filled.read() == expected


@pytest.mark.posix_only
def test_fill_sig(static_pdfs, pdf_samples, image_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_fill_sig.pdf")

    filled = PdfWrapper(
        os.path.join(static_pdfs, "sample_template_with_signature.pdf"),
        adobe_mode=False,  # optional, set to True for Adobe Acrobat compatibility
    ).fill(
        {"signature": os.path.join(image_samples, "sample_signature.png")},
        flatten=False,  # optional, set to True to flatten the filled PDF form
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = filled.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(filled.read()) == len(expected)
        assert filled.read() == expected


@pytest.mark.posix_only
def test_fill_sig_ratio(static_pdfs, pdf_samples, image_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_fill_sig_ratio.pdf")

    pdf = PdfWrapper(
        os.path.join(static_pdfs, "sample_template_with_signature.pdf"),
        adobe_mode=False,  # optional, set to True for Adobe Acrobat compatibility
    )
    pdf.widgets["signature"].preserve_aspect_ratio = False
    pdf.fill(
        {"signature": os.path.join(image_samples, "sample_signature.png")},
        flatten=False,  # optional, set to True to flatten the filled PDF form
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = pdf.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(pdf.read()) == len(expected)
        assert pdf.read() == expected


def test_fill_image(static_pdfs, pdf_samples, image_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_fill_image.pdf")

    filled = PdfWrapper(
        os.path.join(static_pdfs, "sample_template_with_image_field.pdf"),
        adobe_mode=False,  # optional, set to True for Adobe Acrobat compatibility
    ).fill(
        {"image_1": os.path.join(image_samples, "sample_image.jpg")},
        flatten=False,  # optional, set to True to flatten the filled PDF form
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = filled.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(filled.read()) == len(expected)
        assert filled.read() == expected


def test_fill_image_ratio(static_pdfs, pdf_samples, image_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_fill_image_ratio.pdf")

    pdf = PdfWrapper(os.path.join(static_pdfs, "sample_template_with_image_field.pdf"))
    pdf.widgets["image_1"].preserve_aspect_ratio = True
    pdf.fill(
        {"image_1": os.path.join(image_samples, "sample_image.jpg")},
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = pdf.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(pdf.read()) == len(expected)
        assert pdf.read() == expected

### tests/doc_examples/test_font.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_register_font(static_pdfs, sample_font_stream):
    obj = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))
    obj.register_font("new_font_name", sample_font_stream)

    assert "new_font_name" in obj.fonts

### tests/doc_examples/test_inspect.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_schema(static_pdfs):
    pdf_form_schema = PdfWrapper(
        os.path.join(static_pdfs, "sample_template.pdf")
    ).schema

    assert pdf_form_schema == {
        "type": "object",
        "properties": {
            "test": {"type": "string"},
            "check": {"type": "boolean"},
            "test_2": {"type": "string"},
            "check_2": {"type": "boolean"},
            "test_3": {"type": "string"},
            "check_3": {"type": "boolean"},
        },
    }


def test_data(static_pdfs):
    assert PdfWrapper(os.path.join(static_pdfs, "sample_template_filled.pdf")).data == {
        "check": True,
        "check_2": True,
        "check_3": True,
        "test": "test",
        "test_2": "test2",
        "test_3": "test3",
    }


def test_sample_data(static_pdfs):
    assert PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf")).sample_data == {
        "check": True,
        "check_2": True,
        "check_3": True,
        "test": "test",
        "test_2": "test_2",
        "test_3": "test_3",
    }

### tests/doc_examples/test_install.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_create_pdf_wrapper(static_pdfs):
    pdf = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))

    assert pdf.read()

    with open(os.path.join(static_pdfs, "sample_template.pdf"), "rb+") as template:
        pdf_2 = PdfWrapper(template)

    with open(os.path.join(static_pdfs, "sample_template.pdf"), "rb+") as template:
        pdf_3 = PdfWrapper(template.read())

    assert pdf.read() == pdf_2.read()
    assert pdf.read() == pdf_3.read()


def test_create_adobe_mode_wrapper(static_pdfs):
    pdf = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"), adobe_mode=True)

    assert getattr(pdf, "adobe_mode")
    assert (
        pdf.read()
        != PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf")).read()
    )


def test_use_full_widget_name(static_pdfs):
    pdf = PdfWrapper(
        os.path.join(static_pdfs, "sample_template_with_full_key.pdf"),
        use_full_widget_name=True,
    )

    assert getattr(pdf, "use_full_widget_name")
    assert "Gain de 2 classes.0" in pdf.widgets
    assert "0" not in pdf.widgets

### tests/doc_examples/test_prepare.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import Fields, PdfWrapper


@pytest.mark.posix_only
def test_create_text(pdf_samples, sample_font_stream, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_create_text.pdf")

    new_form = (
        PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"))
        .register_font(
            "your_registered_font",
            sample_font_stream,
        )
        .create_field(
            Fields.TextField(
                name="new_text_field",
                page_number=1,
                x=57,
                y=700,
                required=False,  # optional
                tooltip="this is a text field",  # optional
                width=120,  # optional
                height=40,  # optional
                max_length=10,  # optional, number of characters
                comb=True,  # optional, when set to True, max_length must also be set
                font="your_registered_font",  # optional
                font_size=15,  # optional
                font_color=(0, 1, 0),  # optional
                bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)
                border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)
                border_width=5,  # optional
                alignment=2,  # optional, 0=left, 1=center, 2=right
                multiline=False,  # optional
            )
        )
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


@pytest.mark.posix_only
def test_create_check(pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_create_check.pdf")

    new_form = PdfWrapper(os.path.join(pdf_samples, "dummy.pdf")).create_field(
        Fields.CheckBoxField(
            name="new_checkbox",
            page_number=1,
            x=57,
            y=700,
            required=False,  # optional
            tooltip="this is a checkbox",  # optional
            size=50,  # optional
            button_style="cross",  # optional
            tick_color=(0, 1, 0),  # optional
            bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)
            border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)
            border_width=5,  # optional
        )
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


@pytest.mark.posix_only
def test_create_radio(pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_create_radio.pdf")

    new_form = PdfWrapper(os.path.join(pdf_samples, "dummy.pdf")).create_field(
        Fields.RadioGroup(
            name="new_radio_group",
            page_number=1,
            x=[50, 100, 150],
            y=[50, 100, 150],
            required=False,  # optional
            tooltip="this is a radio group",  # optional
            size=40,  # optional
            button_style="circle",  # optional
            shape="square",  # optional, circle or square
            tick_color=(0, 1, 0),  # optional
            bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)
            border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)
            border_width=5,  # optional
        )
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


@pytest.mark.posix_only
def test_create_dropdown(pdf_samples, sample_font_stream, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_create_dropdown.pdf")

    new_form = (
        PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"))
        .register_font("your_registered_font", sample_font_stream)
        .create_field(
            Fields.DropdownField(
                name="new_dropdown",
                page_number=1,
                x=57,
                y=700,
                options=[
                    "foo",
                    "bar",
                    "foobar",
                ],
                required=False,  # optional
                tooltip="this is a dropdown",  # optional
                width=120,  # optional
                height=40,  # optional
                font="your_registered_font",  # optional
                font_size=15,  # optional
                font_color=(0, 1, 0),  # optional
                bg_color=(0, 0, 1, 1),  # optional, (r, g, b, alpha)
                border_color=(1, 0, 0, 1),  # optional, (r, g, b, alpha)
                border_width=5,  # optional
            )
        )
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


@pytest.mark.posix_only
def test_create_dropdown_with_export_values(pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "docs", "test_create_dropdown_with_export_values.pdf"
    )

    new_form = PdfWrapper(os.path.join(pdf_samples, "dummy.pdf")).create_field(
        Fields.DropdownField(
            name="new_dropdown",
            page_number=1,
            x=57,
            y=700,
            options=[
                ("option_1", "option_1_export_value"),
                ("option_2", "option_2_export_value"),
                ("option_3", "option_3_export_value"),
            ],
        )
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


def test_create_sig(pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_create_sig.pdf")

    new_form = PdfWrapper(os.path.join(pdf_samples, "dummy.pdf")).create_field(
        Fields.SignatureField(
            name="new_signature",
            page_number=1,
            x=100,
            y=100,
            required=False,  # optional
            tooltip="this is a signature",  # optional
            width=410,  # optional
            height=100,  # optional
        )
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


def test_create_image(pdf_samples, request):

### tests/doc_examples/test_prepare.py [2/2] (lang=Python)

cted = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


def test_create_image(pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_create_image.pdf")

    new_form = PdfWrapper(os.path.join(pdf_samples, "dummy.pdf")).create_field(
        Fields.ImageField(
            name="new_image",
            page_number=1,
            x=100,
            y=100,
            required=False,  # optional
            tooltip="this is an image",  # optional
            width=192,  # optional
            height=108,  # optional
        )
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


def test_update_key(static_pdfs):
    new_form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))
    assert "test" in new_form.widgets
    new_form.update_widget_key("test", "test_text")
    assert "test" not in new_form.widgets
    assert "test_text" in new_form.widgets


def test_update_key_index(pdf_samples, static_pdfs, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_update_key_index.pdf")

    new_form = PdfWrapper(os.path.join(static_pdfs, "733.pdf")).update_widget_key(
        "Description[0]", "Description[1]", index=1
    )

    new_form.fill(new_form.sample_data)

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected


def test_update_key_bulk(pdf_samples, static_pdfs, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_update_key_bulk.pdf")

    new_form = PdfWrapper(os.path.join(static_pdfs, "733.pdf"))
    for i in range(1, 10):
        new_form.update_widget_key(
            "Description[0]", f"Description[{i}]", index=1, defer=True
        )
    new_form.commit_widget_key_updates()

    new_form.fill(new_form.sample_data)

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = new_form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(new_form.read()) == len(expected)
        assert new_form.read() == expected

### tests/doc_examples/test_style.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import PdfWrapper, Text


@pytest.mark.posix_only
def test_change_text_font(static_pdfs, sample_font_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_text_font.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))
    form.register_font("new_font_name", sample_font_stream)

    # change globally by iterating each text field
    for field in form.widgets.values():
        if isinstance(field, Text):
            field.font = "new_font_name"

    # or change at each field's widget level
    form.widgets["test"].font = "new_font_name"

    form.fill(
        {
            "test": "test_1",
            "check": True,
            "test_2": "test_2",
            "check_2": False,
            "test_3": "test_3",
            "check_3": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_text_font_size(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_text_font_size.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))

    # change globally by iterating each text field
    for field in form.widgets.values():
        if isinstance(field, Text):
            field.font_size = 20

    # or change at each field's widget level
    form.widgets["test"].font_size = 30.5

    form.fill(
        {
            "test": "test_1",
            "check": True,
            "test_2": "test_2",
            "check_2": False,
            "test_3": "test_3",
            "check_3": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_text_font_color(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_text_font_color.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))

    # change globally by iterating each text field
    for field in form.widgets.values():
        if isinstance(field, Text):
            field.font_color = (1, 0, 0)

    # or change at each field's widget level
    form.widgets["test"].font_color = (0.2, 0, 0.5)

    form.fill(
        {
            "test": "test_1",
            "check": True,
            "test_2": "test_2",
            "check_2": False,
            "test_3": "test_3",
            "check_3": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_text_alignment(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_text_alignment.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))

    # change globally by iterating each text field
    for field in form.widgets.values():
        if isinstance(field, Text):
            field.alignment = 1  # center

    # or change at each field's widget level
    form.widgets["test"].alignment = 2  # right

    form.fill(
        {
            "test": "test_1",
            "check": True,
            "test_2": "test_2",
            "check_2": False,
            "test_3": "test_3",
            "check_3": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_text_max_length(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_text_max_length.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))

    # change globally by iterating each text field
    for field in form.widgets.values():
        if isinstance(field, Text):
            field.max_length = 4

    # or change at each field's widget level
    form.widgets["test"].max_length = 2

    form.fill(
        {
            "test": "test_1",
            "check": True,
            "test_2": "test_2",
            "check_2": False,
            "test_3": "test_3",
            "check_3": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_text_comb(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_text_comb.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))

    # change globally by iterating each text field
    for field in form.widgets.values():
        if isinstance(field, Text):
            field.max_length = 4
            field.comb = True

    # or change at each field's widget level
    form.widgets["test"].max_length = 2
    form.widgets["test"].comb = True

    form.fill(
        {
            "test": "test_1",
            "check": True,
            "test_2": "test_2",
            "check_2": False,
            "test_3": "test_3",
            "check_3": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_text_multiline(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_text_multiline.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))

    form.widgets["test"].multiline = True

    form.fill(
        {
            "test": "test_1\ntest_1",
            "check": True,
            "test_2": "test_2\ntest_2",
            "check_2": False,
            "test_3": "test_3\ntest_3",
            "check_3": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_check_size(static_pdfs, pdf_samples, request):

### tests/doc_examples/test_style.py [2/2] (lang=Python)

ead()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_check_size(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_check_size.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))

    form.widgets["check"].size = 50
    form.widgets["check_2"].size = 40
    form.widgets["check_3"].size = 60

    form.fill(
        {
            "check": True,
            "check_2": True,
            "check_3": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_dropdown_choices(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "docs", "test_change_dropdown_choices.pdf"
    )

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template_with_dropdown.pdf"))

    form.widgets["dropdown_1"].choices = ["", "apple", "banana", "cherry", "dates"]

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_dropdown_choices_with_export_values(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "docs", "test_change_dropdown_choices_with_export_values.pdf"
    )

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template_with_dropdown.pdf"))

    form.widgets["dropdown_1"].choices = [
        ("", "blank_export_value"),
        ("apple", "apple_export_value"),
        ("banana", "banana_export_value"),
        ("cherry", "cherry_export_value"),
        ("dates", "dates_export_value"),
    ]

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


@pytest.mark.posix_only
def test_change_dropdown_font(static_pdfs, pdf_samples, sample_font_stream, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_change_dropdown_font.pdf")

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template_with_dropdown.pdf"))

    form.register_font("new_font_name", sample_font_stream)

    form.widgets["dropdown_1"].font = "new_font_name"

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_dropdown_font_size(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "docs", "test_change_dropdown_font_size.pdf"
    )

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template_with_dropdown.pdf"))

    form.widgets["dropdown_1"].font_size = 30

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_dropdown_font_color(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "docs", "test_change_dropdown_font_color.pdf"
    )

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template_with_dropdown.pdf"))

    form.widgets["dropdown_1"].font_color = (1, 0, 0)

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected


def test_change_field_editability(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "docs", "test_change_field_editability.pdf"
    )

    form = PdfWrapper(os.path.join(static_pdfs, "sample_template_with_dropdown.pdf"))

    form.fill(
        {
            "test_1": "test_1",
            "test_2": "test_2",
            "test_3": "test_3",
            "check_1": True,
            "check_2": True,
            "check_3": True,
            "radio_1": 1,
            "dropdown_1": 0,
        },
        flatten=True,
    )
    form.widgets["test_2"].readonly = False  # text
    form.widgets["check_3"].readonly = False  # checkbox
    form.widgets["radio_1"].readonly = False  # radio button group
    form.widgets["dropdown_1"].readonly = False  # dropdown

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = form.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(form.read()) == len(expected)
        assert form.read() == expected

### tests/doc_examples/test_utils.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_extract_pages(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_extract_pages.pdf")

    first_page = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf")).pages[0]
    first_page.fill(
        {
            "test": "test_1",
            "check": True,
        },
    )

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = first_page.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(first_page.read()) == len(expected)
        assert first_page.read() == expected


def test_merge(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_merge.pdf")

    pdf_one = PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"))
    pdf_two = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))
    merged = pdf_one + pdf_two

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = merged.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(merged.read()) == len(expected)
        assert merged.read() == expected


def test_reorg_pages(static_pdfs, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "docs", "test_reorg_pages.pdf")

    pdf_one = PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"))
    pdf_two = PdfWrapper(os.path.join(static_pdfs, "sample_template.pdf"))
    merged = pdf_two.pages[0] + pdf_one + pdf_two.pages[1] + pdf_two.pages[2]

    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = merged.read()

    with open(expected_path, "rb+") as f:
        expected = f.read()

        assert len(merged.read()) == len(expected)
        assert merged.read() == expected


def test_change_version(static_pdfs):
    new_version = PdfWrapper(
        os.path.join(static_pdfs, "sample_template.pdf")
    ).change_version("2.0")

    assert new_version.version == "2.0"

### tests/multi_language/conftest.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest


@pytest.fixture
def multi_language_pdf_samples():
    return os.path.join(
        os.path.dirname(__file__), "..", "..", "pdf_samples", "multi_language"
    )


@pytest.fixture
def zh_cn(multi_language_pdf_samples):
    return os.path.join(multi_language_pdf_samples, "zh_cn")


@pytest.fixture
def ko(multi_language_pdf_samples):
    return os.path.join(multi_language_pdf_samples, "ko")

### tests/multi_language/test_multi_language.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_zh_cn(zh_cn, request):
    expected_path = os.path.join(zh_cn, "test_zh_cn.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(os.path.join(zh_cn, "zh_cn.pdf")).fill(
            {
                "": "",
                "": "",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ko(ko, request):
    expected_path = os.path.join(ko, "test_ko.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(os.path.join(ko, "ko.pdf")).fill(
            {
                "": "",
                "": "",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/scenario/conftest.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest


@pytest.fixture
def pdf_directory():
    return os.path.join(
        os.path.dirname(__file__), "..", "..", "pdf_samples", "scenario"
    )


@pytest.fixture
def issue_pdf_directory(pdf_directory):
    return os.path.join(pdf_directory, "issues")


@pytest.fixture
def tool_pdf_directory(pdf_directory):
    return os.path.join(pdf_directory, "tools")


@pytest.fixture
def existed_pdf_directory(pdf_directory):
    return os.path.join(pdf_directory, "existed")

### tests/scenario/test_existed.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_illinois_gun_bill_of_sale(existed_pdf_directory, request):
    obj = PdfWrapper(
        os.path.join(existed_pdf_directory, "illinois-gun-bill-of-sale.pdf")
    ).fill(
        {
            "Date": "01-01",
            "20": "22",
            "Buyers Name": "John Doe",
            "undefined": "1 N Main St, Chicago, IL 60000",
            "Sellers Name": "Jack Smith",
            "undefined_2": "2 S Main St, Chicago, IL 60000",
            "Make": "AK",
            "TypeModel": "47",
            "Caliber": "7.62-x39mm",
            "Serial Number SN": "111111",
            "Seller accepts cash payment in the amount of": True,
            "The date of this bill of sale": True,
            "At a future date no later than": True,
            "Other": True,
            "undefined_4": "NO REASONS",
            "to": "400",
            "undefined_3": "01-01",
            "20_2": "23",
            "undefined_5": "Food",
            "Buyer is receiving the Firearm as a Gift": True,
            "Seller accepts trade for the Firearm in exchange for": True,
            "Print Name": "John Doe",
            "Print Name_2": "Jack Smith",
            "Date_2": "2021-01-01",
            "Date_3": "2021-01-01",
            "Drivers License Number": "D000-4609-0001",
            "Drivers License Number_2": "S530-4209-0001",
            "State": "IL",
            "State_2": "IL",
        }
    )

    expected_path = os.path.join(
        existed_pdf_directory, "test_illinois_gun_bill_of_sale.pdf"
    )
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(
        expected_path,
        "rb+",
    ) as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ds82(existed_pdf_directory, request):
    obj = PdfWrapper(os.path.join(existed_pdf_directory, "DS82.pdf")).fill(
        {
            "LastName": "Smith",
        }
    )

    expected_path = os.path.join(
        existed_pdf_directory,
        "test_ds82.pdf",
    )
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(
        expected_path,
        "rb+",
    ) as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ds82_all_chars_lowercase(existed_pdf_directory, request):
    obj = PdfWrapper(os.path.join(existed_pdf_directory, "DS82.pdf")).fill(
        {
            "LastName": "x" * 30,
        }
    )

    expected_path = os.path.join(
        existed_pdf_directory,
        "test_ds82_all_chars_lowercase.pdf",
    )
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(
        expected_path,
        "rb+",
    ) as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ds82_all_chars_uppercase(existed_pdf_directory, request):
    obj = PdfWrapper(os.path.join(existed_pdf_directory, "DS82.pdf")).fill(
        {
            "LastName": "X" * 30,
        }
    )

    expected_path = os.path.join(
        existed_pdf_directory,
        "test_ds82_all_chars_uppercase.pdf",
    )
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(
        expected_path,
        "rb+",
    ) as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ds82_mixed_case(existed_pdf_directory, request):
    obj = PdfWrapper(os.path.join(existed_pdf_directory, "DS82.pdf")).fill(
        {
            "LastName": "xX" * 10,
        }
    )

    expected_path = os.path.join(
        existed_pdf_directory,
        "test_ds82_mixed_case.pdf",
    )
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(
        expected_path,
        "rb+",
    ) as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_illinois_real_estate_power_of_attorney_form(existed_pdf_directory, request):
    obj = PdfWrapper(
        os.path.join(
            existed_pdf_directory, "illinois-real-estate-power-of-attorney-form.pdf"
        )
    ).fill(
        {
            "undefined": "John Doe",
            "State of": "Chicago",
            "undefined_2": "Illinois",
            "of": "Michael Smith",
            "Illinois as my Attorneyin": "Chicago",
            "with full power and": "Random",
            "is as": "Not Random",
            "Address of Principal": "1 N Central, Chicago, IL 60000",
            "Phone number where Principal can be contacted": "(000)000-0000",
            "Email address of Principal": "msmith@example.com",
            "Text3": "Someone",
            "Dated": "2018-01-01",
            "Text4": "Sometwo",
            "Text5": "Somethree",
            "Text6": "Somefour",
            "Dated 1": "2019-01-01",
            "My commission expires": "NOW",
        }
    )

    expected_path = os.path.join(
        existed_pdf_directory,
        "test_illinois_real_estate_power_of_attorney_form.pdf",
    )
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(
        expected_path,
        "rb+",
    ) as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_clear_form_button_not_checkbox(existed_pdf_directory):
    obj = PdfWrapper(os.path.join(existed_pdf_directory, "ds11_pdf.pdf"))

    assert "Clear" not in obj.widgets

### tests/scenario/test_issues.py [1/4] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest
from pypdf import PdfReader

from PyPDFForm import PdfWrapper
from PyPDFForm.constants import TU, Parent, V
from PyPDFForm.middleware.radio import Radio
from PyPDFForm.template import get_widget_key, get_widgets_by_page
from PyPDFForm.utils import stream_to_io


def test_pdf_form_with_pages_without_widgets(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-246.pdf")).fill(
        {"QCredit": "5000.63"}
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-246-expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_pdf_form_with_central_aligned_text_fields(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-285.pdf")).fill(
        {
            "name": "Hans Mustermann",
            "fulladdress": "Musterstr. 12, 82903 Musterdorf, Musterland",
            "advisorname": "Karl Test",
        }
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-285-expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_pdf_form_with_central_aligned_text_fields_void(issue_pdf_directory):
    assert PdfWrapper(os.path.join(issue_pdf_directory, "PPF-285.pdf")).fill({}).read()


@pytest.mark.posix_only
def test_pdf_form_with_paragraph_fields_new_line_symbol_text(
    issue_pdf_directory, request
):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-415.pdf")).fill(
        {"Address": "Mr John Smith\n132, My Street\nKingston, New York 12401"}
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-415-expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_pdf_form_with_paragraph_fields_new_line_symbol_text_overflow(
    issue_pdf_directory, request
):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-415-2.pdf")).fill(
        {
            "multiline-text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Malesuada proin libero nunc consequat interdum varius sit amet mattis. Nec tincidunt praesent semper feugiat nibh sed.\nSed libero enim sed faucibus turpis. Cursus in hac habitasse platea dictumst quisque sagittis. Placerat in egestas erat imperdiet sed euismod. Id aliquet risus feugiat in ante metus dictum at. Proin fermentum leo vel orci porta non pulvinar. Consequat semper viverra nam libero justo.\nPellentesque massa placerat duis ultricies lacus sed. Amet est placerat in egestas erat imperdiet sed euismod nisi. Id cursus metus aliquam eleifend mi. Massa massa ultricies mi quis. Volutpat consequat mauris nunc congue nisi vitae suscipit tellus. Ut tellus elementum sagittis vitae.\n\nEtiam sit amet nisl purus in mollis nunc. Vel turpis nunc eget lorem dolor sed. Ultrices dui sapien eget mi proin sed libero enim. Condimentum id venenatis a condimentum vitae sapien pellentesque habitant. Libero volutpat sed cras ornare arcu. Commodo quis imperdiet massa tincidunt nunc pulvinar sapien et ligula. Nisi est sit amet facilisis magna etiam. In iaculis nunc sed augue.\nSapien pellentesque habitant morbi tristique.\nCondimentum mattis pellentesque id nibh tortor id aliquet. Porttitor massa id neque aliquam vestibulum. Feugiat in fermentum posuere urna nec tincidunt praesent semper. Malesuada fames ac turpis egestas integer. Aenean vel elit scelerisque mauris pellentesque. Vel turpis nunc eget lorem dolor sed viverra. Nec feugiat nisl pretium fusce id velit ut tortor."
        }
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-415-2-expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_521(issue_pdf_directory, request):
    expected_path = os.path.join(issue_pdf_directory, "521-expected.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(os.path.join(issue_pdf_directory, "521.pdf")).fill(
            {
                "Text1": "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?",
                "Text2": "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. NEMO ENIM IPSAM VOLUPTATEM QUIA VOLUPTAS SIT ASPERNATUR AUT ODIT AUT FUGIT, SED QUIA CONSEQUUNTUR MAGNI DOLORES EOS QUI RATIONE VOLUPTATEM SEQUI NESCIUNT. NEQUE PORRO QUISQUAM EST, QUI DOLOREM IPSUM QUIA DOLOR SIT AMET, CONSECTETUR, ADIPISCI VELIT, SED QUIA NON NUMQUAM EIUS MODI TEMPORA INCIDUNT UT LABORE ET DOLORE MAGNAM ALIQUAM QUAERAT VOLUPTATEM. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?",
                "Text3": "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only

### tests/scenario/test_issues.py [2/4] (lang=Python)

def test_pdf_form_with_paragraph_fields_new_line_symbol_short_text(
    issue_pdf_directory, request
):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-415.pdf")).fill(
        {"Address": "J Smith\n132 A St\nNYC, NY 12401"}
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-415-3-expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_encrypted_edit_pdf_form(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "437.pdf"))
    obj = obj.fill(obj.sample_data)
    expected_path = os.path.join(issue_pdf_directory, "437_expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_image(issue_pdf_directory, image_samples, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "560.pdf"))
    obj = obj.fill({"ImageSign": os.path.join(image_samples, "sample_image.jpg")})
    expected_path = os.path.join(issue_pdf_directory, "560_expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_reduce_paragraph_overflow_text_font_size(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-620.pdf")).fill(
        {
            "301 What Happened": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris congue, lorem sit amet venenatis lacinia, quam tortor pharetra ante, id facilisis neque velit ac tellus. Nam tincidunt felis quis eros malesuada, ac congue elit consequat. Ut eget porttitor augue. Integer ullamcorper lectus et est scelerisque, ac posuere mi tempor. Nunc vulputate vehicula bibendum. Aliquam erat volutpat. Morbi tortor."
        }
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-620-expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ppf_627_schema(issue_pdf_directory):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-627.pdf"))

    assert obj.schema["properties"]["S1 GF 7"]["maximum"] == 3


def test_ppf_627_fill_0(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-627.pdf")).fill(
        {"S1 GF 7": 0}
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-627-expected-0.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ppf_627_fill_1(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-627.pdf")).fill(
        {"S1 GF 7": 1}
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-627-expected-1.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ppf_627_fill_2(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-627.pdf")).fill(
        {"S1 GF 7": 2}
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-627-expected-2.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_ppf_627_fill_3(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-627.pdf")).fill(
        {"S1 GF 7": 3}
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-627-expected-3.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_sejda_checkbox(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "683.pdf")).fill(
        {"test_checkbox": True}
    )

    expected_path = os.path.join(issue_pdf_directory, "683_expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_update_key(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "733.pdf"))

    for i in range(1, 10):
        obj.update_widget_key("Description[0]", f"Description[{i}]", 1)
        obj.update_widget_key("symbol[0]", f"symbol[{i}]", 1)
        obj.update_widget_key("tradedate[0]", f"tradedate[{i}]", 1)
        obj.update_widget_key("settlementdate[0]", f"settlementdate[{i}]", 1)
        obj.update_widget_key("quantity[0]", f"quantity[{i}]", 1)
        obj.update_widget_key("costperunit[0]", f"costperunit[{i}]", 1)
        obj.update_widget_key("costabasis[0]", f"costabasis[{i}]", 1)

    obj.fill(obj.sample_data)

    expected_path = os.path.join(issue_pdf_directory, "733_expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_update_key_persist_properties(issue_pdf_directory, request):

### tests/scenario/test_issues.py [3/4] (lang=Python)

)
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_update_key_persist_properties(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "733.pdf"))
    obj.widgets["SchwabAccountNumber[0]"].font_size = 20

    for i in range(1, 10):
        obj.update_widget_key("Description[0]", f"Description[{i}]", 1)
        obj.update_widget_key("symbol[0]", f"symbol[{i}]", 1)
        obj.update_widget_key("tradedate[0]", f"tradedate[{i}]", 1)
        obj.update_widget_key("settlementdate[0]", f"settlementdate[{i}]", 1)
        obj.update_widget_key("quantity[0]", f"quantity[{i}]", 1)
        obj.update_widget_key("costperunit[0]", f"costperunit[{i}]", 1)
        obj.update_widget_key("costabasis[0]", f"costabasis[{i}]", 1)

    assert obj.widgets["SchwabAccountNumber[0]"].font_size == 20
    obj.fill(obj.sample_data)

    expected_path = os.path.join(issue_pdf_directory, "733_expected_2.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_bulk_update_key(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "733.pdf"))

    for i in range(1, 10):
        obj.update_widget_key("Description[0]", f"Description[{i}]", 1, defer=True)
        obj.update_widget_key("symbol[0]", f"symbol[{i}]", 1, defer=True)
        obj.update_widget_key("tradedate[0]", f"tradedate[{i}]", 1, defer=True)
        obj.update_widget_key(
            "settlementdate[0]", f"settlementdate[{i}]", 1, defer=True
        )
        obj.update_widget_key("quantity[0]", f"quantity[{i}]", 1, defer=True)
        obj.update_widget_key("costperunit[0]", f"costperunit[{i}]", 1, defer=True)
        obj.update_widget_key("costabasis[0]", f"costabasis[{i}]", 1, defer=True)

    obj.commit_widget_key_updates()
    obj.fill(obj.sample_data)

    expected_path = os.path.join(issue_pdf_directory, "733_expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_get_desc_in_schema(issue_pdf_directory):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "757.pdf"))

    assert (
        obj.schema["properties"]["P1_checkbox4[0]"]["description"]
        == "Part 1. Information About You. Your Full Name. 4. Has your name legally changed since the issuance of your Permanent Resident Card? Select Yes. (Proceed to Item Numbers 5. A. through 5. C.)."
    )
    assert (
        obj.schema["properties"]["P1_checkbox4[1]"]["description"]
        == "Part 1. Information About You. Your Full Name. 4. Has your name legally changed since the issuance of your Permanent Resident Card? Select No (Proceed to Item Numbers 6. A. through 6. I.)."
    )
    assert (
        obj.schema["properties"]["P1_checkbox4[2]"]["description"]
        == "Part 1. Information About You. Your Full Name. 4. Has your name legally changed since the issuance of your Permanent Resident Card? Select Not Applicable - I never received my previous card. (Proceed to Item Numbers 6. A. through 6. I.)."
    )


def test_get_desc_in_schema_radio(issue_pdf_directory):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-620.pdf"))

    keys_to_check = []
    for key, value in obj.widgets.items():
        if isinstance(value, Radio) and value.tooltip is not None:
            keys_to_check.append(key)

    for widgets in get_widgets_by_page(obj.read()).values():
        for widget in widgets:
            key = get_widget_key(widget, False)

            if key in keys_to_check:
                assert (
                    widget[Parent][TU] == obj.schema["properties"][key]["description"]
                )


def test_use_full_widget_name_1(issue_pdf_directory, request):
    obj = PdfWrapper(
        os.path.join(issue_pdf_directory, "PPF-939.pdf"), use_full_widget_name=True
    ).fill(
        {
            "topmostSubform[0].Page1[0].c1_3[1]": False,
            "topmostSubform[0].Page1[0].FilingStatus_ReadOrder[0].c1_3[1]": True,
        }
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-939_expected_1.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_use_full_widget_name_2(issue_pdf_directory, request):
    obj = PdfWrapper(
        os.path.join(issue_pdf_directory, "PPF-939.pdf"), use_full_widget_name=True
    ).fill(
        {
            "topmostSubform[0].Page1[0].c1_3[1]": True,
            "topmostSubform[0].Page1[0].FilingStatus_ReadOrder[0].c1_3[1]": False,
        }
    )

    expected_path = os.path.join(issue_pdf_directory, "PPF-939_expected_2.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_use_full_widget_name_both(issue_pdf_directory):
    obj = PdfWrapper(
        os.path.join(issue_pdf_directory, "PPF-939.pdf"), use_full_widget_name=True
    ).fill(
        {
            "topmostSubform[0].Page1[0].c1_3[1]": True,
            "topmostSubform[0].Page1[0].FilingStatus_ReadOrder[0].c1_3[1]": True,
        }
    )

    assert (
        obj.read()
        == PdfWrapper(os.path.join(issue_pdf_directory, "PPF-939.pdf"))
        .fill(
            {
                "c1_3[1]": True,
            }
        )
        .read()
    )


def test_polish(issue_pdf_directory, request):

### tests/scenario/test_issues.py [4/4] (lang=Python)

))
        .fill(
            {
                "c1_3[1]": True,
            }
        )
        .read()
    )


def test_polish(issue_pdf_directory, request):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "949.pdf")).fill(
        {
            "topmostSubform[0].Page1[0].PESEL[0]": "12345671111",
            "topmostSubform[0].Page2[0].PESEL[0]": "12345672222",
            "topmostSubform[0].Page1[0].Imi[0]": "ucja",
            "topmostSubform[0].Page1[0].Nazwisko[0]": "-Pitkowska",
            "topmostSubform[0].Page1[0].Dataurodzenia[0]": "01021992",
            "topmostSubform[0].Page1[0].Miejscowo[0]": "witochowice-kawa",
            "topmostSubform[0].Page1[0].Ulica[0]": "Krta",
            "topmostSubform[0].Page1[0].Numerdomu[0]": "13",
            "topmostSubform[0].Page2[0].OrzeczenieTAK[0]": 1,
        }
    )

    expected_path = os.path.join(issue_pdf_directory, "949_expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_polish_use_full_widget_name(issue_pdf_directory, request):
    obj = PdfWrapper(
        os.path.join(issue_pdf_directory, "949_new.pdf"), use_full_widget_name=True
    ).fill(
        {
            "topmostSubform[0].Page1[0].PESEL[0]": "12345671111",
            "topmostSubform[0].Page2[0].PESEL[0]": "12345672222",
            "topmostSubform[0].Page1[0].Imi[0]": "ucja",
            "topmostSubform[0].Page1[0].Nazwisko[0]": "-Pitkowska",
            "topmostSubform[0].Page1[0].Dataurodzenia[0]": "01021992",
            "topmostSubform[0].Page1[0].Miejscowo[0]": "witochowice-kawa",
            "topmostSubform[0].Page1[0].Ulica[0]": "Krta",
            "topmostSubform[0].Page1[0].Numerdomu[0]": "13",
            "topmostSubform[0].Page2[0].OrzeczenieTAK[0]": 1,
        }
    )

    assert "PESEL[0]" not in obj.schema

    expected_path = os.path.join(issue_pdf_directory, "949_new_expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_merge_sejda_pdf_forms(issue_pdf_directory):
    data = [
        {"name": "John", "dob": "1990-01-01", "note": "test1"},
        {"name": "James", "dob": "1992-06-15", "note": "test2"},
        {"name": "Dan", "dob": "1988-12-30", "note": "test3"},
    ]

    obj = PdfWrapper(adobe_mode=True)

    for i in range(3):
        obj += PdfWrapper(
            os.path.join(issue_pdf_directory, "PPF-884.pdf"), adobe_mode=True
        ).fill(data[i])

    result = PdfReader(stream_to_io(obj.read()))

    for i, page in enumerate(result.pages):
        page_data = data[i]
        for widget in page.annotations or []:
            key = get_widget_key(widget, use_full_widget_name=False)
            for k, v in page_data.items():
                if key.startswith(k):
                    assert widget[Parent][V] == v


def test_xfa_to_regular_form(issue_pdf_directory, request):
    obj = PdfWrapper(
        os.path.join(issue_pdf_directory, "1087.pdf"), adobe_mode=True
    ).fill(
        {
            "G28CheckBox[0]": True,
            "Pt1Line1a_FamilyName[0]": "Mylastname",
            "Pt1Line1b_GivenName[0]": "Myfirstname",
            "Line2_CompanyName[0]": "The company LLC",
        }
    )

    expected_path = os.path.join(issue_pdf_directory, "1087_expected.pdf")
    request.config.results["expected_path"] = expected_path
    request.config.results["stream"] = obj.read()
    with open(expected_path, "rb+") as f:
        expected = f.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_full_widget_name(issue_pdf_directory):
    obj = PdfWrapper(
        os.path.join(issue_pdf_directory, "PPF-1159.pdf"), use_full_widget_name=True
    )

    assert "Ancestry.Page 1" in obj.widgets


def test_extract_multiline_property(issue_pdf_directory):
    obj = PdfWrapper(os.path.join(issue_pdf_directory, "PPF-1162.pdf"))

    for k, v in obj.widgets.items():
        if "AdditionalInfo" in k:
            assert v.multiline

### tests/scenario/test_tools.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import PdfWrapper


def test_filling_pdf_escape_pdf_form(tool_pdf_directory, request):
    expected_path = os.path.join(
        tool_pdf_directory, "test_filling_pdf_escape_pdf_form.pdf"
    )
    with open(expected_path, "rb+") as f:
        expected = f.read()
        result = PdfWrapper(os.path.join(tool_pdf_directory, "pdf_escape.pdf")).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 2,
            }
        )
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = result.read()

        assert len(result.read()) == len(expected)
        assert result.read() == expected


def test_filling_docfly_pdf_form(tool_pdf_directory, request):
    expected_path = os.path.join(tool_pdf_directory, "test_filling_docfly_pdf_form.pdf")
    with open(expected_path, "rb+") as f:
        expected = f.read()
        result = PdfWrapper(os.path.join(tool_pdf_directory, "docfly.pdf")).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
            }
        )
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = result.read()

        assert len(result.read()) == len(expected)
        assert result.read() == expected


def test_filling_sejda_dropdown_pdf_form(tool_pdf_directory, request):
    expected_path = os.path.join(
        tool_pdf_directory, "test_filling_sejda_dropdown_pdf_form.pdf"
    )
    with open(expected_path, "rb+") as f:
        expected = f.read()
        result = PdfWrapper(
            os.path.join(tool_pdf_directory, "sejda_dropdown.pdf")
        ).fill({"dropdown_1": 2})
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = result.read()
        assert len(result.read()) == len(expected)
        assert result.read() == expected


def test_filling_soda_pdf_form(tool_pdf_directory, request):
    expected_path = os.path.join(tool_pdf_directory, "test_filling_soda_pdf_form.pdf")
    with open(expected_path, "rb+") as f:
        expected = f.read()
        result = PdfWrapper(os.path.join(tool_pdf_directory, "soda.pdf")).fill(
            {
                "Text1": "Helvetica 8",
                "Text2": "Helvetica 12",
                "Text3": "Helvetica 24",
                "Text4": "Helvetica 8",
                "Text5": "Helvetica 12",
                "Text6": "Helvetica 24",
                "Text7": "Helvetica 8",
                "Text8": "Helvetica 12",
                "Text9": "Helvetica 24",
            }
        )
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = result.read()

        assert len(result.read()) == len(expected)
        assert result.read() == expected


@pytest.mark.posix_only
def test_filling_pdfgear_sig(tool_pdf_directory, image_samples, request):
    expected_path = os.path.join(tool_pdf_directory, "test_filling_pdfgear_sig.pdf")
    with open(expected_path, "rb+") as f:
        expected = f.read()
        result = PdfWrapper(os.path.join(tool_pdf_directory, "pdfgear.pdf")).fill(
            {"signature": os.path.join(image_samples, "sample_signature.png")}
        )
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = result.read()

        assert len(result.read()) == len(expected)
        assert result.read() == expected

### tests/test_adobe_mode.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import Fields, PdfWrapper


def test_fill(template_stream, pdf_samples, data_dict, request):
    expected_path = os.path.join(pdf_samples, "adobe_mode", "sample_filled.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream, adobe_mode=True).fill(
            data_dict,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_two(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "adobe_mode", "dropdown", "dropdown_two.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown, adobe_mode=True).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 1,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_sejda_complex(sejda_template_complex, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "adobe_mode", "paragraph", "sample_filled_sejda_complex.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template_complex, adobe_mode=True).fill(
            {
                "checkbox": True,
                "radio": 0,
                "dropdown_font_auto_left": 0,
                "dropdown_font_auto_center": 1,
                "dropdown_font_auto_right": 2,
                "dropdown_font_ten_left": 0,
                "dropdown_font_ten_center": 1,
                "dropdown_font_ten_right": 2,
                "paragraph_font_auto_left": "paragraph_font_auto_left",
                "paragraph_font_auto_center": "paragraph_font_auto_center",
                "paragraph_font_auto_right": "paragraph_font_auto_right",
                "paragraph_font_ten_left": "paragraph_font_ten_left",
                "paragraph_font_ten_center": "paragraph_font_ten_center",
                "paragraph_font_ten_right": "paragraph_font_ten_right",
                "text__font_auto_left": "test text",
                "text_font_auto_center": "test text",
                "text_font_auto_right": "test text",
                "text_font_ten_left": "text_font_ten_left",
                "text_font_ten_center": "text_font_ten_center",
                "text_font_ten_right": "text_font_ten_right",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_issue_613(pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "adobe_mode", "issues", "613_expected.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(pdf_samples, "scenario", "issues", "613.pdf"), adobe_mode=True
        ).fill(
            {
                "301 Full name": "John Smith",
                "301 Address Street": "1234 road number 6",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_sample_template_library(
    pdf_samples, image_samples, sample_font_stream, request
):
    expected_path = os.path.join(
        pdf_samples, "adobe_mode", "test_sample_template_library.pdf"
    )

    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"), adobe_mode=True)
            .register_font("new_font", sample_font_stream)
            .create_field(
                Fields.TextField(
                    name="new_text_field_widget",
                    page_number=1,
                    x=60,
                    y=710,
                )
            )
            .create_field(
                Fields.CheckBoxField(
                    name="new_checkbox_widget",
                    page_number=1,
                    x=100,
                    y=600,
                )
            )
            .create_field(
                Fields.RadioGroup(
                    name="new_radio_group",
                    page_number=1,
                    x=[50, 100, 150],
                    y=[50, 100, 150],
                )
            )
            .create_field(
                Fields.DropdownField(
                    name="new_dropdown_widget",
                    page_number=1,
                    x=300,
                    y=710,
                    options=[
                        "foo",
                        "bar",
                        "foobar",
                    ],
                    font="new_font",
                )
            )
            .create_field(
                Fields.ImageField(
                    name="new_image_widget",
                    page_number=1,
                    x=300,
                    y=200,
                )
            )
            .create_field(
                Fields.SignatureField(
                    name="new_signature_wiget",
                    page_number=1,
                    x=300,
                    y=400,
                )
            )
            .fill(
                {
                    "new_text_field_widget": "test text",
                    "new_checkbox_widget": True,
                    "new_radio_group": 1,
                    "new_dropdown_widget": "barfoo",
                    "new_image_widget": os.path.join(image_samples, "sample_image.jpg"),
                    "new_signature_wiget": os.path.join(
                        image_samples, "sample_signature.png"
                    ),
                },
            )
        )

        obj.widgets["new_text_field_widget"].font = "new_font"
        obj.widgets["new_text_field_widget"].font_color = (1, 0, 0)
        obj.widgets["new_text_field_widget"].alignment = 2
        obj.widgets["new_checkbox_widget"].size = 40
        obj.widgets["new_radio_group"].size = 50

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/test_create_widget.py [1/6] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import Fields, PdfWrapper


def test_create_not_supported_type_not_working(template_stream):
    obj = PdfWrapper(template_stream)
    stream = obj.read()

    with pytest.warns(DeprecationWarning) as r:  # noqa: PT030, PT031
        assert (
            obj.create_widget(
                "foo",
                "foo",
                1,
                100,
                100,
            ).read()
            == stream
        )
        assert r


@pytest.mark.posix_only
def test_create_checkbox_default(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_default.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
            )
        )
        assert obj.schema["properties"]["foo"]["type"] == "boolean"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_default_filled(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_default_filled.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
            )
        )
        obj.fill(obj.sample_data)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_default_filled_flatten(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_default_filled_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
            )
        )
        obj.fill(obj.sample_data, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_complex(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_complex.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                size=100,
                button_style="check",
                tick_color=(0, 1, 0),
                bg_color=(0, 0, 1),
                border_color=(1, 0, 0),
                border_width=5,
            )
        )

        assert obj.schema["properties"]["foo"]["type"] == "boolean"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_complex_fill(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_complex_fill.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                size=100,
                button_style="check",
                tick_color=(0, 1, 0),
                bg_color=(0, 0, 1),
                border_color=(1, 0, 0),
                border_width=5,
            )
        )
        obj.fill(obj.sample_data)

        assert obj.schema["properties"]["foo"]["type"] == "boolean"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_complex_fill_flatten(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_complex_fill_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                size=100,
                button_style="check",
                tick_color=(0, 1, 0),
                bg_color=(0, 0, 1),
                border_color=(1, 0, 0),
                border_width=5,
            )
        )
        obj.fill(obj.sample_data, flatten=True)

        assert obj.schema["properties"]["foo"]["type"] == "boolean"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_check_fill(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_check_fill.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                button_style="check",
            )
        )
        obj.fill(obj.sample_data)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_check_fill_flatten(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_check_fill_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                button_style="check",
            )
        )
        obj.fill(obj.sample_data, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_circle_fill(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_circle_fill.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                button_style="circle",
            )
        )
        obj.fill(obj.sample_data)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only

### tests/test_create_widget.py [2/6] (lang=Python)

def test_create_checkbox_circle_fill_flatten(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_circle_fill_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                button_style="circle",
            )
        )
        obj.fill(obj.sample_data, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_cross_fill(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_cross_fill.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                button_style="cross",
            )
        )
        obj.fill(obj.sample_data)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_cross_fill_flatten(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_cross_fill_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                button_style="cross",
            )
        )
        obj.fill(obj.sample_data, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_default(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "widget", "test_create_text_default.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.TextField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
            )
        )
        assert obj.schema["properties"]["foo"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_alpha_bg_color(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_text_alpha_bg_color.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.TextField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                bg_color=(0, 0, 1, 0),
            )
        )
        assert obj.schema["properties"]["foo"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_align_center(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_text_align_center.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.TextField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                alignment=1,
            )
        )
        assert obj.schema["properties"]["foo"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_align_right(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_text_align_right.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.TextField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                alignment=2,
            )
        )
        assert obj.schema["properties"]["foo"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_multiline(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_text_align_multiline.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.TextField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
                multiline=True,
            )
        )
        assert obj.schema["properties"]["foo"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_default_filled(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_text_default_filled.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.TextField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
            )
        )
        obj.fill(obj.sample_data)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_default_filled_flatten(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_text_default_filled_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.TextField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
            )
        )
        obj.fill(obj.sample_data, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only

### tests/test_create_widget.py [3/6] (lang=Python)

am"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_complex(template_stream, pdf_samples, sample_font_stream, request):
    expected_path = os.path.join(pdf_samples, "widget", "test_create_text_complex.pdf")
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(template_stream)
            .register_font("new_font", sample_font_stream)
            .create_field(
                Fields.TextField(
                    name="foo",
                    page_number=1,
                    x=100,
                    y=100,
                    width=400,
                    height=400,
                    max_length=2,
                    font="new_font",
                    font_size=50,
                    font_color=(1, 0.5, 1),
                    bg_color=(0, 0, 1),
                    border_color=(1, 0, 0),
                    border_width=5,
                )
            )
        )
        assert obj.schema["properties"]["foo"]["type"] == "string"
        assert obj.schema["properties"]["foo"]["maxLength"] == 2

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_complex_filled(
    template_stream, pdf_samples, sample_font_stream, request
):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_text_complex_filled.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(template_stream)
            .register_font("new_font", sample_font_stream)
            .create_field(
                Fields.TextField(
                    name="foo",
                    page_number=1,
                    x=100,
                    y=100,
                    width=400,
                    height=400,
                    max_length=2,
                    font="new_font",
                    font_size=50,
                    font_color=(1, 0.5, 1),
                    bg_color=(0, 0, 1),
                    border_color=(1, 0, 0),
                    border_width=5,
                )
            )
        )
        obj.fill(obj.sample_data)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_complex_filled_flatten(
    template_stream, pdf_samples, sample_font_stream, request
):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_text_complex_filled_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(template_stream)
            .register_font("new_font", sample_font_stream)
            .create_field(
                Fields.TextField(
                    name="foo",
                    page_number=1,
                    x=100,
                    y=100,
                    width=400,
                    height=400,
                    max_length=2,
                    font="new_font",
                    font_size=50,
                    font_color=(1, 0.5, 1),
                    bg_color=(0, 0, 1),
                    border_color=(1, 0, 0),
                    border_width=5,
                )
            )
        )
        obj.fill(obj.sample_data, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_text_comb(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "widget", "test_create_text_comb.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.TextField(
                "foo",
                page_number=1,
                x=100,
                y=100,
                max_length=3,
                comb=True,
            )
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_persist_old_widgets_fill(
    template_stream, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_checkbox_persist_old_widgets_fill.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["test"].font_size = 30
        obj.widgets["test"].font_color = (0, 1, 0)
        obj.create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
            )
        ).fill(obj.sample_data)
        assert obj.schema["properties"]["foo"]["type"] == "boolean"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_checkbox_persist_old_widgets_fill_flatten(
    template_stream, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples,
        "widget",
        "test_create_checkbox_persist_old_widgets_fill_flatten.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["test"].font_size = 30
        obj.widgets["test"].font_color = (0, 1, 0)
        obj.create_field(
            Fields.CheckBoxField(
                name="foo",
                page_number=1,
                x=100,
                y=100,
            )
        ).fill(obj.sample_data, flatten=True)
        assert obj.schema["properties"]["foo"]["type"] == "boolean"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_widget_sejda_fill(sejda_template, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_widget_sejda_fill.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.fill(obj.sample_data).create_field(
            Fields.TextField(
                name="new_text_field_widget",
                page_number=1,
                x=72,
                y=730,
                width=120,
                height=40,
                max_length=6,
                font="Helvetica",
                font_size=20,
                font_color=(0, 0, 1),
            )
        ).fill(obj.sample_data)
        assert obj.schema["properties"]["new_text_field_widget"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only

### tests/test_create_widget.py [4/6] (lang=Python)

am"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_widget_sejda_fill_flatten_before(sejda_template, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_widget_sejda_fill_flatten_before.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.fill(obj.sample_data, flatten=True).create_field(
            Fields.TextField(
                name="new_text_field_widget",
                page_number=1,
                x=72,
                y=730,
                width=120,
                height=40,
                max_length=6,
                font="Helvetica",
                font_size=20,
                font_color=(0, 0, 1),
            )
        ).fill(obj.sample_data)
        assert obj.schema["properties"]["new_text_field_widget"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_widget_sejda_fill_flatten_after(sejda_template, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_widget_sejda_fill_flatten_after.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.fill(obj.sample_data).create_field(
            Fields.TextField(
                name="new_text_field_widget",
                page_number=1,
                x=72,
                y=730,
                width=120,
                height=40,
                max_length=6,
                font="Helvetica",
                font_size=20,
                font_color=(0, 0, 1),
            )
        ).fill(obj.sample_data, flatten=True)
        assert obj.schema["properties"]["new_text_field_widget"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_create_widget_sejda_schema(sejda_template):
    obj = PdfWrapper(sejda_template)
    old_schema = obj.schema
    schema = (
        PdfWrapper(sejda_template)
        .create_field(
            Fields.TextField(
                name="new_text_field_widget",
                page_number=1,
                x=72,
                y=730,
                width=120,
                height=40,
                max_length=6,
                font="Times-Roman",
                font_size=20,
                font_color=(0, 0, 1),
            )
        )
        .schema
    )

    assert schema["properties"]["new_text_field_widget"]
    assert len(schema["properties"]) == len(old_schema["properties"]) + 1


@pytest.mark.posix_only
def test_create_dropdown(template_stream, pdf_samples, sample_font_stream, request):
    expected_path = os.path.join(pdf_samples, "widget", "test_create_dropdown.pdf")
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(template_stream)
            .register_font("new_font", sample_font_stream)
            .create_field(
                Fields.DropdownField(
                    name="new_dropdown_widget",
                    page_number=1,
                    x=57,
                    y=700,
                    options=[
                        "foo",
                        "bar",
                        "foobar",
                    ],
                    width=120,
                    height=40,
                    font="new_font",
                    font_size=15,
                    font_color=(1, 0, 0),
                    bg_color=(0, 0, 1),
                    border_color=(1, 0, 0),
                    border_width=5,
                )
            )
        )
        assert obj.schema["properties"]["new_dropdown_widget"]["type"] == "integer"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_dropdown_with_export_values(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_dropdown_with_export_values.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.DropdownField(
                name="new_dropdown_widget",
                page_number=1,
                x=57,
                y=700,
                options=[
                    ("foo", "foo_export"),
                    ("bar", "bar_export"),
                    ("foobar", "foobar_export"),
                ],
            )
        )
        assert obj.schema["properties"]["new_dropdown_widget"]["type"] == "integer"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_cmyk_color(pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "widget", "test_fill_cmyk_color.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(pdf_samples, "widget", "sample_template_with_cmyk_color.pdf")
        ).fill({"foo": "foo"})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_cmyk_color_flatten(pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_fill_cmyk_color_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(pdf_samples, "widget", "sample_template_with_cmyk_color.pdf")
        ).fill({"foo": "foo"}, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_radio_default(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "widget", "test_create_radio_default.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.RadioGroup(
                name="radio",
                page_number=2,
                x=[50, 100, 150],
                y=[50, 100, 150],
            )
        )
        assert obj.schema["properties"]["radio"]["type"] == "integer"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_radio_default_filled(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_radio_default_filled.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.RadioGroup(
                name="radio",
                page_number=2,
                x=[50, 100, 150],
                y=[50, 100, 150],
            )
        )
        obj.fill(obj.sample_data)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only

### tests/test_create_widget.py [5/6] (lang=Python)

def test_create_radio_default_filled_flatten(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_radio_default_filled_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.RadioGroup(
                name="radio",
                page_number=2,
                x=[50, 100, 150],
                y=[50, 100, 150],
            )
        )
        obj.fill(obj.sample_data, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_radio_complex(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "widget", "test_create_radio_complex.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.RadioGroup(
                name="radio",
                page_number=2,
                x=[50, 100, 150],
                y=[50, 100, 150],
                size=50,
                button_style="check",
                shape="circle",
                tick_color=(0, 1, 0),
                bg_color=(0, 0, 1, 1),
                border_color=(1, 0, 0),
                border_width=5,
            )
        )
        assert obj.schema["properties"]["radio"]["type"] == "integer"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_create_signature_default(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_signature_default.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.SignatureField(
                name="sig_1",
                page_number=1,
                x=100,
                y=100,
                width=410,
                height=100,
            )
        )
        assert obj.schema["properties"]["sig_1"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_signature_default_filled(
    template_stream, pdf_samples, image_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_signature_default_filled.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(template_stream)
            .create_field(
                Fields.SignatureField(
                    name="sig_1",
                    page_number=1,
                    x=100,
                    y=100,
                    width=410,
                    height=100,
                )
            )
            .fill({"sig_1": os.path.join(image_samples, "sample_signature.png")})
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_signature_default_filled_flatten(
    template_stream, pdf_samples, image_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_signature_default_filled_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(template_stream)
            .create_field(
                Fields.SignatureField(
                    name="sig_1",
                    page_number=1,
                    x=100,
                    y=100,
                    width=410,
                    height=100,
                )
            )
            .fill(
                {"sig_1": os.path.join(image_samples, "sample_signature.png")},
                flatten=True,
            )
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_create_image_default(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "widget", "test_create_image_default.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).create_field(
            Fields.ImageField(
                name="image_1",
                page_number=1,
                x=100,
                y=100,
                width=192,
                height=108,
            )
        )
        assert obj.schema["properties"]["image_1"]["type"] == "string"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_create_image_default_filled(
    template_stream, pdf_samples, image_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_image_default_filled.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(template_stream)
            .create_field(
                Fields.ImageField(
                    name="image_1",
                    page_number=1,
                    x=100,
                    y=100,
                    width=192,
                    height=108,
                )
            )
            .fill({"image_1": os.path.join(image_samples, "sample_image.jpg")})
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_create_image_default_filled_flatten(
    template_stream, pdf_samples, image_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_image_default_filled_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(template_stream)
            .create_field(
                Fields.ImageField(
                    name="image_1",
                    page_number=1,
                    x=100,
                    y=100,
                    width=192,
                    height=108,
                )
            )
            .fill(
                {"image_1": os.path.join(image_samples, "sample_image.jpg")},
                flatten=True,
            )
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_required_fields(pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_required_fields.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"))
            .create_field(
                Fields.TextField(
                    name="new_text", page_number=1, x=100, y=100, required=True
                )
            )
            .create_field(
                Fields.CheckBoxField(
                    name="new_check", page_number=1, x=100, y=200, required=True
                )
            )
            .create_field(
                Fields.RadioGroup(
                    name="new_radio_group",
                    page_number=1,
                    x=[300, 350, 400],
                    y=[100, 150, 200],
                    required=True,
                )
            )
            .create_field(
                Fields.DropdownField(
                    name="new_dropdown",
                    page_number=1,
                    x=400,
                    y=400,
                    required=True,
                    options=["apple", "banana", "cherry"],
                )
            )
            .create_field(
                Fields.ImageField(
                    name="new_image",
                    page_number=1,
                    x=300,
                    y=600,
                    required=True,
                )
            )
            .create_field(
                Fields.SignatureField(
                    name="new_signature", page_number=1, x=100, y=600, required=True
                )
            )
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only

### tests/test_create_widget.py [6/6] (lang=Python)

def test_create_not_required_fields(pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_not_required_fields.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"))
            .create_field(
                Fields.TextField(
                    name="new_text", page_number=1, x=100, y=100, required=False
                )
            )
            .create_field(
                Fields.CheckBoxField(
                    name="new_check", page_number=1, x=100, y=200, required=False
                )
            )
            .create_field(
                Fields.RadioGroup(
                    name="new_radio_group",
                    page_number=1,
                    x=[300, 350, 400],
                    y=[100, 150, 200],
                    required=False,
                )
            )
            .create_field(
                Fields.DropdownField(
                    name="new_dropdown",
                    page_number=1,
                    x=400,
                    y=400,
                    required=False,
                    options=["apple", "banana", "cherry"],
                )
            )
            .create_field(
                Fields.ImageField(
                    name="new_image",
                    page_number=1,
                    x=300,
                    y=600,
                    required=False,
                )
            )
            .create_field(
                Fields.SignatureField(
                    name="new_signature", page_number=1, x=100, y=600, required=False
                )
            )
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_create_fields_with_tooltips(pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "widget", "test_create_fields_with_tooltips.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = (
            PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"))
            .create_field(
                Fields.TextField(
                    name="new_text", page_number=1, x=100, y=100, tooltip="new_text"
                )
            )
            .create_field(
                Fields.CheckBoxField(
                    name="new_check",
                    page_number=1,
                    x=100,
                    y=200,
                    tooltip="new_checkbox",
                )
            )
            .create_field(
                Fields.RadioGroup(
                    name="new_radio_group",
                    page_number=1,
                    x=[300, 350, 400],
                    y=[100, 150, 200],
                    tooltip="new_radio_group",
                )
            )
            .create_field(
                Fields.DropdownField(
                    name="new_dropdown",
                    page_number=1,
                    x=400,
                    y=400,
                    options=["apple", "banana", "cherry"],
                    tooltip="new_dropdown",
                )
            )
            .create_field(
                Fields.ImageField(
                    name="new_image",
                    page_number=1,
                    x=300,
                    y=600,
                    tooltip="new_image",
                )
            )
            .create_field(
                Fields.SignatureField(
                    name="new_signature",
                    page_number=1,
                    x=100,
                    y=600,
                    tooltip="new_signature",
                )
            )
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/test_dropdown.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import PdfWrapper


def test_schema(sample_template_with_dropdown):
    obj = PdfWrapper(sample_template_with_dropdown)

    for key, value in obj.schema["properties"].items():
        if key == "dropdown_1":
            assert value["maximum"] == 3

    assert obj.sample_data["dropdown_1"] == 3


def test_dropdown_not_specified(sample_template_with_dropdown):
    assert (
        PdfWrapper(sample_template_with_dropdown)
        .fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
            }
        )
        .read()
    )


def test_dropdown_one(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "dropdown", "test_dropdown_one.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 0,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_one_flatten(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_dropdown_one_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 0,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_two(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "dropdown", "test_dropdown_two.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 1,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_two_via_str(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "dropdown", "test_dropdown_two.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": "bar",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_two_flatten(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_dropdown_two_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 1,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_three(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "dropdown", "test_dropdown_three.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 2,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_three_flatten(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_dropdown_three_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 2,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_four(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "dropdown", "test_dropdown_four.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 3,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_four_flatten(sample_template_with_dropdown, pdf_samples, request):

### tests/test_dropdown.py [2/2] (lang=Python)

    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_dropdown_four_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown).fill(
            {
                "test_1": "test_1",
                "test_2": "test_2",
                "test_3": "test_3",
                "check_1": True,
                "check_2": True,
                "check_3": True,
                "radio_1": 1,
                "dropdown_1": 3,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_dropdown_alignment(dropdown_alignment, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "dropdown", "test_dropdown_alignment.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(dropdown_alignment).fill(
            {
                "dropdown_left": 0,
                "dropdown_center": 1,
                "dropdown_right": 2,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_dropdown_alignment_flatten(dropdown_alignment, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_dropdown_alignment_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(dropdown_alignment).fill(
            {
                "dropdown_left": 0,
                "dropdown_center": 1,
                "dropdown_right": 2,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_dropdown_alignment_flatten_then_unflatten(
    dropdown_alignment, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_dropdown_alignment_flatten_then_unflatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(dropdown_alignment).fill(
            {
                "dropdown_left": 0,
                "dropdown_center": 1,
                "dropdown_right": 2,
            },
            flatten=True,
        )
        obj.widgets["dropdown_center"].readonly = False

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_alignment_sejda(dropdown_alignment_sejda, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_dropdown_alignment_sejda.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(dropdown_alignment_sejda).fill(
            {
                "dropdown_left": 0,
                "dropdown_center": 1,
                "dropdown_right": 2,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_alignment_sejda_flatten(
    dropdown_alignment_sejda, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_dropdown_alignment_sejda_flatten.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(dropdown_alignment_sejda).fill(
            {
                "dropdown_left": 0,
                "dropdown_center": 1,
                "dropdown_right": 2,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_dropdown_alignment_sejda_flatten_then_unflatten(
    dropdown_alignment_sejda, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples,
        "dropdown",
        "test_dropdown_alignment_sejda_flatten_then_unflatten.pdf",
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(dropdown_alignment_sejda).fill(
            {
                "dropdown_left": 0,
                "dropdown_center": 1,
                "dropdown_right": 2,
            },
            flatten=True,
        )
        obj.widgets["dropdown_center"].readonly = False

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_change_dropdown_choices(sample_template_with_dropdown, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_change_dropdown_choices.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown)
        obj.widgets["dropdown_1"].choices = ["", "apple", "banana", "cherry", "dates"]

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_change_dropdown_choices_with_export_values(
    sample_template_with_dropdown, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "dropdown", "test_change_dropdown_choices_with_export_values.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown, adobe_mode=True)
        obj.widgets["dropdown_1"].choices = [
            ("apple", "apple_export"),
            ("banana", "banana_export"),
        ]

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/test_extract_values.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_text_check_values(pdf_samples, data_dict):
    obj = PdfWrapper(os.path.join(pdf_samples, "test_fill.pdf"))

    for k, v in data_dict.items():
        if v is False:
            assert obj.widgets[k].value is None
        else:
            assert obj.widgets[k].value == v


def test_radio_values(pdf_samples):
    data_dict = {
        "radio_1": 0,
        "radio_2": 1,
        "radio_3": 2,
    }
    obj = PdfWrapper(os.path.join(pdf_samples, "test_fill_radiobutton.pdf"))

    for k, v in data_dict.items():
        assert obj.widgets[k].value == v


def test_sejda_values(pdf_samples, sejda_data):
    obj = PdfWrapper(os.path.join(pdf_samples, "test_fill_sejda.pdf"))

    for k, v in sejda_data.items():
        if v is False:
            assert obj.widgets[k].value is None
        else:
            assert obj.widgets[k].value == v


def test_dropdown_values(pdf_samples):
    obj = PdfWrapper(os.path.join(pdf_samples, "dropdown", "test_dropdown_two.pdf"))

    assert obj.widgets["dropdown_1"].value == 1


def test_dropdown_default_values(pdf_samples):
    obj = PdfWrapper(os.path.join(pdf_samples, "dropdown", "test_dropdown_one.pdf"))

    assert obj.widgets["dropdown_1"].value is None


def test_sejda_dropdown_values(pdf_samples):
    obj = PdfWrapper(
        os.path.join(pdf_samples, "dropdown", "test_dropdown_alignment_sejda.pdf")
    )

    assert obj.widgets["dropdown_left"].value is None
    assert obj.widgets["dropdown_center"].value == 1
    assert obj.widgets["dropdown_right"].value == 2


def test_addition_operator_3_times_values(template_stream, data_dict):
    result = PdfWrapper()

    for _ in range(3):
        result += PdfWrapper(template_stream).fill(data_dict)

    obj = PdfWrapper(result.read())

    for k, v in obj.widgets.items():
        if k.split("-")[0] in data_dict:
            assert (v.value or False) == data_dict[k.split("-")[0]]

### tests/test_fill_max_length_text_field.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_fill_max_length_text_field_all_chars(
    sample_template_with_max_length_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_max_length_text_field_all_chars.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_max_length_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXXXXXXXX",
                "Awesomeness": True,
                "Gender": 0,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_max_length_text_field_all_chars_flatten(
    sample_template_with_max_length_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory,
        "test_fill_max_length_text_field_all_chars_flatten.pdf",
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_max_length_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXXXXXXXX",
                "Awesomeness": True,
                "Gender": 0,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_max_length_text_field_odd_chars(
    sample_template_with_max_length_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_max_length_text_field_odd_chars.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_max_length_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXX",
                "Awesomeness": True,
                "Gender": 0,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_max_length_text_field_odd_chars_flatten(
    sample_template_with_max_length_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory,
        "test_fill_max_length_text_field_odd_chars_flatten.pdf",
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_max_length_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXX",
                "Awesomeness": True,
                "Gender": 0,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_max_length_text_field_even_chars(
    sample_template_with_max_length_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_max_length_text_field_even_chars.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_max_length_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXX",
                "Awesomeness": True,
                "Gender": 0,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_max_length_text_field_even_chars_flatten(
    sample_template_with_max_length_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory,
        "test_fill_max_length_text_field_even_chars_flatten.pdf",
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_max_length_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXX",
                "Awesomeness": True,
                "Gender": 0,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_all_chars(
    sample_template_with_comb_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_comb_text_field_all_chars.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_comb_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXXXXXXXX",
                "Awesomeness": True,
                "Gender": 0,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_all_chars_flatten(
    sample_template_with_comb_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_comb_text_field_all_chars_flatten.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_comb_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXXXXXXXX",
                "Awesomeness": True,
                "Gender": 0,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_odd_chars(
    sample_template_with_comb_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_comb_text_field_odd_chars.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_comb_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXX",
                "Awesomeness": True,
                "Gender": 0,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_odd_chars_flatten(

### tests/test_fill_max_length_text_field.py [2/2] (lang=Python)

  expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_odd_chars_flatten(
    sample_template_with_comb_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_comb_text_field_odd_chars_flatten.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_comb_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXX",
                "Awesomeness": True,
                "Gender": 0,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_even_chars(
    sample_template_with_comb_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_comb_text_field_even_chars.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_comb_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXXXX",
                "Awesomeness": True,
                "Gender": 0,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_even_chars_flatten(
    sample_template_with_comb_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory,
        "test_fill_comb_text_field_even_chars_flatten.pdf",
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_comb_text_field).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXXXX",
                "Awesomeness": True,
                "Gender": 0,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_void(
    sample_template_with_comb_text_field, max_length_expected_directory, request
):
    expected_path = os.path.join(
        max_length_expected_directory, "test_fill_comb_text_field_void.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_comb_text_field).fill({})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_even_chars_right_aligned(
    sample_template_with_comb_text_field_right_aligned,
    max_length_expected_directory,
    request,
):
    expected_path = os.path.join(
        max_length_expected_directory,
        "test_fill_comb_text_field_even_chars_right_aligned.pdf",
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_comb_text_field_right_aligned).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXXXX",
                "Awesomeness": True,
                "Gender": 0,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_comb_text_field_even_chars_right_aligned_flatten(
    sample_template_with_comb_text_field_right_aligned,
    max_length_expected_directory,
    request,
):
    expected_path = os.path.join(
        max_length_expected_directory,
        "test_fill_comb_text_field_even_chars_right_aligned_flatten.pdf",
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sample_template_with_comb_text_field_right_aligned).fill(
            {
                "FirstName": "John",
                "MiddleName": "Joe",
                "LastName": "XXXXXX",
                "Awesomeness": True,
                "Gender": 0,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/test_fill_method.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

from PyPDFForm import PdfWrapper


def test_fill_with_varied_int_values(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "fill_method", "test_fill_with_varied_int_values.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(
            {
                "test": 100,
                "test_2": -250,
                "test_3": 0,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_with_boolean_and_int_values(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "fill_method", "test_fill_with_boolean_and_int_values.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(
            {
                "test": 42,
                "test_2": True,
                "test_3": False,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_with_empty_string_and_int(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "fill_method", "test_fill_with_empty_string_and_int.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(
            {
                "test": 42,
                "test_2": "",
                "test_3": 33,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_with_large_and_small_ints(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "fill_method", "test_fill_with_large_and_small_ints.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(
            {
                "test": 999999999999,
                "test_2": -999999999999,
                "test_3": 1,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_with_varied_float_values(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "fill_method", "test_fill_with_varied_float_values.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(
            {
                "test": 1.5,
                "test_2": 13.8,
                "test_3": 543,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_with_negative_and_positive_floats_and_int(
    template_stream, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples,
        "fill_method",
        "test_fill_with_negative_and_positive_floats_and_int.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(
            {
                "test": -1.5,
                "test_2": -6.9,
                "test_3": 22,
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/test_font_widths.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

# https://github.com/chinapandaman/PyPDFForm/issues/1142
# https://github.com/chinapandaman/PyPDFForm/pull/1154

import os
from io import BytesIO
from unittest.mock import MagicMock, patch

import pytest
from fontTools.ttLib import TTLibError
from pypdf import PdfWriter

from PyPDFForm import PdfWrapper
from PyPDFForm.constants import (DEFAULT_ASSUMED_GLYPH_WIDTH, DR,
                                 ENCODING_TABLE_SIZE, AcroForm, Font,
                                 FontDescriptor, MissingWidth, Widths)
from PyPDFForm.font import compute_font_glyph_widths


@pytest.fixture
def pdf_font_widths_and_missing(static_pdfs, sample_font_stream):
    path = os.path.join(static_pdfs, "sample_template.pdf")
    obj = PdfWrapper(path, adobe_mode=True)
    obj.register_font("new_font_name", sample_font_stream)

    writer = PdfWriter(BytesIO(obj.read()))
    fonts = writer._root_object[AcroForm][DR][Font]  # type: ignore # noqa: SLF001
    font_obj = fonts[obj._available_fonts["new_font_name"]].get_object()  # type: ignore # noqa: SLF001

    pdf_widths_array = font_obj.get(Widths, [])
    descriptor_obj = font_obj[FontDescriptor].get_object()
    missing_width = descriptor_obj.get(MissingWidth, DEFAULT_ASSUMED_GLYPH_WIDTH)

    return pdf_widths_array, missing_width


def test_compute_font_glyph_widths_with_valid_font(sample_font_stream):
    missing_width = 500.0
    widths = compute_font_glyph_widths(BytesIO(sample_font_stream), missing_width)

    assert isinstance(widths, list)
    assert len(widths) == ENCODING_TABLE_SIZE
    assert all(isinstance(w, float) for w in widths)

    # with this font, not all widths should be equal to missing width
    assert any(w != missing_width for w in widths)


def test_compute_font_glyph_widths_with_default_missing_width(sample_font_stream):
    widths = compute_font_glyph_widths(
        BytesIO(sample_font_stream), DEFAULT_ASSUMED_GLYPH_WIDTH
    )

    assert isinstance(widths, list)
    assert len(widths) == ENCODING_TABLE_SIZE
    assert all(isinstance(w, float) for w in widths)

    # with this font, not all widths should be equal to missing width
    assert any(w != DEFAULT_ASSUMED_GLYPH_WIDTH for w in widths)


def test_compute_font_widths_raises_for_invalid_ttf():
    broken_stream = BytesIO(b"not a real font")
    with pytest.raises(TTLibError):
        compute_font_glyph_widths(
            broken_stream, missing_width=DEFAULT_ASSUMED_GLYPH_WIDTH
        )


def test_compute_font_glyph_widths_with_missing_tables():
    with patch("PyPDFForm.font.FT_TTFont") as mock_ttfont:
        mock_font = MagicMock()
        mock_font.get.side_effect = lambda table: None
        mock_ttfont.return_value = mock_font

        dummy_stream = BytesIO(b"anything")
        widths = compute_font_glyph_widths(dummy_stream, DEFAULT_ASSUMED_GLYPH_WIDTH)

    assert len(widths) == ENCODING_TABLE_SIZE
    assert all(w == DEFAULT_ASSUMED_GLYPH_WIDTH for w in widths)


def test_pdf_widths_array_has_256_entries(pdf_font_widths_and_missing):
    pdf_widths_array, _ = pdf_font_widths_and_missing
    assert len(pdf_widths_array) == ENCODING_TABLE_SIZE


def test_pdf_widths_match_computed_font_widths(
    pdf_font_widths_and_missing, sample_font_stream
):
    pdf_widths_array, missing_width = pdf_font_widths_and_missing
    computed_widths_array = compute_font_glyph_widths(
        BytesIO(sample_font_stream), missing_width
    )

    assert len(pdf_widths_array) == len(computed_widths_array)

    # Assume that rounding floats to 3 decimal is accurate for most cases
    assert all(
        round(pdf_width, 3) == round(computed_width, 3)
        for pdf_width, computed_width in zip(
            pdf_widths_array, computed_widths_array, strict=True
        )
    )


def test_pdf_widths_use_missing_width_for_unmapped_glyphs(pdf_font_widths_and_missing):
    pdf_widths_array, missing_width = pdf_font_widths_and_missing

    # Assume that rounding floats to 3 decimal is accurate for most cases
    assert round(missing_width, 3) == round(pdf_widths_array[128], 3)
    assert round(missing_width, 3) == round(pdf_widths_array[129], 3)

### tests/test_functional.py [1/5] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest
from jsonschema import ValidationError, validate

from PyPDFForm import PdfWrapper
from PyPDFForm.constants import DA, UNIQUE_SUFFIX_LENGTH, T, V
from PyPDFForm.middleware.base import Widget
from PyPDFForm.middleware.text import Text
from PyPDFForm.template import get_widgets_by_page


def test_base_schema_definition():
    assert Widget("foo").schema_definition == {}


def test_write(template_stream, pdf_samples):
    assert PdfWrapper(template_stream).write(
        os.path.join(pdf_samples, "sample_template.pdf")
    )


def test_fill(template_stream, pdf_samples, data_dict, request):
    expected_path = os.path.join(pdf_samples, "test_fill.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(
            data_dict,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()
        assert len(obj.read()) == len(obj.read())
        assert obj.read() == obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_flatten(template_stream, pdf_samples, data_dict, request):
    expected_path = os.path.join(pdf_samples, "test_fill_flatten.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(data_dict, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()
        assert len(obj.read()) == len(obj.read())
        assert obj.read() == obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_flatten_then_unflatten(template_stream, pdf_samples, data_dict, request):
    expected_path = os.path.join(pdf_samples, "test_fill_flatten_then_unflatten.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).fill(data_dict, flatten=True)
        obj.widgets["test_2"].readonly = False
        obj.widgets["check_3"].readonly = False

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()
        assert len(obj.read()) == len(obj.read())
        assert obj.read() == obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_register_bad_fonts():
    assert not PdfWrapper().register_font("foo", b"foo").read()
    assert not PdfWrapper().register_font("foo", "foo").read()

    obj = PdfWrapper().register_font("foo", b"foo")
    assert "foo" not in obj.fonts


@pytest.mark.posix_only
def test_register_global_font_fill(
    template_stream, pdf_samples, sample_font_stream, data_dict, request
):
    expected_path = os.path.join(pdf_samples, "test_register_global_font_fill.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_stream).register_font(
            "new_font",
            sample_font_stream,
        )
        assert "new_font" in obj.fonts
        for v in obj.widgets.values():
            if isinstance(v, Text):
                v.font = "new_font"
        obj.fill(
            data_dict,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_register_global_font_fill_flatten(
    template_stream, pdf_samples, sample_font_stream, data_dict, request
):
    expected_path = os.path.join(
        pdf_samples, "test_register_global_font_fill_flatten.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_stream).register_font(
            "new_font",
            sample_font_stream,
        )
        for v in obj.widgets.values():
            if isinstance(v, Text):
                v.font = "new_font"
        obj.fill(
            data_dict,
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_font_20(template_stream, pdf_samples, data_dict, request):
    expected_path = os.path.join(pdf_samples, "test_fill_font_20.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_stream)
        for v in obj.widgets.values():
            if isinstance(v, Text):
                v.font_size = 20
        obj.fill(
            data_dict,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_font_20_flatten(template_stream, pdf_samples, data_dict, request):
    expected_path = os.path.join(pdf_samples, "test_fill_font_20_flatten.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_stream)
        for v in obj.widgets.values():
            if isinstance(v, Text):
                v.font_size = 20
        obj.fill(
            data_dict,
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_font_color_red(template_stream, pdf_samples, data_dict, request):
    expected_path = os.path.join(pdf_samples, "test_fill_font_color_red.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_stream)
        for v in obj.widgets.values():
            if isinstance(v, Text):
                v.font_color = (1, 0, 0)
        obj.fill(
            data_dict,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_font_color_red_flatten(template_stream, pdf_samples, data_dict, request):
    expected_path = os.path.join(pdf_samples, "test_fill_font_color_red_flatten.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_stream)
        for v in obj.widgets.values():
            if isinstance(v, Text):
                v.font_color = (1, 0, 0)
        obj.fill(data_dict, flatten=True)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_fill_with_customized_widgets(
    template_stream, pdf_samples, sample_font_stream, data_dict, request
):
    expected_path = os.path.join(pdf_samples, "test_fill_with_customized_widgets.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_stream).register_font(
            "new_font",
            sample_font_stream,
        )
        obj.widgets["test"].font = "new_font"
        obj.widgets["test"].font_size = 20
        obj.widgets["test"].font_color = (1, 0, 0)
        obj.widgets["test_2"].font_color = (0, 1, 0)
        obj.fill(
            data_dict,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only

### tests/test_functional.py [2/5] (lang=Python)

def test_fill_with_customized_widgets_flatten(
    template_stream, pdf_samples, sample_font_stream, data_dict, request
):
    expected_path = os.path.join(
        pdf_samples, "test_fill_with_customized_widgets_flatten.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_stream).register_font(
            "new_font",
            sample_font_stream,
        )
        obj.widgets["test"].font = "new_font"
        obj.widgets["test"].font_size = 20
        obj.widgets["test"].font_color = (1, 0, 0)
        obj.widgets["test_2"].font_color = (0, 1, 0)
        obj.fill(
            data_dict,
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_radiobutton(template_with_radiobutton_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_fill_radiobutton.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_with_radiobutton_stream).fill(
            {
                "radio_1": 0,
                "radio_2": 1,
                "radio_3": 2,
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_radiobutton_flatten(
    template_with_radiobutton_stream, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_fill_radiobutton_flatten.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_with_radiobutton_stream).fill(
            {
                "radio_1": 0,
                "radio_2": 1,
                "radio_3": 2,
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_radiobutton_flatten_then_unflatten(
    template_with_radiobutton_stream, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "test_fill_radiobutton_flatten_then_unflatten.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(template_with_radiobutton_stream).fill(
            {
                "radio_1": 0,
                "radio_2": 1,
                "radio_3": 2,
            },
            flatten=True,
        )
        obj.widgets["radio_2"].readonly = False

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_sejda(sejda_template, pdf_samples, sejda_data, request):
    expected_path = os.path.join(pdf_samples, "test_fill_sejda.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sejda_template).fill(sejda_data)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_sejda_flatten(sejda_template, pdf_samples, sejda_data, request):
    expected_path = os.path.join(pdf_samples, "test_fill_sejda_flatten.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sejda_template).fill(
            sejda_data,
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_sejda_flatten_then_unflatten(
    sejda_template, pdf_samples, sejda_data, request
):
    expected_path = os.path.join(
        pdf_samples, "test_fill_sejda_flatten_then_unflatten.pdf"
    )
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(sejda_template).fill(
            sejda_data,
            flatten=True,
        )
        obj.widgets["buyer_name"].readonly = False
        obj.widgets["at_future_date"].readonly = False
        obj.widgets["purchase_option"].readonly = False

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_draw_text_on_one_page(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_draw_text_on_one_page.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).draw_text(
            "drawn_text",
            1,
            300,
            225,
            font_size=20,
            font_color=(1, 0, 0),
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_draw_multiline_text_on_one_page(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "test_draw_multiline_text_on_one_page.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).draw_text(
            "drawn_text\ndrawn_text\ndrawn_text",
            1,
            300,
            225,
            font_size=20,
            font_color=(1, 0, 0),
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_draw_text_on_radio_template(
    template_with_radiobutton_stream, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_draw_text_on_radio_template.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_with_radiobutton_stream).draw_text(
            "drawn_text",
            1,
            300,
            225,
            font_size=20,
            font_color=(1, 0, 0),
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_draw_text_on_sejda_template(sejda_template, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_draw_text_on_sejda_template.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template).draw_text(
            "drawn_text",
            1,
            300,
            225,
            font_size=20,
            font_color=(1, 0, 0),
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_draw_image_on_one_page(template_stream, image_samples, pdf_samples, request):

### tests/test_functional.py [3/5] (lang=Python)

    expected_path = os.path.join(pdf_samples, "test_draw_image_on_one_page.pdf")
    with open(expected_path, "rb+") as f:
        with open(os.path.join(image_samples, "sample_image.jpg"), "rb+") as _f:
            obj = PdfWrapper(template_stream).draw_image(
                _f,
                2,
                100,
                100,
                400,
                225,
            )

        expected = f.read()

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_draw_image_on_radio_template(
    template_with_radiobutton_stream, image_samples, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_draw_image_on_radio_template.pdf")
    with open(expected_path, "rb+") as f:
        with open(os.path.join(image_samples, "sample_image.jpg"), "rb+") as _f:
            obj = PdfWrapper(template_with_radiobutton_stream).draw_image(
                _f,
                2,
                100,
                100,
                400,
                225,
            )

        expected = f.read()

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_draw_image_on_sejda_template(
    sejda_template, image_samples, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_draw_image_on_sejda_template.pdf")
    with open(expected_path, "rb+") as f:
        with open(os.path.join(image_samples, "sample_image.jpg"), "rb+") as _f:
            obj = PdfWrapper(sejda_template).draw_image(
                _f,
                2,
                100,
                100,
                400,
                225,
            )

        expected = f.read()

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_draw_png_image_on_one_page(
    template_stream, image_samples, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_draw_png_image_on_one_page.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).draw_image(
            os.path.join(image_samples, "sample_png_image.png"),
            2,
            100,
            100,
            400,
            225,
        )

        expected = f.read()

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_draw_transparent_png_image_on_one_page(
    template_stream, image_samples, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "test_draw_transparent_png_image_on_one_page.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).draw_image(
            os.path.join(image_samples, "sample_transparent_png.png"),
            1,
            100,
            100,
            400,
            225,
        )

        expected = f.read()

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()
        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_addition_operator_3_times(template_stream, data_dict):
    result = PdfWrapper()

    for _ in range(3):
        result += PdfWrapper(template_stream).fill(data_dict)

    assert len((result + PdfWrapper()).read()) == len(result.read())
    assert (result + PdfWrapper()).read() == result.read()
    assert len(result.pages) == len(PdfWrapper(template_stream).pages) * 3


def test_merging_unique_suffix(template_stream):
    result = PdfWrapper()

    for i in range(10):
        obj = PdfWrapper(
            PdfWrapper(template_stream).fill({"test": f"value-{i}"}).read()
        )
        result += obj

    merged = PdfWrapper(result.read())

    for page, widgets in get_widgets_by_page(result.read()).items():
        for widget in widgets:
            assert widget[T] in merged.widgets
            if widget[T] == "test":
                assert widget[V] == "value-0"
            elif V in widget and "value-" in widget[V]:
                assert widget[V] == f"value-{page // 3}"
                assert widget[T].split("-")[0] == "test"
                assert len(widget[T].split("-")[1]) == UNIQUE_SUFFIX_LENGTH


def test_merge_preserve_font_and_data(template_stream, sample_font_stream):
    result = PdfWrapper()

    for i in range(10):
        obj = PdfWrapper(template_stream).register_font("new_font", sample_font_stream)
        obj.widgets["test"].font = "new_font"
        result += obj.fill({"test": f"test_{i}"})

    for page, widgets in get_widgets_by_page(result.read()).items():
        for widget in widgets:
            if widget[T] == "test":
                assert widget[V] == "test_0"
                assert widget[DA].startswith("/F1")
            elif widget[T].startswith("test-"):
                assert widget[V] == f"test_{page // 3}"
                assert widget[DA].startswith("/F1")


def test_schema(sample_template_with_comb_text_field):
    data = {
        "FirstName": "John",
        "MiddleName": "Joe",
        "LastName": "XXXXXXX",
        "Awesomeness": True,
        "Gender": 0,
    }
    schema = PdfWrapper(sample_template_with_comb_text_field).schema

    assert schema["type"] == "object"
    properties = schema["properties"]
    for key, value in data.items():
        if key == "LastName":
            assert properties[key]["maxLength"] == 7
        if isinstance(value, str):
            assert properties[key]["type"] == "string"
        elif isinstance(value, bool):
            assert properties[key]["type"] == "boolean"
        elif isinstance(value, int):
            assert properties[key]["type"] == "integer"
            assert properties[key]["maximum"] == 1

    validate(instance=data, schema=schema)

    data["LastName"] = "XXXXXXXX"
    try:
        validate(instance=data, schema=schema)
        raise AssertionError
    except ValidationError:
        pass

    data["LastName"] = "XXXXXXX"
    data["Gender"] = 1
    validate(instance=data, schema=schema)

    data["Gender"] = 2
    try:
        validate(instance=data, schema=schema)
        raise AssertionError
    except ValidationError:
        pass


def test_sample_data(sejda_template_complex):
    obj = PdfWrapper(sejda_template_complex)
    try:
        validate(instance=obj.sample_data, schema=obj.schema)
    except ValidationError:
        raise AssertionError from ValidationError

    widget = Widget("foo")
    try:
        widget.sample_value()
        raise AssertionError
    except NotImplementedError:
        pass


def test_sample_data_max_boundary(sample_template_with_comb_text_field):
    obj = PdfWrapper(sample_template_with_comb_text_field)
    try:
        validate(instance=obj.sample_data, schema=obj.schema)
    except ValidationError:
        raise AssertionError from ValidationError

    assert obj.sample_data["LastName"] == "LastNam"
    assert obj.sample_data["Gender"] == 1


def test_fill_right_aligned(

### tests/test_functional.py [4/5] (lang=Python)

sertionError from ValidationError

    assert obj.sample_data["LastName"] == "LastNam"
    assert obj.sample_data["Gender"] == 1


def test_fill_right_aligned(
    sample_template_with_right_aligned_text_field, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_fill_right_aligned.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_right_aligned_text_field).fill(
            {
                "name": "Hans Mustermann",
                "fulladdress": "Musterstr. 12, 82903 Musterdorf, Musterland",
                "advisorname": "Karl Test",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_right_aligned_flatten(
    sample_template_with_right_aligned_text_field, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_fill_right_aligned_flatten.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_right_aligned_text_field).fill(
            {
                "name": "Hans Mustermann",
                "fulladdress": "Musterstr. 12, 82903 Musterdorf, Musterland",
                "advisorname": "Karl Test",
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_version(pdf_samples):
    versions = ["1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "2.0"]

    for version in versions:
        obj = PdfWrapper(os.path.join(pdf_samples, "versions", f"{version}.pdf"))
        assert obj.version == version
        assert obj.change_version("2.0").version == "2.0"

    obj = PdfWrapper(os.path.join(pdf_samples, "versions", "unknown.pdf"))
    assert obj.version is None


@pytest.mark.posix_only
def test_fill_font_color(sample_template_with_font_colors, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_fill_font_color.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_font_colors).fill(
            {
                "red_12": "red",
                "green_14": "green",
                "blue_16": "blue",
                "mixed_auto": "mixed",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_fill_font_color_flatten(
    sample_template_with_font_colors, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_fill_font_color_flatten.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_font_colors).fill(
            {
                "red_12": "red",
                "green_14": "green",
                "blue_16": "blue",
                "mixed_auto": "mixed",
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_fill_complex_fonts(sample_template_with_complex_fonts, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_fill_complex_fonts.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_complex_fonts).fill(
            {
                "Courier": "Test",
                "Courier-Bold": "Test",
                "Courier-BoldOblique": "Test",
                "Courier-Oblique": "Test",
                "Helvetica": "Test",
                "Helvetica-Bold": "Test",
                "Helvetica-BoldOblique": "Test",
                "Helvetica-Oblique": "Test",
                "Times-Bold": "Test",
                "Times-BoldItalic": "Test",
                "Times-Italic": "Test",
                "Times-Roman": "Test",
            },
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_fill_complex_fonts_flatten(
    sample_template_with_complex_fonts, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_fill_complex_fonts_flatten.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_complex_fonts).fill(
            {
                "Courier": "Test",
                "Courier-Bold": "Test",
                "Courier-BoldOblique": "Test",
                "Courier-Oblique": "Test",
                "Helvetica": "Test",
                "Helvetica-Bold": "Test",
                "Helvetica-BoldOblique": "Test",
                "Helvetica-Oblique": "Test",
                "Times-Bold": "Test",
                "Times-BoldItalic": "Test",
                "Times-Italic": "Test",
                "Times-Roman": "Test",
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_pages(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "pages", "test_pages.pdf")
    obj = PdfWrapper(template_stream)

    with open(expected_path, "rb+") as f:
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.pages[0].read()
        assert obj.pages[0].read() == f.read()


@pytest.mark.posix_only
def test_pages_preserve_font(template_stream, pdf_samples, sample_font_stream, request):
    expected_path = os.path.join(pdf_samples, "pages", "test_pages_preserve_font.pdf")
    obj = PdfWrapper(template_stream)
    obj.register_font("new_font", sample_font_stream)
    obj.widgets["test_2"].font = "new_font"

    with open(expected_path, "rb+") as f:
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.pages[1].read()
        assert obj.pages[1].read() == f.read()


def test_sejda_pages_1(sejda_template, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "pages", "test_sejda_pages_1.pdf")
    obj = PdfWrapper(sejda_template)

    with open(expected_path, "rb+") as f:
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.pages[0].read()
        assert obj.pages[0].read() == f.read()


def test_sejda_pages_2(sejda_template, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "pages", "test_sejda_pages_2.pdf")
    obj = PdfWrapper(sejda_template)

    with open(expected_path, "rb+") as f:
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.pages[1].read()
        assert obj.pages[1].read() == f.read()


def test_radio_pages_1(template_with_radiobutton_stream, pdf_samples, request):

### tests/test_functional.py [5/5] (lang=Python)

    expected_path = os.path.join(pdf_samples, "pages", "test_radio_pages_1.pdf")
    obj = PdfWrapper(template_with_radiobutton_stream)

    with open(expected_path, "rb+") as f:
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.pages[0].read()
        assert obj.pages[0].read() == f.read()


def test_radio_pages_2(template_with_radiobutton_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "pages", "test_radio_pages_2.pdf")
    obj = PdfWrapper(template_with_radiobutton_stream)

    with open(expected_path, "rb+") as f:
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.pages[1].read()
        assert obj.pages[1].read() == f.read()


def test_radio_pages_3(template_with_radiobutton_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "pages", "test_radio_pages_3.pdf")
    obj = PdfWrapper(template_with_radiobutton_stream)

    with open(expected_path, "rb+") as f:
        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.pages[2].read()
        assert obj.pages[2].read() == f.read()


def test_pages_inherit_attributes(template_stream):
    obj = PdfWrapper(
        template_stream,
        use_full_widget_name=True,
    )

    for page in obj.pages:
        assert getattr(page, "use_full_widget_name")


def test_generate_coordinate_grid(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_generate_coordinate_grid.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).generate_coordinate_grid((1, 0, 1))

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_generate_coordinate_grid_margin_50(template_stream, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "test_generate_coordinate_grid_margin_50.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).generate_coordinate_grid((1, 0, 1), margin=50)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_checkbox_change_size(template_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_checkbox_change_size.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["check"].size = 50
        obj.widgets["check_2"].size = 40
        obj.widgets["check_3"].size = 60

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_radio_change_size(template_with_radiobutton_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_radio_change_size.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_with_radiobutton_stream)
        obj.widgets["radio_1"].size = 50
        obj.widgets["radio_2"].size = 40
        obj.widgets["radio_3"].size = 60

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_image(
    sample_template_with_image_field, image_samples, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_fill_image.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_image_field).fill(
            {"image_1": os.path.join(image_samples, "sample_image.jpg")},
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_image_flatten(
    sample_template_with_image_field, image_samples, pdf_samples, request
):
    expected_path = os.path.join(pdf_samples, "test_fill_image_flatten.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_image_field).fill(
            {"image_1": os.path.join(image_samples, "sample_image.jpg")},
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_update_radio_key(template_with_radiobutton_stream, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_update_radio_key.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_with_radiobutton_stream)
        obj.update_widget_key("radio_3", "RADIO")
        obj.fill({"RADIO": 0})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_update_sejda_key(sejda_template, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_update_sejda_key.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.update_widget_key("year", "YEAR")
        obj.update_widget_key("at_future_date", "FUTURE_DATE")
        obj.update_widget_key("purchase_option", "PURCHASE_OPTION")
        obj.update_widget_key("buyer_signed_date", "BUYER_SIGNED_DATE")
        obj.fill(
            {
                "YEAR": "12",
                "FUTURE_DATE": True,
                "PURCHASE_OPTION": 1,
                "BUYER_SIGNED_DATE": "2012-01-01",
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_uncheck_checkbox(pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_uncheck_checkbox.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(os.path.join(pdf_samples, "sample_template_filled.pdf")).fill(
            {"check": False, "check_2": False, "check_3": False},
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_uncheck_checkbox_flatten(pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "test_uncheck_checkbox_flatten.pdf")
    with open(
        expected_path,
        "rb+",
    ) as f:
        obj = PdfWrapper(os.path.join(pdf_samples, "sample_template_filled.pdf")).fill(
            {"check": False, "check_2": False, "check_3": False},
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/test_paragraph.py [1/2] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import PdfWrapper


def test_paragraph_y_coordinate(sample_template_with_paragraph, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_y_coordinate.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph).fill(
            {"paragraph_1": "test paragraph"}
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_paragraph_y_coordinate_flatten(
    sample_template_with_paragraph, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_y_coordinate_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph).fill(
            {"paragraph_1": "test paragraph"},
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_paragraph_auto_wrap(sample_template_with_paragraph, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_auto_wrap.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph).fill(
            {
                "paragraph_1": "t xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx t"
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_paragraph_auto_wrap_flatten(
    sample_template_with_paragraph, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_auto_wrap_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph).fill(
            {
                "paragraph_1": "t xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx t"
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_paragraph_auto_font(
    sample_template_with_paragraph_auto_font, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_auto_font.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph_auto_font).fill(
            {"paragraph": "test paragraph"}
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_paragraph_auto_font_flatten(
    sample_template_with_paragraph_auto_font, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_auto_font_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph_auto_font).fill(
            {"paragraph": "test paragraph"}, flatten=True
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_paragraph_auto_font_auto_wrap(
    sample_template_with_paragraph_auto_font, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_auto_font_auto_wrap.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph_auto_font).fill(
            {
                "paragraph": "t xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx t"
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_paragraph_auto_font_auto_wrap_flatten(
    sample_template_with_paragraph_auto_font, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_auto_font_auto_wrap_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph_auto_font).fill(
            {
                "paragraph": "t xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx t"
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_sejda_complex(sejda_template_complex, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_fill_sejda_complex.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template_complex).fill(
            {
                "checkbox": True,
                "radio": 0,
                "dropdown_font_auto_left": 0,
                "dropdown_font_auto_center": 1,
                "dropdown_font_auto_right": 2,
                "dropdown_font_ten_left": 0,
                "dropdown_font_ten_center": 1,
                "dropdown_font_ten_right": 2,
                "paragraph_font_auto_left": "paragraph_font_auto_left",
                "paragraph_font_auto_center": "paragraph_font_auto_center",
                "paragraph_font_auto_right": "paragraph_font_auto_right",
                "paragraph_font_ten_left": "paragraph_font_ten_left",
                "paragraph_font_ten_center": "paragraph_font_ten_center",
                "paragraph_font_ten_right": "paragraph_font_ten_right",
                "text__font_auto_left": "test text",
                "text_font_auto_center": "test text",
                "text_font_auto_right": "test text",
                "text_font_ten_left": "text_font_ten_left",
                "text_font_ten_center": "text_font_ten_center",
                "text_font_ten_right": "text_font_ten_right",
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_sejda_complex_flatten(sejda_template_complex, pdf_samples, request):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_fill_sejda_complex_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template_complex).fill(
            {
                "checkbox": True,
                "radio": 0,
                "dropdown_font_auto_left": 0,
                "dropdown_font_auto_center": 1,
                "dropdown_font_auto_right": 2,
                "dropdown_font_ten_left": 0,
                "dropdown_font_ten_center": 1,
                "dropdown_font_ten_right": 2,
                "paragraph_font_auto_left": "paragraph_font_auto_left",
                "paragraph_font_auto_center": "paragraph_font_auto_center",
                "paragraph_font_auto_right": "paragraph_font_auto_right",
                "paragraph_font_ten_left": "paragraph_font_ten_left",
                "paragraph_font_ten_center": "paragraph_font_ten_center",
                "paragraph_font_ten_right": "paragraph_font_ten_right",
                "text__font_auto_left": "test text",
                "text_font_auto_center": "test text",
                "text_font_auto_right": "test text",
                "text_font_ten_left": "text_font_ten_left",
                "text_font_ten_center": "text_font_ten_center",
                "text_font_ten_right": "text_font_ten_right",
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_sejda_complex_paragraph_multiple_line_alignment(

### tests/test_paragraph.py [2/2] (lang=Python)

    sejda_template_complex, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples,
        "paragraph",
        "test_sejda_complex_paragraph_multiple_line_alignment.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template_complex).fill(
            {
                "paragraph_font_auto_left": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_auto_right": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_auto_center": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_left": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_right": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_center": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_sejda_complex_paragraph_multiple_line_alignment_flatten(
    sejda_template_complex, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples,
        "paragraph",
        "test_sejda_complex_paragraph_multiple_line_alignment_flatten.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template_complex).fill(
            {
                "paragraph_font_auto_left": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_auto_right": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_auto_center": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_left": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_right": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_center": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_paragraph_complex(sample_template_paragraph_complex, pdf_samples, request):
    expected_path = os.path.join(pdf_samples, "paragraph", "test_paragraph_complex.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_paragraph_complex).fill(
            {
                "paragraph_font_auto_left": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_auto_right": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_auto_center": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_left": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_right": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_center": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_paragraph_complex_flatten(
    sample_template_paragraph_complex, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_complex_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_paragraph_complex).fill(
            {
                "paragraph_font_auto_left": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_auto_right": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_auto_center": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_left": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_right": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
                "paragraph_font_ten_center": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_paragraph_max_length(
    sample_template_with_paragraph_max_length, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_max_length.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph_max_length).fill(
            {
                "paragraph": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
            }
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_paragraph_max_length_flatten(
    sample_template_with_paragraph_max_length, pdf_samples, request
):
    expected_path = os.path.join(
        pdf_samples, "paragraph", "test_paragraph_max_length_flatten.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_paragraph_max_length).fill(
            {
                "paragraph": "Lorem ipsum dolor sit amet, consectetur adipiscing elit",
            },
            flatten=True,
        )

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/test_signature.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import PdfWrapper


@pytest.mark.posix_only
def test_fill_signature(pdf_samples, image_samples, request):
    expected_path = os.path.join(pdf_samples, "signature", "test_fill_signature.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(pdf_samples, "signature", "sample_template_with_signature.pdf")
        ).fill({"signature": os.path.join(image_samples, "sample_signature.png")})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_signature_schema(pdf_samples):
    obj = PdfWrapper(
        os.path.join(pdf_samples, "signature", "sample_template_with_signature.pdf")
    )

    assert obj.widgets["signature"].schema_definition == {"type": "string"}


def test_signature_sample_value(pdf_samples):
    obj = PdfWrapper(
        os.path.join(pdf_samples, "signature", "sample_template_with_signature.pdf")
    )

    assert obj.widgets["signature"].sample_value == os.path.expanduser(
        "~/Downloads/sample_image.jpg"
    )


@pytest.mark.posix_only
def test_fill_signature_overlap(pdf_samples, image_samples, request):
    expected_path = os.path.join(
        pdf_samples, "signature", "test_fill_signature_overlap.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(
                pdf_samples, "signature", "sample_template_with_signature_overlap.pdf"
            )
        ).fill({"signature": os.path.join(image_samples, "sample_signature.png")})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_fill_signature_overlap_not_preserve_aspect_ratio(
    pdf_samples, image_samples, request
):
    expected_path = os.path.join(
        pdf_samples,
        "signature",
        "test_fill_signature_overlap_not_preserve_aspect_ratio.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(
                pdf_samples, "signature", "sample_template_with_signature_overlap.pdf"
            )
        )
        obj.widgets["signature"].preserve_aspect_ratio = False
        obj.fill({"signature": os.path.join(image_samples, "sample_signature.png")})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_fill_small_icon(pdf_samples, image_samples, request):
    expected_path = os.path.join(pdf_samples, "signature", "test_fill_small_icon.pdf")
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(
                pdf_samples, "signature", "sample_template_with_signature_overlap.pdf"
            )
        )
        obj.fill({"signature": os.path.join(image_samples, "small_icon.png")})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_fill_small_icon_not_preserve_aspect_ratio(pdf_samples, image_samples, request):
    expected_path = os.path.join(
        pdf_samples, "signature", "test_fill_small_icon_not_preserve_aspect_ratio.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(
                pdf_samples, "signature", "sample_template_with_signature_overlap.pdf"
            )
        )
        obj.widgets["signature"].preserve_aspect_ratio = False
        obj.fill({"signature": os.path.join(image_samples, "small_icon.png")})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_vertical_image(pdf_samples, image_samples, request):
    expected_path = os.path.join(
        pdf_samples, "signature", "test_fill_vertical_image.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(
                pdf_samples, "signature", "sample_template_with_signature_overlap.pdf"
            )
        )
        obj.fill({"signature": os.path.join(image_samples, "vertical_image.jpg")})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_fill_vertical_image_not_preserve_aspect_ratio(
    pdf_samples, image_samples, request
):
    expected_path = os.path.join(
        pdf_samples,
        "signature",
        "test_fill_vertical_image_not_preserve_aspect_ratio.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(
            os.path.join(
                pdf_samples, "signature", "sample_template_with_signature_overlap.pdf"
            )
        )
        obj.widgets["signature"].preserve_aspect_ratio = False
        obj.fill({"signature": os.path.join(image_samples, "vertical_image.jpg")})

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

### tests/test_use_full_widget_name.py [1/1] (lang=Python)

# -*- coding: utf-8 -*-

import pytest

from PyPDFForm import PdfWrapper


def test_init(sample_template_with_full_key):
    obj = PdfWrapper(sample_template_with_full_key, use_full_widget_name=True)
    assert "Gain de 2 classes.0" in obj.widgets
    assert "0" not in obj.widgets


def test_sample_data(sample_template_with_full_key):
    obj = PdfWrapper(sample_template_with_full_key, use_full_widget_name=True)
    assert "Gain de 2 classes.0" in obj.sample_data
    assert "0" not in obj.sample_data


def test_fill(sample_template_with_full_key):
    obj_1 = PdfWrapper(sample_template_with_full_key, use_full_widget_name=True)
    obj_2 = PdfWrapper(sample_template_with_full_key)

    assert (
        obj_1.fill({"Gain de 2 classes.0": True}).read()
        == obj_2.fill({"0": True}).read()
    )


def test_update_widget_key(sample_template_with_full_key):
    obj = PdfWrapper(sample_template_with_full_key, use_full_widget_name=True)

    with pytest.raises(NotImplementedError):
        obj.update_widget_key("0", "foo")


def test_commit_widget_key_updates(sample_template_with_full_key):
    obj = PdfWrapper(sample_template_with_full_key, use_full_widget_name=True)

    with pytest.raises(NotImplementedError):
        obj.commit_widget_key_updates()


def test_schema(sample_template_with_full_key):
    obj = PdfWrapper(sample_template_with_full_key, use_full_widget_name=True)
    assert "Gain de 2 classes.0" in obj.schema["properties"]
    assert "0" not in obj.schema

### tests/test_widget_attr_trigger.py [1/3] (lang=Python)

# -*- coding: utf-8 -*-

import os

import pytest

from PyPDFForm import Fields, PdfWrapper


@pytest.mark.posix_only
def test_register_font_no_form_fields(pdf_samples, sample_font_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_register_font_no_form_fields.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(os.path.join(pdf_samples, "dummy.pdf"))
        obj.register_font("new_font", sample_font_stream).create_field(
            Fields.TextField(name="foo", page_number=1, x=100, y=100, font="new_font")
        )
        obj.draw_text("foo", 1, 200, 200, font="new_font")

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_set_text_field_font(pdf_samples, font_samples, template_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_text_field_font.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream).register_font(
            "new_font", os.path.join(font_samples, "LiberationSerif-BoldItalic.ttf")
        )
        obj.widgets["test"].font = "new_font"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_set_text_field_font_sejda(pdf_samples, font_samples, sejda_template, request):
    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_text_field_font_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template).register_font(
            "new_font", os.path.join(font_samples, "LiberationSerif-Italic.ttf")
        )
        obj.register_font(
            "new_font_2", os.path.join(font_samples, "LiberationSerif-Bold.ttf")
        )
        obj.widgets["buyer_name"].font = "new_font_2"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_font_size(pdf_samples, template_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_text_field_font_size.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["test"].font_size = 30

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_font_size_sejda(pdf_samples, sejda_template, request):
    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_text_field_font_size_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["buyer_name"].font_size = 30

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_font_color(pdf_samples, template_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_text_field_font_color.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["test"].font_color = (1, 0, 0)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_font_color_sejda(pdf_samples, sejda_template, request):
    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_text_field_font_color_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["buyer_name"].font_color = (1, 0, 0)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_alignment(pdf_samples, template_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_text_field_alignment.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["test"].alignment = 2

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_alignment_sejda(pdf_samples, sejda_template, request):
    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_text_field_alignment_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["buyer_name"].alignment = 2

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_max_length(pdf_samples, template_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_text_field_max_length.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["test"].max_length = 2

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_max_length_sejda(pdf_samples, sejda_template, request):
    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_text_field_max_length_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["buyer_name"].max_length = 2

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_comb(pdf_samples, template_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_text_field_comb.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["test"].max_length = 2
        obj.widgets["test"].comb = True

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_comb_sejda(pdf_samples, sejda_template, request):

### tests/test_widget_attr_trigger.py [2/3] (lang=Python)

    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_text_field_comb_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["buyer_name"].max_length = 2
        obj.widgets["buyer_name"].comb = True

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_multiline(pdf_samples, template_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_text_field_multiline.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["test"].multiline = True

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_multiline_sejda(pdf_samples, sejda_template, request):
    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_text_field_multiline_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["buyer_name"].multiline = True

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_checkbox_size(pdf_samples, template_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_checkbox_size.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_stream)
        obj.widgets["check"].size = 30

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_checkbox_size_sejda(pdf_samples, sejda_template, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_checkbox_size_sejda.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["date_of_this_bill"].size = 30

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_radio_size(pdf_samples, template_with_radiobutton_stream, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_radio_size.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(template_with_radiobutton_stream)
        obj.widgets["radio_1"].size = 40

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_radio_size_sejda(pdf_samples, sejda_template, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_radio_size_sejda.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["purchase_option"].size = 40

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_set_dropdown_font(
    pdf_samples, sample_template_with_dropdown, sample_font_stream, request
):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_dropdown_font.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown)
        obj.register_font("new_font", sample_font_stream)
        obj.widgets["dropdown_1"].font = "new_font"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


@pytest.mark.posix_only
def test_set_dropdown_font_sejda(
    pdf_samples, dropdown_alignment_sejda, sample_font_stream, request
):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_dropdown_font_sejda.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(dropdown_alignment_sejda)
        obj.register_font("new_font", sample_font_stream)
        obj.widgets["dropdown_left"].font = "new_font"

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_dropdown_font_size(pdf_samples, sample_template_with_dropdown, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_dropdown_font_size.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown)
        obj.widgets["dropdown_1"].font_size = 30

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_dropdown_font_size_sejda(pdf_samples, dropdown_alignment_sejda, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_dropdown_font_size_sejda.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(dropdown_alignment_sejda)
        obj.widgets["dropdown_left"].font_size = 30

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_dropdown_font_color(pdf_samples, sample_template_with_dropdown, request):
    expected_path = os.path.join(
        pdf_samples, "test_widget_attr_trigger", "test_set_dropdown_font_color.pdf"
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sample_template_with_dropdown)
        obj.widgets["dropdown_1"].font_color = (1, 0, 0)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_dropdown_font_color_sejda(pdf_samples, dropdown_alignment_sejda, request):
    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_dropdown_font_color_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(dropdown_alignment_sejda)
        obj.widgets["dropdown_left"].font_color = (1, 0, 0)

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected


def test_set_text_field_required_sejda(pdf_samples, sejda_template, request):

### tests/test_widget_attr_trigger.py [3/3] (lang=Python)

    expected_path = os.path.join(
        pdf_samples,
        "test_widget_attr_trigger",
        "test_set_text_field_required_sejda.pdf",
    )
    with open(expected_path, "rb+") as f:
        obj = PdfWrapper(sejda_template)
        obj.widgets["buyer_address"].required = True

        request.config.results["expected_path"] = expected_path
        request.config.results["stream"] = obj.read()

        expected = f.read()

        assert len(obj.read()) == len(expected)
        assert obj.read() == expected

